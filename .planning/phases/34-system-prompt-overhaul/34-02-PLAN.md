# Phase 34-02: Dynamic Context Injection (Layered Assembly)

**Phase:** 34 — System Prompt Overhaul
**Plan:** 02 of 2
**Wave:** 1 (foundation — no dependencies beyond 34-01)
**Status:** PENDING
**Depends on:** 34-01 (Layer 1 prompt + injectable blocks + buildMentorSystemPrompt must exist)
**Autonomous:** true
**Authority:** `.planning/OPERATING-BIBLE.md` (canonical reference for all behavior rules)

## Files Modified

- `lib/ai/prompts.ts` — Add `FounderContext` type, `buildFounderContextBlock` function
- `app/api/fred/chat/route.ts` — Wire layered prompt assembly into chat pipeline
- `lib/fred/service.ts` — Accept system prompt override in FredServiceOptions
- `lib/fred/machine.ts` — Pass system prompt through to actors via context
- `lib/fred/actors/decide.ts` — Enforce Next 3 Actions output standard
- `lib/fred/actors/load-memory.ts` — Return founder profile data alongside memory context

## Goal

Wire the layered prompt assembly into the chat pipeline so that every conversation gets a prompt composed of:
- **Layer 1**: Core instructions (from 34-01, always present)
- **Founder Context**: Dynamic data about this specific founder (profile, memory, session state)
- **Injectable Protocols**: Founder Intake (when data missing), Weekly Check-In (when check-in detected), Red Flag scanning (always), Standard Protocols (when triggered)
- **Layer 2/3**: Diagnostic router + framework (from existing diagnostic engine, injected when signals justify it)

This is what makes FRED feel like a mentor who knows you -- the prompt adapts to your data, stage, and current needs.

## Architecture (Layered Assembly)

```
Chat Route (POST /api/fred/chat)
  │
  ├─ Load founder profile from profiles table
  ├─ Load memory context (existing — load-memory.ts)
  ├─ Run diagnostic analysis (existing — diagnostic-engine.ts)
  ├─ Detect: missing intake fields? weekly check-in? active protocol?
  │
  ├─ Call buildMentorSystemPrompt({
  │     founderContext: { stage, revenue, runway, ... },     // Founder data
  │     diagnosticState: { currentMode, signals },           // Layer 2 router
  │     missingIntakeFields: ['runway', 'constraint'],       // Triggers Intake Protocol
  │     isWeeklyCheckin: false,                              // Triggers Check-In Protocol
  │     includeRedFlagScanning: true,                        // Always on
  │   })
  │
  │   Assembly order:
  │   1. Layer 1: FRED_CAREY_SYSTEM_PROMPT (core instructions)
  │   2. Founder Context block (dynamic profile data)
  │   3. Layer 2: Diagnostic router (positioning/investor mode)
  │   4. Injectable protocols (intake, check-in, red flags)
  │   5. Layer 3: Active framework (if diagnostic triggered)
  │
  └─ Pass assembled prompt to FredService as systemPrompt override
```

## Tasks

### Task 1: Define `FounderContext` type in `lib/ai/prompts.ts`

Add a type that captures everything the prompt needs about the founder:

```typescript
export interface FounderContext {
  // From profiles table / onboarding
  name?: string;
  startupName?: string;
  stage?: string;          // "idea" | "mvp" | "pre-seed" | "seed" | "series-a"
  industry?: string;
  productStatus?: string;  // "concept" | "prototype" | "live" | "revenue"
  revenueRange?: string;
  teamSize?: number;
  fundingHistory?: string;
  runway?: string;
  mainChallenge?: string;
  ninetyDayGoal?: string;

  // From memory / enrichment
  challenges?: string[];
  competitorsMentioned?: string[];
  metricsShared?: Record<string, string>;

  // Conversation state (what has been established)
  establishedFacts?: string[];   // e.g. ["problem defined", "buyer identified"]
  missingFields?: string[];      // Fields from Founder Intake Protocol still needed
  currentProcessStep?: string;   // Which of the 9 steps they're on

  // Session context
  isFirstConversation?: boolean;
  isWeeklyCheckin?: boolean;
  lastConversationDate?: string;
}
```

### Task 2: Implement `buildFounderContextBlock` in `lib/ai/prompts.ts`

Create a function that converts `FounderContext` into a formatted string block for the system prompt:

```typescript
export function buildFounderContextBlock(ctx: FounderContext): string
```

Output format:
```
## FOUNDER CONTEXT (What You Know About This Founder)

**Founder:** [name] | **Startup:** [startupName] | **Stage:** [stage]
**Industry:** [industry] | **Product:** [productStatus]
**Revenue:** [revenueRange] | **Team:** [teamSize] people
**Runway:** [runway] | **Funding History:** [fundingHistory]
**Primary Challenge:** [mainChallenge]
**90-Day Goal:** [ninetyDayGoal]

### What Has Been Established
- [list of established facts]

### What Still Needs Validation
- [list of missing fields — triggers Founder Intake Protocol]

### Current Process Position
Step [N] of 9: [step name] — [step objective]

### Session Context
- [First conversation / returning founder / weekly check-in]
- Last spoke: [date]
```

Rules:
- Only include fields that have values — do not show "undefined" or "N/A"
- If many fields are missing, add instruction: "Prioritize gathering: [top 2 missing fields] in this conversation"
- If `isFirstConversation` is true, add: "This is your first real conversation with this founder. Reference what onboarding captured and go deeper — do not re-ask basics."
- If `isWeeklyCheckin` is true, add: "This appears to be a weekly check-in. Use the Weekly Check-In Protocol."

### Task 3: Wire `buildMentorSystemPrompt` with layered assembly

The `buildMentorSystemPrompt` function is defined in 34-01 Task 6. This task ensures the chat route calls it with the correct layered parameters. The function signature (from 34-01):

```typescript
export function buildMentorSystemPrompt(options: {
  founderContext?: FounderContext;
  diagnosticState?: DiagnosticState;
  missingIntakeFields?: string[];       // Triggers Founder Intake Protocol injection
  isWeeklyCheckin?: boolean;             // Triggers Weekly Check-In Protocol injection
  includeRedFlagScanning?: boolean;      // Defaults to true
  activeProtocol?: 'deck-review' | 'strategic-report' | 'rewrite';
}): string
```

The chat route must compute each parameter:
- `founderContext`: built from profile + memory data (Task 6 below)
- `diagnosticState`: from `runDiagnosticAnalysis` (existing engine)
- `missingIntakeFields`: compare FOUNDER_INTAKE_FIELDS against profile data
- `isWeeklyCheckin`: detect from user message (phrases like "checking in", "weekly update", "what should I focus on")
- `includeRedFlagScanning`: always true
- `activeProtocol`: detect from user message or context (deck upload, report request)

### Task 4: Update `FredServiceOptions` and `FredService` to accept systemPrompt

In `lib/fred/service.ts`:

```typescript
export interface FredServiceOptions {
  userId: string;
  sessionId: string;
  enableObservability?: boolean;
  systemPrompt?: string;  // NEW: dynamic system prompt override
  onStateChange?: (state: string, context: FredContext) => void;
  onError?: (error: Error) => void;
}
```

Pass `systemPrompt` into the XState actor's input so it flows through to the decide actor where response content is built.

In `lib/fred/machine.ts`, add `systemPrompt` to the machine's input type and store it in context:
```typescript
// In FredContext (lib/fred/types.ts)
systemPrompt?: string;
```

### Task 5: Update `load-memory.ts` to return founder profile data

Extend `loadMemoryActor` to also query the `profiles` table and return profile fields as part of the memory context. This gives the chat route the data it needs to build `FounderContext`.

Add to the return type:
```typescript
// In MemoryContext (lib/fred/types.ts)
founderProfile?: {
  name?: string;
  stage?: string;
  industry?: string;
  revenueRange?: string;
  teamSize?: number;
  fundingHistory?: string;
  onboardingCompleted?: boolean;
};
```

**NOTE:** The `enrichment_data` JSONB column does NOT exist in the profiles table (migration 037 only added `enriched_at` and `enrichment_source`). Existing code in `fireEnrichment` references it but this is a latent bug. Do NOT query `enrichment_data`. Instead, rely on semantic memory facts (loaded separately) for conversation-extracted data like revenue hints, competitors, and metrics.

Query the profiles table in parallel with existing memory loads:
```typescript
const [episodes, facts, decisions, profile] = await Promise.all([
  // ... existing queries ...
  supabase.from("profiles").select("name, stage, industry, revenue_range, team_size, funding_history, onboarding_completed, challenges").eq("id", userId).single().catch(() => ({ data: null })),
]);
```

### Task 6: Wire dynamic context injection in `app/api/fred/chat/route.ts`

This is the integration point. In the `handlePost` function, after auth/rate-limit but before creating FredService:

1. Load the founder's profile from Supabase (or use data from memory context)
2. Run diagnostic analysis on the conversation context
3. Assemble the FounderContext from profile + memory + request context
4. Call `buildMentorSystemPrompt` to get the dynamic prompt
5. Pass the assembled prompt to `createFredService` as `systemPrompt`

```typescript
// After rate limit checks, before FredService creation:

// 1. Load founder profile for context injection
const supabase = createServiceClient();
const { data: profile } = await supabase
  .from("profiles")
  .select("name, stage, industry, revenue_range, team_size, funding_history, onboarding_completed, challenges")
  .eq("id", userId)
  .single();

// 2. Build founder context
const founderContext: FounderContext = {
  name: profile?.name || undefined,
  stage: profile?.stage || context?.stage || undefined,
  industry: profile?.industry || undefined,
  startupName: context?.startupName || undefined,
  revenueRange: profile?.revenue_range || undefined,
  teamSize: profile?.team_size || undefined,
  fundingHistory: profile?.funding_history || undefined,
  mainChallenge: (profile?.challenges as string[])?.[0] || undefined,
  isFirstConversation: isNewSession && profile?.onboarding_completed,
};

// 3. Determine missing fields for intake protocol
const intakeFields = ['stage', 'revenueRange', 'teamSize', 'mainChallenge'];
founderContext.missingFields = intakeFields.filter(f => !founderContext[f as keyof FounderContext]);

// 4. Run diagnostic analysis (existing engine, now wired in)
const diagnosticResult = runDiagnosticAnalysis(
  FRED_CAREY_SYSTEM_PROMPT,
  { messages: [], hasUploadedDeck: false, userProfile: { stage: profile?.stage } }
);

// 5. Detect weekly check-in signal from user message
const checkinPatterns = /\b(check.?in|weekly update|what should i focus on|weekly review)\b/i;
const isWeeklyCheckin = checkinPatterns.test(message);

// 6. Assemble dynamic prompt using layered architecture
const systemPrompt = buildMentorSystemPrompt({
  founderContext,
  diagnosticState: diagnosticResult.state,
  missingIntakeFields: founderContext.missingFields,
  isWeeklyCheckin,
  includeRedFlagScanning: true,
});

// 6. Pass to service
const fredService = createFredService({
  userId,
  sessionId: effectiveSessionId,
  enableObservability: true,
  systemPrompt,
});
```

### Task 7: Update `decideActor` to use dynamic system prompt in response building

In `lib/fred/actors/decide.ts`, update `buildResponseContent` to append the Next 3 Actions block to every substantive response (auto_execute, recommend, escalate). This enforces the output standard regardless of the prompt:

```typescript
function appendNextActions(content: string, synthesis: SynthesisResult): string {
  if (!synthesis.nextSteps || synthesis.nextSteps.length === 0) return content;

  const actions = synthesis.nextSteps.slice(0, 3);
  return `${content}\n\n## Next 3 Actions\n${actions.map((a, i) => `${i + 1}. ${a}`).join("\n")}`;
}
```

Call this at the end of `buildResponseContent` for all action types except "clarify" and "defer" (which are questions, not substantive responses).

## Verification

- [ ] `FounderContext` type is exported from `lib/ai/prompts.ts`
- [ ] `buildFounderContextBlock` produces formatted context block with only populated fields
- [ ] `buildMentorSystemPrompt` composes Layer 1 + founder context + Layer 2 router + injectable protocols + Layer 3 framework
- [ ] Chat route passes `missingIntakeFields` to trigger Founder Intake Protocol injection
- [ ] Chat route detects weekly check-in signals and passes `isWeeklyCheckin: true`
- [ ] Red Flag scanning is always injected (`includeRedFlagScanning: true`)
- [ ] Only ONE framework injected at a time (Layer 3 via diagnostic engine)
- [ ] `FredServiceOptions` accepts optional `systemPrompt`
- [ ] Chat route loads founder profile and passes it through context injection pipeline
- [ ] `loadMemoryActor` returns founder profile data from profiles table (NO `enrichment_data` column)
- [ ] `decideActor` appends "Next 3 Actions" to every substantive response
- [ ] Empty/minimal founder data produces a valid prompt (no "undefined" strings)
- [ ] First conversation after onboarding references captured data
- [ ] Diagnostic engine state is passed through to the system prompt
- [ ] Total assembled prompt (Layer 1 + context + protocols + framework) stays under ~6000 tokens
- [ ] `npx tsc --noEmit` passes
- [ ] Existing chat API contract is preserved (same request/response schema)
- [ ] Existing tests pass (no breaking changes)

## Must-Haves

1. Chat route request/response schema is unchanged — this is purely a backend prompt improvement
2. `buildMentorSystemPrompt` is the single entry point for prompt assembly — no other code path should construct the system prompt ad-hoc
3. Profile query must not block the critical path if it fails — graceful fallback to static prompt
4. No new database tables or migrations required — uses existing `profiles` table columns
5. Dynamic context block must be concise — target <500 tokens for the founder context section to avoid eating the context window
6. Diagnostic engine integration must be backward-compatible — if no diagnostic state, use default (founder-os mode)
