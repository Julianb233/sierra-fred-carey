# Phase 38-01: Wire Diagnostic Engine & Framework Mode Switching

**Phase:** 38 — Framework & Mode Integration
**Plan:** 01 of 1
**Wave:** 1 (single wave, all tasks sequential)
**Status:** PENDING
**Depends on:** Phase 36 (conversation state + structured flow must exist)
**Autonomous:** true
**Authority:** `.planning/OPERATING-BIBLE.md` (canonical reference for all behavior rules)

## Files Modified

- `app/api/fred/chat/route.ts` — Run diagnostic analysis, persist mode, inject active framework
- `lib/ai/diagnostic-engine.ts` — Refactor to use persisted state, accept ConversationStateContext, return mode transitions
- `lib/ai/prompts.ts` — Add `buildFrameworkInjectionBlock`, `buildModeTransitionBlock`
- `lib/db/conversation-state.ts` — Add DAL functions for active_mode and mode_context columns
- `lib/fred/types.ts` — Add `DiagnosticModeContext` to ConversationStateContext
- `lib/fred/actors/validate-input.ts` — Add framework signal detection to validated output

## Goal

Wire the diagnostic engine (`lib/ai/diagnostic-engine.ts`) into the chat pipeline so that:
- Every message is analyzed for positioning and investor signals (silently)
- Mode transitions happen automatically based on signal strength (never user-chosen)
- The correct framework document (Positioning, Investor Lens, or 9-Step Process) is injected into the system prompt
- Mode state persists across messages via `active_mode` and `mode_context` columns (migration 052)
- Framework introductions are delivered exactly once, tracked in `mode_context.introduction_state`
- The 9-Step Startup Process serves as the default backbone for `founder-os` mode

This plan handles the INTEGRATION — the diagnostic engine and framework modules already exist in code but are NOT wired into the chat route.

## Architecture

```
Chat Route (POST /api/fred/chat)
  |
  +-- [EXISTING] Auth, rate limit, tier check
  +-- [EXISTING] buildFounderContext (profile + semantic facts + step progress)
  +-- [EXISTING] Load conversation state (Phase 36)
  |
  +-- [NEW] Load persisted mode from conversation state (active_mode, mode_context)
  +-- [NEW] Run diagnostic signal detection on current message
  +-- [NEW] Determine mode transition (founder-os -> positioning | investor-readiness)
  +-- [NEW] If mode changed: persist new active_mode + mode_context
  +-- [NEW] Build framework injection block for system prompt
  +-- [NEW] If introduction needed: build introduction block
  |
  +-- [MODIFIED] System prompt = base + founderContext + stepGuidance + frameworkBlock
  |
  +-- [EXISTING] createFredService, process message, stream response
  |
  +-- [NEW] Post-response: update signal_history in mode_context (fire-and-forget)
```

### Key Design Decisions

1. **Mode persists across messages.** The diagnostic engine currently re-analyzes from scratch on each call. Phase 38 changes this: `active_mode` is loaded from the DB, and mode only changes when new signals are strong enough to override the current mode. This prevents mode flickering.

2. **Hysteresis for mode transitions.** Entering a mode requires strong signals. Exiting requires the ABSENCE of signals for 3+ consecutive messages. This prevents a single off-topic question from resetting the mode.

3. **Framework injection is prompt-layer only.** The framework document (Investor Lens prompt, Positioning prompt, or 9-Step Process prompt) is appended to the system prompt. The LLM decides how to apply it. No structural code forces specific framework behavior.

4. **Introductions are delivered exactly once.** When FRED first enters Positioning or Investor mode, the introduction language is injected as a one-time system prompt instruction. `mode_context.introduction_state` tracks whether each introduction has been delivered.

5. **9-Step Process is always the backbone.** In `founder-os` mode, the step guidance block (from Phase 36) IS the active framework. In Positioning or Investor mode, the specialized framework is injected IN ADDITION to step guidance, not replacing it.

6. **Signal detection stays in validate-input.ts.** The diagnostic engine's signal detection functions are called from the validate-input actor, keeping detection structural. The mode transition decision happens in the chat route, keeping it at the orchestration layer.

## Tasks

### Task 1: Add DAL functions for `active_mode` and `mode_context` in `lib/db/conversation-state.ts`

Add functions to read and write the new columns from migration 052.

```typescript
import type { DiagnosticMode } from "@/lib/ai/diagnostic-engine";

// ─── Types ───────────────────────────────────────────────────────────────────

export interface ModeIntroductionState {
  introduced: boolean;
  introduced_at: string | null;
  trigger: string | null;
}

export interface ModeContext {
  activated_at: string | null;
  activated_by: string | null;
  introduction_state: {
    positioning: ModeIntroductionState;
    investor: ModeIntroductionState;
  };
  signal_history: Array<{
    signal: string;
    framework: string;
    detected_at: string;
    context: string;
  }>;
  formal_assessments: {
    offered: boolean;
    accepted: boolean;
  };
  /** Number of consecutive messages without framework signals (for hysteresis) */
  quiet_count: number;
}

// ─── Functions ───────────────────────────────────────────────────────────────

/**
 * Get the current active mode and mode context for a user.
 * Returns defaults if columns are not yet populated.
 */
export async function getActiveMode(
  userId: string
): Promise<{ activeMode: DiagnosticMode; modeContext: ModeContext }> {
  const supabase = await createServiceClient();
  const { data, error } = await supabase
    .from("fred_conversation_state")
    .select("active_mode, mode_context")
    .eq("user_id", userId)
    .single();

  if (error || !data) {
    return {
      activeMode: "founder-os",
      modeContext: createDefaultModeContext(),
    };
  }

  return {
    activeMode: (data.active_mode as DiagnosticMode) || "founder-os",
    modeContext: (data.mode_context as ModeContext) || createDefaultModeContext(),
  };
}

function createDefaultModeContext(): ModeContext {
  return {
    activated_at: null,
    activated_by: null,
    introduction_state: {
      positioning: { introduced: false, introduced_at: null, trigger: null },
      investor: { introduced: false, introduced_at: null, trigger: null },
    },
    signal_history: [],
    formal_assessments: { offered: false, accepted: false },
    quiet_count: 0,
  };
}

/**
 * Update active mode and mode context.
 * Called when a mode transition occurs or signal history is updated.
 * Fire-and-forget — never blocks the response.
 */
export async function updateActiveMode(
  userId: string,
  activeMode: DiagnosticMode,
  modeContext: ModeContext
): Promise<void> {
  // Cap signal_history to 20 entries
  if (modeContext.signal_history.length > 20) {
    modeContext.signal_history = modeContext.signal_history.slice(-20);
  }

  const supabase = await createServiceClient();
  await supabase
    .from("fred_conversation_state")
    .update({
      active_mode: activeMode,
      mode_context: modeContext,
      updated_at: new Date().toISOString(),
    })
    .eq("user_id", userId);
}

/**
 * Mark a framework introduction as delivered.
 * Called after FRED's response includes the introduction language.
 */
export async function markIntroductionDelivered(
  userId: string,
  framework: "positioning" | "investor",
  trigger: string
): Promise<void> {
  const { modeContext } = await getActiveMode(userId);
  modeContext.introduction_state[framework] = {
    introduced: true,
    introduced_at: new Date().toISOString(),
    trigger,
  };
  const supabase = await createServiceClient();
  await supabase
    .from("fred_conversation_state")
    .update({
      mode_context: modeContext,
      updated_at: new Date().toISOString(),
    })
    .eq("user_id", userId);
}
```

### Task 2: Refactor `lib/ai/diagnostic-engine.ts` to support persisted state

The current diagnostic engine is stateless — it re-analyzes all messages from scratch. Refactor to:
1. Accept persisted mode as input (don't always start from `founder-os`)
2. Return a mode transition decision (stay, enter, or exit)
3. Implement hysteresis (3+ quiet messages to exit a mode)

**Do NOT rewrite the existing functions.** Add new functions alongside them.

```typescript
// ─── Persisted Mode Support (Phase 38) ────────────────────────────────────

import type { ModeContext } from "@/lib/db/conversation-state";

/** How many consecutive messages without signals before exiting a mode */
const MODE_EXIT_THRESHOLD = 3;

export interface ModeTransitionResult {
  /** The mode FRED should be in after this message */
  newMode: DiagnosticMode;
  /** Whether a transition occurred */
  transitioned: boolean;
  /** Direction of transition */
  direction: "enter" | "exit" | "none";
  /** Which framework was entered or exited */
  framework: "positioning" | "investor" | null;
  /** Whether the introduction needs to be delivered */
  needsIntroduction: boolean;
  /** Signals detected in this message */
  detectedSignals: string[];
  /** Updated mode context (caller persists this) */
  updatedModeContext: ModeContext;
}

/**
 * Determine mode transition based on current message + persisted state.
 *
 * Rules:
 * 1. Investor signals override everything (investor > positioning > founder-os)
 * 2. Entering a mode requires at least 1 strong signal
 * 3. Exiting a mode requires MODE_EXIT_THRESHOLD consecutive quiet messages
 * 4. Introduction is needed only if the framework hasn't been introduced yet
 */
export function determineModeTransition(
  currentMessage: string,
  currentMode: DiagnosticMode,
  modeContext: ModeContext,
  hasUploadedDeck: boolean = false
): ModeTransitionResult {
  // Detect signals in current message only (not all history)
  const posSignals = detectPositioningSignals(currentMessage);
  const invSignals = detectInvestorSignals(currentMessage, hasUploadedDeck);

  const hasPositioningSignals = needsPositioningFramework(posSignals);
  const hasInvestorSignals = needsInvestorLens(invSignals);

  // Build signal list for history
  const detectedSignals: string[] = [];
  if (posSignals.icpVagueOrUndefined) detectedSignals.push("icp_vague");
  if (posSignals.everyoneAsTarget) detectedSignals.push("everyone_target");
  if (posSignals.genericMessaging) detectedSignals.push("generic_messaging");
  if (posSignals.highEffortLowTraction) detectedSignals.push("high_effort_low_traction");
  if (invSignals.mentionsFundraising) detectedSignals.push("mentions_fundraising");
  if (invSignals.mentionsValuation) detectedSignals.push("mentions_valuation");
  if (invSignals.mentionsDeck) detectedSignals.push("mentions_deck");
  if (invSignals.asksAboutReadiness) detectedSignals.push("asks_readiness");
  if (invSignals.uploadedDeck) detectedSignals.push("uploaded_deck");

  // Clone mode context for mutation
  const updatedContext: ModeContext = JSON.parse(JSON.stringify(modeContext));

  // Add to signal history
  if (detectedSignals.length > 0) {
    const framework = hasInvestorSignals ? "investor" : "positioning";
    updatedContext.signal_history.push({
      signal: detectedSignals.join(","),
      framework,
      detected_at: new Date().toISOString(),
      context: currentMessage.substring(0, 100),
    });
    updatedContext.quiet_count = 0;
  } else {
    updatedContext.quiet_count = (updatedContext.quiet_count || 0) + 1;
  }

  // --- Mode transition logic ---

  let newMode: DiagnosticMode = currentMode;
  let transitioned = false;
  let direction: "enter" | "exit" | "none" = "none";
  let framework: "positioning" | "investor" | null = null;

  // Case 1: Investor signals detected — enter investor mode (highest priority)
  if (hasInvestorSignals && currentMode !== "investor-readiness") {
    newMode = "investor-readiness";
    transitioned = true;
    direction = "enter";
    framework = "investor";
    updatedContext.activated_at = new Date().toISOString();
    updatedContext.activated_by = "signal_detected";
  }
  // Case 2: Positioning signals detected — enter positioning mode (only if not in investor)
  else if (hasPositioningSignals && currentMode === "founder-os") {
    newMode = "positioning";
    transitioned = true;
    direction = "enter";
    framework = "positioning";
    updatedContext.activated_at = new Date().toISOString();
    updatedContext.activated_by = "signal_detected";
  }
  // Case 3: No signals for a while — consider exiting to founder-os
  else if (
    currentMode !== "founder-os" &&
    !hasInvestorSignals &&
    !hasPositioningSignals &&
    updatedContext.quiet_count >= MODE_EXIT_THRESHOLD
  ) {
    newMode = "founder-os";
    transitioned = true;
    direction = "exit";
    framework = currentMode === "investor-readiness" ? "investor" : "positioning";
    updatedContext.activated_at = null;
    updatedContext.activated_by = null;
    updatedContext.quiet_count = 0;
  }

  // Determine if introduction is needed
  let needsIntroduction = false;
  if (transitioned && direction === "enter" && framework) {
    const introState = updatedContext.introduction_state[framework];
    needsIntroduction = !introState.introduced;
  }

  return {
    newMode,
    transitioned,
    direction,
    framework,
    needsIntroduction,
    detectedSignals,
    updatedModeContext: updatedContext,
  };
}
```

**Important:** The existing `analyzeConversation`, `runDiagnosticAnalysis`, and `generateDiagnosticSystemPrompt` functions remain untouched for backward compatibility. The new `determineModeTransition` function is the Phase 38 entry point.

### Task 3: Add `buildFrameworkInjectionBlock` and `buildModeTransitionBlock` to `lib/ai/prompts.ts`

Add prompt-layer functions that inject the correct framework document and optional introduction language.

```typescript
import { generatePositioningPrompt } from "@/lib/ai/frameworks/positioning";
import { generateInvestorLensPrompt } from "@/lib/ai/frameworks/investor-lens";
import { generateFullProcessPrompt } from "@/lib/ai/frameworks/startup-process";
import type { DiagnosticMode } from "@/lib/ai/diagnostic-engine";

/**
 * Build the framework injection block for the system prompt.
 * Returns the full framework document for the active mode.
 *
 * In founder-os mode, the 9-Step Process is the default backbone
 * (step guidance from Phase 36 already handles this, so we return
 * a minimal reinforcement block rather than the full process prompt).
 *
 * In positioning/investor mode, the specialized framework is injected
 * as an ACTIVE FRAMEWORK section.
 */
export function buildFrameworkInjectionBlock(
  activeMode: DiagnosticMode
): string {
  switch (activeMode) {
    case "positioning":
      return `\n\n## ACTIVE FRAMEWORK: Positioning Readiness\n\n${generatePositioningPrompt()}`;

    case "investor-readiness":
      return `\n\n## ACTIVE FRAMEWORK: Investor Lens\n\n${generateInvestorLensPrompt()}`;

    case "founder-os":
    default:
      // In founder-os mode, the step guidance block (Phase 36) already
      // provides process context. Add a minimal reinforcement.
      return `\n\n## ACTIVE MODE: Founder Decision OS\n\nYou are in the default mentoring mode. Use the 9-Step Startup Process as your backbone. Focus on the founder's current step. Do not introduce specialized frameworks unless signals warrant it.`;
  }
}

/**
 * Build a one-time introduction block when entering a new framework mode.
 * This tells FRED to deliver the introduction language in its response.
 *
 * The introduction is PROMPT-DRIVEN: we instruct the LLM to include it,
 * rather than hardcoding it in the response.
 */
export function buildModeTransitionBlock(
  framework: "positioning" | "investor",
  direction: "enter" | "exit"
): string {
  if (direction === "exit") {
    return `\n\n## MODE TRANSITION\n\nYou have returned to the default Founder Decision OS mode. Resume guiding the founder through their current step in the 9-Step Process. Do not reference the previous framework unless the founder brings it up.`;
  }

  if (framework === "positioning") {
    return `\n\n## MODE TRANSITION: Entering Positioning Mode\n\nYou have detected positioning signals. Before applying the Positioning Readiness Framework, introduce it naturally:\n\n"Before we talk about scaling or investors, we need to get clear on how this is positioned. Right now, it's hard to tell who this is for and why they'd choose it."\n\nUse this language verbatim or adapt it naturally to the conversation flow. Do NOT frame this as marketing or branding. After introducing, begin applying the framework's diagnostic questions.`;
  }

  if (framework === "investor") {
    return `\n\n## MODE TRANSITION: Entering Investor Mode\n\nYou have detected investor/fundraising signals. Before applying the Investor Lens, introduce it naturally:\n\n"We can evaluate this the way investors actually will. That includes a clear verdict — yes, no, or not yet — and why."\n\nUse this language verbatim or adapt it naturally. Remember: Do NOT encourage fundraising by default. Verdict first, then pass reasons, then fixes. Never optimize narrative over fundamentals.`;
  }

  return "";
}
```

### Task 4: Add framework signal flags to `ValidatedInput` in `lib/fred/types.ts`

Extend `ValidatedInput` to carry diagnostic signal results so the chat route can use them for mode transition decisions.

```typescript
// Add to ValidatedInput interface:
export interface ValidatedInput {
  // ... existing fields ...

  /** Phase 38: Positioning signal detection results */
  positioningSignals?: {
    icpVagueOrUndefined: boolean;
    everyoneAsTarget: boolean;
    genericMessaging: boolean;
    highEffortLowTraction: boolean;
    hasSignals: boolean;
  };

  /** Phase 38: Investor signal detection results */
  investorSignals?: {
    mentionsFundraising: boolean;
    mentionsValuation: boolean;
    mentionsDeck: boolean;
    asksAboutReadiness: boolean;
    uploadedDeck: boolean;
    hasSignals: boolean;
  };
}
```

### Task 5: Add signal detection to `lib/fred/actors/validate-input.ts`

Wire the diagnostic engine's signal detectors into the validation actor. This keeps signal detection STRUCTURAL (in code), while mode transition decisions happen at the orchestration layer.

At the end of `validateInputActor`, after existing detection logic, add:

```typescript
import {
  detectPositioningSignals,
  needsPositioningFramework,
} from "@/lib/ai/frameworks/positioning";
import {
  detectInvestorSignals,
  needsInvestorLens,
} from "@/lib/ai/frameworks/investor-lens";

// ... inside validateInputActor, after burnout detection ...

// Phase 38: Detect framework signals for mode switching
const posSignals = detectPositioningSignals(sanitizedMessage);
const invSignals = detectInvestorSignals(sanitizedMessage, !!input.attachments?.some(
  a => a.mimeType === "application/pdf" || a.name.toLowerCase().includes("deck")
));

return {
  originalMessage: input.message,
  intent: intentResult.intent,
  topic: intentResult.topic,
  entities,
  confidence: intentResult.confidence,
  clarificationNeeded,
  keywords,
  sentiment,
  urgency,
  burnoutSignals,
  positioningSignals: {
    ...posSignals,
    hasSignals: needsPositioningFramework(posSignals),
  },
  investorSignals: {
    ...invSignals,
    hasSignals: needsInvestorLens(invSignals),
  },
};
```

### Task 6: Wire diagnostic mode into chat route (`app/api/fred/chat/route.ts`)

This is the orchestration task — brings everything together in `handlePost`.

After the existing Phase 36 conversation state loading block, add:

```typescript
import { determineModeTransition, type DiagnosticMode } from "@/lib/ai/diagnostic-engine";
import { getActiveMode, updateActiveMode, markIntroductionDelivered } from "@/lib/db/conversation-state";
import { buildFrameworkInjectionBlock, buildModeTransitionBlock } from "@/lib/ai/prompts";

// ... inside handlePost, after Phase 36 block (stateContext built) ...

// Phase 38: Load persisted diagnostic mode
let activeMode: DiagnosticMode = "founder-os";
let modeContext: ModeContext | null = null;
let frameworkBlock = "";
let modeTransitionBlock = "";

try {
  const persisted = await getActiveMode(userId);
  activeMode = persisted.activeMode;
  modeContext = persisted.modeContext;

  // Run mode transition analysis on current message
  const hasUploadedDeck = false; // TODO: detect from attachments when file upload is wired
  const transition = determineModeTransition(
    message,
    activeMode,
    modeContext,
    hasUploadedDeck
  );

  // Update mode if transitioned
  if (transition.transitioned) {
    activeMode = transition.newMode;
  }

  // Build framework injection for system prompt
  frameworkBlock = buildFrameworkInjectionBlock(activeMode);

  // Build introduction block if entering a new mode
  if (transition.needsIntroduction && transition.framework) {
    modeTransitionBlock = buildModeTransitionBlock(
      transition.framework,
      "enter"
    );
  } else if (transition.transitioned && transition.direction === "exit") {
    modeTransitionBlock = buildModeTransitionBlock(
      transition.framework!,
      "exit"
    );
  }

  // Fire-and-forget: persist mode changes and signal history
  updateActiveMode(userId, activeMode, transition.updatedModeContext).catch(err =>
    console.warn("[FRED Chat] Failed to persist mode (non-blocking):", err)
  );

  // Fire-and-forget: mark introduction delivered if needed
  if (transition.needsIntroduction && transition.framework) {
    markIntroductionDelivered(
      userId,
      transition.framework,
      transition.detectedSignals.join(",")
    ).catch(err =>
      console.warn("[FRED Chat] Failed to mark introduction (non-blocking):", err)
    );
  }
} catch (error) {
  console.warn("[FRED Chat] Failed to load diagnostic mode (non-blocking):", error);
}

// Phase 38: Assemble full system prompt context
// Order: founderContext + stepGuidance + frameworkBlock + modeTransitionBlock
const fullContext = [
  founderContext,
  stepGuidanceBlock,
  frameworkBlock,
  modeTransitionBlock,
].filter(Boolean).join("\n\n");
```

This replaces the existing `fullContext` assembly (lines 289-291 in the current code). The new assembly includes all four context layers in the correct order.

### Task 7: Add `DiagnosticModeContext` to `ConversationStateContext` in `lib/fred/types.ts`

Extend the machine-threaded context so actors can read the active mode.

```typescript
export interface ConversationStateContext {
  // ... existing fields from Phase 36 ...
  currentStep: StartupStep;
  stepStatuses: Record<StartupStep, StepStatus>;
  processStatus: string;
  currentBlockers: string[];
  diagnosticTags: Record<string, string>;
  founderSnapshot: Record<string, unknown>;
  progressContext: string;

  /** Phase 38: Active diagnostic mode */
  activeMode: "founder-os" | "positioning" | "investor-readiness";
  /** Phase 38: Whether a mode transition occurred on this message */
  modeTransitioned: boolean;
}
```

Update the `stateContext` construction in the chat route:

```typescript
const stateContext: ConversationStateContext | null = conversationState
  ? {
      currentStep: conversationState.currentStep,
      stepStatuses: conversationState.stepStatuses,
      processStatus: conversationState.processStatus,
      currentBlockers: conversationState.currentBlockers,
      diagnosticTags: conversationState.diagnosticTags as Record<string, string>,
      founderSnapshot: conversationState.founderSnapshot as Record<string, unknown>,
      progressContext: stepGuidanceBlock,
      activeMode: activeMode,           // Phase 38
      modeTransitioned: transition?.transitioned ?? false,  // Phase 38
    }
  : null;
```

## Verification

- [ ] `getActiveMode` returns persisted mode from `fred_conversation_state.active_mode`
- [ ] `updateActiveMode` writes mode + context, caps `signal_history` at 20
- [ ] `markIntroductionDelivered` updates `mode_context.introduction_state` correctly
- [ ] `determineModeTransition` correctly identifies investor signals as highest priority
- [ ] `determineModeTransition` requires MODE_EXIT_THRESHOLD (3) quiet messages to exit a mode
- [ ] `determineModeTransition` tracks `quiet_count` correctly (resets on signal, increments on quiet)
- [ ] `determineModeTransition` only sets `needsIntroduction: true` when introduction hasn't been delivered
- [ ] `buildFrameworkInjectionBlock("positioning")` returns the full Positioning Readiness prompt
- [ ] `buildFrameworkInjectionBlock("investor-readiness")` returns the full Investor Lens prompt
- [ ] `buildFrameworkInjectionBlock("founder-os")` returns a minimal reinforcement block
- [ ] `buildModeTransitionBlock` includes the Operating Bible's introduction language verbatim
- [ ] Framework signal detection runs in `validate-input.ts` (structural layer)
- [ ] Mode transition decision runs in `chat/route.ts` (orchestration layer)
- [ ] All mode persistence is fire-and-forget (never blocks the response)
- [ ] Graceful fallback: if diagnostic mode loading fails, chat continues in `founder-os`
- [ ] System prompt assembly order: founderContext + stepGuidance + frameworkBlock + modeTransitionBlock
- [ ] Framework injection does not replace step guidance — they coexist
- [ ] 9-Step Process serves as default backbone in `founder-os` mode
- [ ] `ConversationStateContext` includes `activeMode` and `modeTransitioned`
- [ ] `npx tsc --noEmit` passes
- [ ] Existing chat API contract preserved (same request/response schema)
- [ ] Existing tests pass (no breaking changes)
- [ ] `ValidatedInput` carries `positioningSignals` and `investorSignals`

## Must-Haves

1. **Chat route request/response schema is unchanged** — purely a backend enrichment, no new API surface
2. **Mode persistence is fire-and-forget** — never blocks the critical path
3. **Introductions are delivered exactly once** per framework, tracked in `mode_context`
4. **Hysteresis prevents mode flickering** — 3+ quiet messages required to exit a specialized mode
5. **Investor signals override positioning signals** — investor mode is highest priority (Operating Bible: introduce only ONE framework at a time)
6. **Framework injection is additive** — specialized framework is appended to step guidance, not replacing it
7. **Signal detection is structural** (validate-input.ts), mode transition is orchestration (chat route), framework language is prompt-driven (prompts.ts) — three-layer separation maintained
8. **No new database tables or migrations** — uses existing `active_mode` and `mode_context` columns from migration 052
9. **Backward-compatible** — if migration 052 hasn't run, `getActiveMode` returns defaults and chat works normally
10. **`signal_history` capped at 20 entries** to prevent JSONB bloat
11. **No scoring without intake** — framework injection tells FRED about the framework but does not trigger automatic scoring (Operating Bible: "Intake before scoring")
12. **Legacy `diagnostic_states` table is NOT queried** — all mode state flows through `fred_conversation_state`

## Interaction with Other Phases

- **Phase 36 (Step Guidance):** Coexists. Step guidance is always injected. Framework injection is additive.
- **Phase 37 (Reality Lens Gate):** Orthogonal. RL gate checks downstream requests. Mode integration checks framework signals. Both can be active simultaneously.
- **Phase 39 (Missing Frameworks):** Depends on Phase 38 patterns. Phase 39 will complete the Investor Readiness Score implementation and formalize the Deck Request Protocol, building on the mode switching infrastructure.
- **Phase 45 (Chat UI Redesign):** Will read `activeMode` from the response to show the mode indicator in the top bar (Neutral, Positioning, Investor, Strategy).
