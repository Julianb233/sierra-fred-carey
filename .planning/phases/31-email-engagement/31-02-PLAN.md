---
phase: 31-email-engagement
plan: 02
type: execute
wave: 2
depends_on: ["31-01"]
files_modified:
  - lib/email/templates/milestone.tsx
  - lib/email/milestones/triggers.ts
  - lib/email/milestones/types.ts
  - lib/email/templates/re-engagement.tsx
  - lib/email/re-engagement/detector.ts
  - lib/email/re-engagement/types.ts
  - app/api/cron/re-engagement/route.ts
  - app/api/milestones/route.ts
  - vercel.json
autonomous: true

must_haves:
  truths:
    - "When a founder completes a milestone, they receive a celebration email if email prefs allow"
    - "Inactive users receive graduated re-engagement emails at 7, 14, and 30 day intervals"
    - "Re-engagement emails respect the marketing preference toggle and do not send to opted-out users"
    - "A user does not receive a re-engagement email if they already received one in the last 14 days"
    - "Milestone emails include a congratulatory message, the milestone details, and a motivational Fred quote"
    - "Re-engagement cron runs daily but only sends to qualifying inactive users"
  artifacts:
    - path: "lib/email/templates/milestone.tsx"
      provides: "Milestone celebration React Email template"
      exports: ["MilestoneEmail"]
    - path: "lib/email/milestones/triggers.ts"
      provides: "Milestone email trigger logic called inline from milestone updates"
      exports: ["sendMilestoneEmail"]
    - path: "lib/email/templates/re-engagement.tsx"
      provides: "Re-engagement nudge React Email template with graduated messaging"
      exports: ["ReEngagementEmail"]
    - path: "lib/email/re-engagement/detector.ts"
      provides: "Inactive user detection and re-engagement eligibility checking"
      exports: ["getReEngagementCandidates"]
    - path: "app/api/cron/re-engagement/route.ts"
      provides: "Daily cron for re-engagement email dispatch"
      exports: ["GET"]
  key_links:
    - from: "app/api/milestones/route.ts"
      to: "lib/email/milestones/triggers.ts"
      via: "sendMilestoneEmail() call on milestone completion"
      pattern: "sendMilestoneEmail"
    - from: "app/api/cron/re-engagement/route.ts"
      to: "lib/email/re-engagement/detector.ts"
      via: "getReEngagementCandidates() for inactive user list"
      pattern: "getReEngagementCandidates"
    - from: "lib/email/milestones/triggers.ts"
      to: "lib/email/send.ts"
      via: "sendEmail() from Plan 01 infrastructure"
      pattern: "sendEmail"
    - from: "app/api/cron/re-engagement/route.ts"
      to: "lib/email/send.ts"
      via: "sendEmail() from Plan 01 infrastructure"
      pattern: "sendEmail"
    - from: "vercel.json"
      to: "app/api/cron/re-engagement/route.ts"
      via: "daily cron schedule entry"
      pattern: "re-engagement"
---

<objective>
Add milestone celebration emails and re-engagement email system to Sahara.

Purpose: When founders hit key milestones (first chat, first Reality Lens, 10 conversations, etc.), send a congratulatory email with a Fred quote and next steps. For inactive users (7/14/30 days), send graduated nudge emails to bring them back. Both systems use the email infrastructure built in Plan 01.

Output: Milestone trigger function wired into existing API, re-engagement cron route, React Email templates for both, daily cron configuration.
</objective>

<execution_context>
@/opt/agency-workspace/sierra-fred-carey/.planning/phases/31-email-engagement/31-RESEARCH.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/31-email-engagement/31-01-SUMMARY.md
@lib/email/send.ts
@lib/email/preferences.ts
@lib/email/templates/layout.tsx
@lib/email/types.ts
@lib/email/constants.ts
@lib/db/migrations/045_email_engagement.sql
@vercel.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Milestone celebration emails</name>
  <files>
    lib/email/milestones/types.ts
    lib/email/milestones/triggers.ts
    lib/email/templates/milestone.tsx
    app/api/milestones/route.ts
  </files>
  <action>
    1. Create `lib/email/milestones/types.ts` with:
       - `MilestoneType` type: `'first_chat' | 'first_reality_lens' | 'first_pitch_review' | 'ten_conversations' | 'irs_above_70' | 'first_strategy_doc' | 'milestone_completed'`
       - `MilestoneEmailData` interface: `{ founderName: string; milestoneTitle: string; milestoneDescription: string; milestoneType: MilestoneType; fredQuote: string; nextSuggestion: string; appUrl: string; unsubscribeUrl: string }`
       - `MILESTONE_MESSAGES` record mapping each `MilestoneType` to `{ title: string; description: string; nextSuggestion: string }`. Examples:
         - `first_chat`: title "Your First FRED Conversation!", next suggestion "Try a Reality Lens analysis"
         - `first_reality_lens`: title "Reality Check Complete!", next suggestion "Review your red flags dashboard"
         - `ten_conversations`: title "10 Conversations with FRED!", next suggestion "Check your Investor Readiness Score"
         - `milestone_completed`: title "Milestone Achieved!", next suggestion "Set your next milestone on the Journey Dashboard"

    2. Create `lib/email/templates/milestone.tsx` -- React Email component with props `MilestoneEmailData`:
       - Uses `EmailLayout` wrapper from `./layout`
       - Preview text: `Congratulations! {milestoneTitle}`
       - Celebration header with milestone title (large text, brand color)
       - Description paragraph
       - Fred quote section: styled blockquote with the motivational Fred quote (italic, left-border accent)
       - "What's Next" section with the next suggestion
       - CTA button: "Continue Your Journey" linking to `{appUrl}/dashboard`
       - All inline styles, table-based layout for email compatibility

    3. Create `lib/email/milestones/triggers.ts` -- Export `sendMilestoneEmail(userId: string, milestoneType: MilestoneType, customTitle?: string): Promise<void>`. This function:
       - Checks `shouldSendEmail(userId, 'milestone')` -- return early if false
       - Checks idempotency: query `email_sends` for existing record with `email_type='milestone'` and `email_subtype=milestoneType` for the user in the last 24 hours. Skip if exists (prevents duplicate milestone emails on retry).
       - Fetches user profile (name, email) from `profiles` via service client
       - If no email on profile, return early (log and skip)
       - Gets a random Fred quote via `getRandomQuote()` from `lib/ai/fred-brain` (import dynamically to avoid circular deps)
       - Looks up milestone message from `MILESTONE_MESSAGES[milestoneType]`, using `customTitle` to override title if provided
       - Calls `sendEmail()` with `MilestoneEmail` React component
       - Wraps in try/catch -- milestone email failures must NOT break the calling operation. Log errors but never throw.

    4. Wire milestone trigger into existing milestone update flow. Read `app/api/milestones/route.ts` (or the relevant milestones API route). In the PATCH/PUT handler where milestone status is updated to 'completed', add a non-blocking call:
       ```typescript
       // Fire-and-forget: don't await to avoid slowing the API response
       sendMilestoneEmail(userId, 'milestone_completed', milestone.title).catch(err =>
         logger.error('[Milestones] Failed to send milestone email', err)
       );
       ```
       Import `sendMilestoneEmail` from `@/lib/email/milestones/triggers`.
       If there is no existing PATCH handler for milestones, check for the route at `app/api/journey/milestones/route.ts` or similar. Only add the trigger if the route exists -- do not create a new milestones API route from scratch.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `npm run lint` passes
    - `lib/email/milestones/triggers.ts` exists and exports `sendMilestoneEmail`
    - `lib/email/templates/milestone.tsx` exists and exports `MilestoneEmail`
    - `lib/email/milestones/types.ts` exists with `MILESTONE_MESSAGES` and `MilestoneType`
    - The milestones API route (if found) imports and calls `sendMilestoneEmail` on completion
  </verify>
  <done>
    Milestone celebration emails work: when a milestone status changes to completed, a fire-and-forget call sends a branded congratulatory email with a Fred quote and next step suggestion. Email preferences are respected. Failures are logged but don't break the API.
  </done>
</task>

<task type="auto">
  <name>Task 2: Re-engagement emails and cron configuration</name>
  <files>
    lib/email/re-engagement/types.ts
    lib/email/re-engagement/detector.ts
    lib/email/templates/re-engagement.tsx
    app/api/cron/re-engagement/route.ts
    vercel.json
  </files>
  <action>
    1. Create `lib/email/re-engagement/types.ts` with:
       - `ReEngagementTier` type: `'day7' | 'day14' | 'day30'`
       - `ReEngagementCandidate` interface: `{ userId: string; email: string; name: string; inactiveDays: number; tier: ReEngagementTier }`
       - `ReEngagementEmailData` interface: `{ founderName: string; tier: ReEngagementTier; inactiveDays: number; fredMessage: string; featureHighlight: string; appUrl: string; unsubscribeUrl: string }`
       - `RE_ENGAGEMENT_MESSAGES` record mapping each tier to `{ subject: string; fredMessage: string; featureHighlight: string }`:
         - `day7`: subject "FRED misses you", fredMessage is a gentle reminder about progress, featureHighlight mentions recent platform updates
         - `day14`: subject "Your startup journey is waiting", fredMessage highlights the value of consistent mentorship, featureHighlight mentions a specific feature they haven't tried
         - `day30`: subject "One more thing before you go", fredMessage is a final warm nudge about Fred's availability, featureHighlight mentions the founder community

    2. Create `lib/email/re-engagement/detector.ts` -- Export `getReEngagementCandidates(): Promise<ReEngagementCandidate[]>`. This function:
       - Uses `createServiceClient()` from `lib/supabase/server`
       - Gets all profiles with `onboarding_completed = true` and non-null email
       - For each user, finds the most recent activity by querying the MAX `created_at` from `journey_events` for that user (single query with GROUP BY user_id is more efficient than per-user)
       - Calculates inactive days = difference between now and last activity date
       - Categorizes into tiers: 7-13 days = day7, 14-29 days = day14, 30+ days = day30
       - Filters out users inactive less than 7 days (still active)
       - Checks `shouldSendEmail(userId, 're_engagement')` for each candidate
       - Checks idempotency: queries `email_sends` for existing `re_engagement` record for the user in the last 14 days. Skip if exists.
       - Returns array of `ReEngagementCandidate`
       - Uses batch query approach (get all users + all last-activity in 2 queries, join in memory) to avoid N+1

    3. Create `lib/email/templates/re-engagement.tsx` -- React Email component with props `ReEngagementEmailData`:
       - Uses `EmailLayout` wrapper from `./layout`
       - Preview text varies by tier: "FRED misses you" / "Your startup journey is waiting" / "One more thing..."
       - Warm greeting: `Hey {founderName},`
       - Fred's message paragraph (personalized by tier)
       - Feature highlight section with a subtle card-style box
       - CTA button: `Come Back to Sahara` linking to `{appUrl}/dashboard`
       - For day30 tier, add a softer tone and "no pressure" phrasing
       - All inline styles, table-based layout

    4. Create `app/api/cron/re-engagement/route.ts` -- Follow the EXACT pattern from `app/api/cron/weekly-checkin/route.ts`:
       - `export const dynamic = 'force-dynamic'`
       - `export const maxDuration = 60`
       - GET handler with CRON_SECRET bearer token auth
       - Check RESEND_API_KEY is present, return 503 if not
       - Call `getReEngagementCandidates()` to get qualifying users
       - For each candidate:
         a. Build `ReEngagementEmailData` using `RE_ENGAGEMENT_MESSAGES[candidate.tier]`
         b. Call `sendEmail()` with `ReEngagementEmail` React component
         c. Subject from `RE_ENGAGEMENT_MESSAGES[candidate.tier].subject`
         d. Tags: `[{name: 'category', value: 're_engagement'}, {name: 'tier', value: candidate.tier}]`
       - Track sent/skipped/failed counts
       - Log via `lib/logger` with `[Cron: Re-engagement]` prefix
       - Return JSON summary: `{ success, sent, skipped, failed, duration }`

    5. Update `vercel.json` -- Add re-engagement cron entry to the existing `crons` array (Plan 01 already added weekly-digest):
       ```json
       { "path": "/api/cron/re-engagement", "schedule": "0 14 * * *" }
       ```
       This runs daily at 14:00 UTC. Keep all existing crons intact.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `npm run lint` passes
    - `app/api/cron/re-engagement/route.ts` exists and exports GET
    - `lib/email/templates/re-engagement.tsx` exists and exports ReEngagementEmail
    - `lib/email/re-engagement/detector.ts` exists and exports getReEngagementCandidates
    - `vercel.json` contains both `/api/cron/weekly-digest` AND `/api/cron/re-engagement` in crons array
    - `npm run build` completes without errors
  </verify>
  <done>
    Re-engagement system is complete: daily cron detects inactive users at 7/14/30 day tiers, sends graduated nudge emails with Fred-voice messaging, respects marketing email preferences, and prevents duplicate sends within 14-day windows. Milestone emails fire on completion events. All three email types (digest, milestone, re-engagement) use shared infrastructure from Plan 01.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `npx tsc --noEmit` passes with all new files
2. Lint: `npm run lint` passes
3. Build: `npm run build` succeeds
4. Milestone files exist: types.ts, triggers.ts, milestone.tsx
5. Re-engagement files exist: types.ts, detector.ts, re-engagement.tsx, cron route
6. vercel.json has both weekly-digest and re-engagement cron entries
7. Milestone trigger is wired into existing milestone completion flow (if route exists)
8. All email templates use shared EmailLayout from Plan 01
</verification>

<success_criteria>
- Milestone email trigger fires on milestone completion (non-blocking)
- Milestone template shows celebration header, Fred quote, and next step suggestion
- Re-engagement detector identifies inactive users at 7/14/30 day tiers efficiently
- Re-engagement cron authenticates, checks preferences, prevents 14-day duplicate sends
- Re-engagement template has graduated messaging (gentle day7, value-focused day14, warm-farewell day30)
- Both email types respect preference toggles (email master + category-specific)
- vercel.json has daily re-engagement cron at 14:00 UTC
- All files compile and build successfully
</success_criteria>

<output>
After completion, create `.planning/phases/31-email-engagement/31-02-SUMMARY.md`
</output>
