---
phase: 59-sentry-production-monitoring
plan: 02
type: execute
wave: 2
depends_on: ["59-01"]
files_modified:
  - .github/workflows/deploy.yml
  - lib/sentry.ts
  - middleware.ts
  - app/api/chat/route.ts
autonomous: true

must_haves:
  truths:
    - "CI pipeline fails when lint, typecheck, or tests fail (no silent pass-through)"
    - "Alert rules notify team of critical errors within 5 minutes"
    - "Performance monitoring tracks page load times via web vitals"
    - "Performance monitoring tracks API response times via custom spans"
  artifacts:
    - path: ".github/workflows/deploy.yml"
      provides: "CI pipeline with real quality gates"
      contains: "npm run lint"
    - path: "lib/sentry.ts"
      provides: "Performance span helper for API routes"
      exports: ["withSentrySpan"]
  key_links:
    - from: ".github/workflows/deploy.yml"
      to: "build job"
      via: "lint/typecheck/test steps without || true"
      pattern: "npm run lint$"
    - from: "middleware.ts"
      to: "Sentry"
      via: "request duration tracking breadcrumb"
      pattern: "addBreadcrumb|captureMessage"
---

<objective>
Harden the CI pipeline by removing all `|| true` suffixes so quality gates actually block deployments, add Sentry performance monitoring spans to critical routes, and configure Sentry alert rules via the Sentry API.

Purpose: Currently every quality gate in CI is silenced with `|| true` (Pitfall #10). This means type errors, lint failures, and test failures are invisible. This plan makes CI honest AND adds performance monitoring so page load times and API response times are tracked. Alert rules ensure the team is notified of critical errors within 5 minutes.

Output: Honest CI pipeline + Sentry performance monitoring + alert rules configured.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/PITFALLS.md (Pitfall #10: CI/CD `|| true`)

Prior plan context:
@.planning/phases/59-sentry-production-monitoring/59-01-SUMMARY.md

Existing files:
@.github/workflows/deploy.yml
@middleware.ts
@lib/sentry.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Remove || true from CI quality gates</name>
  <files>.github/workflows/deploy.yml</files>
  <action>
  Read `.github/workflows/deploy.yml` and make these changes to the `build` job:

  1. **Remove `|| true` from lint step** (line 29):
     Change: `run: npm run lint || true`
     To: `run: npm run lint`

  2. **Remove `|| true` from typecheck step** (line 32):
     Change: `run: npx tsc --noEmit || true`
     To: `run: npx tsc --noEmit`

  3. **Remove `|| true` from test step** (line 35):
     Change: `run: npm run test || true`
     To: `run: npm run test`

  4. **Keep `|| true` on security audit** (line 54) -- this is intentional. `npm audit` flags vulnerabilities in transitive dependencies that the project cannot fix. Security audit should warn but not block.

  5. **Add Sentry env vars to the build step** so source maps upload during CI builds. Add an `env` block to the "Build application" step:

  ```yaml
  - name: Build application
    env:
      NEXT_PUBLIC_SENTRY_DSN: ${{ secrets.NEXT_PUBLIC_SENTRY_DSN }}
      SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
      SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
      SENTRY_PROJECT: ${{ secrets.SENTRY_PROJECT }}
    run: npm run build
  ```

  This ensures source maps are uploaded during CI builds, not just Vercel deployments. The secrets are set by the user in Plan 01's checkpoint.

  6. **Add a comment** at the top of the `build` job explaining that quality gates are intentionally strict:

  ```yaml
  # Quality gates: lint, typecheck, and test MUST pass.
  # Do NOT add `|| true` â€” failures must block the build.
  # See: .planning/research/PITFALLS.md (Pitfall #10)
  ```

  IMPORTANT: Before making this change, verify that `npm run lint`, `npx tsc --noEmit`, and `npm run test` actually pass locally. If any fail, note the failures in the summary but still remove `|| true` -- the CI should reflect reality.

  Run locally to verify:
  - `npm run lint` (should pass or show fixable issues)
  - `npx tsc --noEmit` (should pass -- next.config.mjs has `ignoreBuildErrors: true` for build, but tsc --noEmit runs independently)
  - `npm run test` (should pass -- STATE.md says 801/805 passing; check if 4 failures are blocking)
  </action>
  <verify>
  - `grep "|| true" .github/workflows/deploy.yml` should return ONLY the `npm audit` line (1 match, not 3+)
  - `grep "SENTRY_AUTH_TOKEN" .github/workflows/deploy.yml` should show the secret reference in build step
  - The workflow YAML is valid (no syntax errors)
  - Locally: `npm run lint` exits 0, `npx tsc --noEmit` exits 0, `npm run test` exits 0 (or note any failures)
  </verify>
  <done>
  CI pipeline has real quality gates. Lint, typecheck, and test failures block the build. Sentry env vars are passed to the build step for source map uploads. Security audit remains advisory-only (|| true kept intentionally).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add performance monitoring and configure alert rules</name>
  <files>
    lib/sentry.ts
    middleware.ts
    app/api/chat/route.ts
  </files>
  <action>
  Three sub-tasks for performance monitoring and alerting:

  **A. Add request timing to middleware:**

  In `middleware.ts`, add a simple performance breadcrumb that tracks request duration. Do NOT import `lib/sentry.ts` in middleware (it's edge runtime -- keep imports minimal). Instead, use `@sentry/nextjs` directly:

  - At the top of the middleware function, capture `const start = Date.now();`
  - At the end (before returning the response), compute duration: `const duration = Date.now() - start;`
  - If duration > 2000ms (slow request), add a Sentry breadcrumb:
    ```typescript
    import * as Sentry from "@sentry/nextjs";
    // ... at end of middleware:
    if (process.env.NEXT_PUBLIC_SENTRY_DSN && duration > 2000) {
      Sentry.addBreadcrumb({
        message: `Slow middleware: ${pathname} (${duration}ms)`,
        category: "performance",
        level: "warning",
        data: { pathname, duration },
      });
    }
    ```
  - This is lightweight -- only fires for slow requests and only when Sentry is active.
  - Place the timing code so it wraps the entire middleware function body including the try/catch.
  - Make sure to handle early returns (CORS preflight) by placing the timing capture at the very top.

  **B. Wire `withSentrySpan` into the chat API route:**

  In `app/api/chat/route.ts`, the `withSentrySpan` helper from `lib/sentry.ts` (added in Plan 01, Task 2) should wrap the main AI completion call. This creates a Sentry performance span that tracks how long AI responses take:

  - Find the main AI call (likely `streamText` or similar from Vercel AI SDK)
  - Wrap it: `const result = await withSentrySpan("ai.chat.completion", "ai.run", async () => { ... existing AI call ... });`
  - This is no-op without DSN. When active, it creates a span visible in Sentry Performance.
  - If the existing code uses streaming (which it likely does), wrap the stream creation, not the entire stream consumption.

  **C. Create a Sentry alert configuration script:**

  Create a new file `scripts/configure-sentry-alerts.ts` that uses the Sentry API to create alert rules. This script is run once manually after Sentry is activated.

  ```typescript
  #!/usr/bin/env npx tsx
  /**
   * Configure Sentry alert rules for Sahara production monitoring.
   * Run once after Sentry env vars are set:
   *   SENTRY_AUTH_TOKEN=... SENTRY_ORG=... SENTRY_PROJECT=... npx tsx scripts/configure-sentry-alerts.ts
   */

  const SENTRY_API = "https://sentry.io/api/0";
  const authToken = process.env.SENTRY_AUTH_TOKEN;
  const org = process.env.SENTRY_ORG;
  const project = process.env.SENTRY_PROJECT;

  if (!authToken || !org || !project) {
    console.error("Missing env vars: SENTRY_AUTH_TOKEN, SENTRY_ORG, SENTRY_PROJECT");
    process.exit(1);
  }

  const headers = {
    Authorization: `Bearer ${authToken}`,
    "Content-Type": "application/json",
  };

  async function createAlertRule(name: string, conditions: object[], actions: object[], frequency: number = 300) {
    const res = await fetch(`${SENTRY_API}/projects/${org}/${project}/rules/`, {
      method: "POST",
      headers,
      body: JSON.stringify({
        name,
        conditions,
        actions,
        actionMatch: "any",
        filterMatch: "all",
        frequency, // seconds between alerts (300 = 5 min)
        environment: "production",
      }),
    });
    if (!res.ok) {
      const err = await res.text();
      console.error(`Failed to create "${name}": ${res.status} ${err}`);
      return;
    }
    console.log(`Created alert rule: ${name}`);
  }

  async function main() {
    // Alert 1: High-frequency errors (>10 events in 5 minutes)
    await createAlertRule(
      "High Error Rate",
      [{ id: "sentry.rules.conditions.event_frequency.EventFrequencyCondition", value: 10, interval: "5m" }],
      [{ id: "sentry.mail.actions.NotifyEmailAction", targetType: "IssueOwners" }],
      300
    );

    // Alert 2: New issue (first occurrence)
    await createAlertRule(
      "New Issue Detected",
      [{ id: "sentry.rules.conditions.first_seen_event.FirstSeenEventCondition" }],
      [{ id: "sentry.mail.actions.NotifyEmailAction", targetType: "IssueOwners" }],
      1800 // 30 min cooldown for new issues
    );

    // Alert 3: Issue regression (previously resolved, reappeared)
    await createAlertRule(
      "Issue Regression",
      [{ id: "sentry.rules.conditions.regression_event.RegressionEventCondition" }],
      [{ id: "sentry.mail.actions.NotifyEmailAction", targetType: "IssueOwners" }],
      300
    );

    console.log("\nAlert rules configured. Verify at:");
    console.log(`https://sentry.io/organizations/${org}/alerts/rules/?project=${project}`);
  }

  main().catch(console.error);
  ```

  Add this file to `scripts/` directory. It is NOT part of the build -- it's a one-time setup script.
  </action>
  <verify>
  - `grep "|| true" .github/workflows/deploy.yml | wc -l` returns 1 (only the audit line)
  - `cat scripts/configure-sentry-alerts.ts` exists and is valid TypeScript
  - `npx tsc --noEmit` passes (no type errors from middleware changes)
  - `npm run build` passes
  - `npm run test` passes
  </verify>
  <done>
  CI pipeline is honest (lint/typecheck/test failures block builds). Performance monitoring spans track AI response times. Middleware logs slow requests as Sentry breadcrumbs. Alert configuration script ready to run after Sentry activation. Three alert rules defined: high error rate, new issues, and regressions.
  </done>
</task>

</tasks>

<verification>
- `.github/workflows/deploy.yml` has `|| true` ONLY on `npm audit` (not on lint, typecheck, or test)
- `scripts/configure-sentry-alerts.ts` exists and defines 3 alert rules
- Middleware tracks slow requests via Sentry breadcrumbs
- Chat API route has `withSentrySpan` around AI completion
- `npx tsc --noEmit` passes
- `npm run build` passes
- `npm run test` passes
</verification>

<success_criteria>
1. CI fails on type errors, lint errors, and test failures (verified by grep showing no `|| true` on quality gates)
2. Performance spans track AI chat completion time in Sentry Performance
3. Slow middleware requests (>2s) create Sentry breadcrumbs for debugging
4. Alert configuration script creates 3 rules: high error rate, new issues, regressions
5. All existing tests continue passing
</success_criteria>

<output>
After completion, create `.planning/phases/59-sentry-production-monitoring/59-02-SUMMARY.md`
</output>
