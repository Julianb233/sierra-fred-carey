---
phase: 59-sentry-production-monitoring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - sentry.edge.config.ts
  - instrumentation.ts
  - sentry.client.config.ts
  - sentry.server.config.ts
  - lib/sentry.ts
  - app/api/chat/route.ts
  - app/api/stripe/webhook/route.ts
  - .env.example
autonomous: false
user_setup:
  - service: sentry
    why: "Error tracking and source map uploads"
    env_vars:
      - name: NEXT_PUBLIC_SENTRY_DSN
        source: "Sentry Dashboard -> Project Settings -> Client Keys (DSN)"
      - name: SENTRY_AUTH_TOKEN
        source: "Sentry Dashboard -> Settings -> Auth Tokens -> Create New Token (org:read, project:releases, project:write)"
      - name: SENTRY_ORG
        source: "Sentry Dashboard URL slug (e.g., https://sentry.io/organizations/YOUR-ORG/)"
      - name: SENTRY_PROJECT
        source: "Sentry Dashboard -> Project Settings -> Project slug"
    dashboard_config:
      - task: "Create Sentry project for Next.js (if not already created)"
        location: "Sentry Dashboard -> Projects -> Create Project -> Next.js"

must_haves:
  truths:
    - "Sentry captures client-side runtime errors with readable source maps"
    - "Sentry captures server-side API route errors with user context"
    - "Sentry captures edge runtime errors from middleware"
    - "Noisy errors (ResizeObserver, AbortError, network timeout) are filtered out"
    - "Sentry tunnel route bypasses ad blockers"
  artifacts:
    - path: "sentry.edge.config.ts"
      provides: "Edge runtime Sentry initialization"
      min_lines: 5
    - path: "instrumentation.ts"
      provides: "Server + edge Sentry initialization via Next.js instrumentation hook"
      contains: "sentry.edge.config"
    - path: "lib/sentry.ts"
      provides: "Sentry helper functions used by API routes"
      exports: ["captureError", "captureMessage", "setUserContext", "addBreadcrumb"]
  key_links:
    - from: "instrumentation.ts"
      to: "sentry.edge.config.ts"
      via: "dynamic import for edge runtime"
      pattern: "import.*sentry\\.edge"
    - from: "app/api/chat/route.ts"
      to: "lib/sentry.ts"
      via: "setUserContext and captureError in catch blocks"
      pattern: "import.*from.*lib/sentry"
    - from: "next.config.mjs"
      to: "sentry"
      via: "withSentryConfig wrapper for source map upload"
      pattern: "withSentryConfig"
---

<objective>
Activate Sentry error tracking across all three Next.js runtimes (client, server, edge) with source maps, error filtering, user context tagging, and the tunnel route for ad-blocker bypass.

Purpose: Sentry code is already wired in the codebase but completely inert (DSN not set). This plan activates it properly: adds the missing edge config, wires the existing but unused `lib/sentry.ts` helpers into key API routes, and ensures a user-facing checkpoint to set all 4 env vars simultaneously (CRITICAL -- setting DSN without SENTRY_AUTH_TOKEN breaks source map uploads).

Output: Working Sentry error tracking across client/server/edge runtimes with source maps uploading correctly.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/PITFALLS.md (Pitfall #1: Sentry DSN activation)
@.planning/research/ARCHITECTURE.md (Section 2D: Sentry)

Existing Sentry files (all conditional on NEXT_PUBLIC_SENTRY_DSN):
@sentry.client.config.ts
@sentry.server.config.ts
@lib/sentry.ts
@instrumentation.ts
@next.config.mjs (withSentryConfig on line 70-80)
@app/global-error.tsx (already captures to Sentry)
@.env.example (Sentry vars already documented)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add edge config and enhance Sentry initialization</name>
  <files>
    sentry.edge.config.ts
    instrumentation.ts
    sentry.client.config.ts
    sentry.server.config.ts
  </files>
  <action>
  1. Create `sentry.edge.config.ts` in the project root. This file initializes Sentry for edge runtime (middleware). Keep it minimal -- edge runtime has limited APIs:

  ```typescript
  import * as Sentry from "@sentry/nextjs";

  if (process.env.NEXT_PUBLIC_SENTRY_DSN) {
    Sentry.init({
      dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
      environment: process.env.NODE_ENV,
      tracesSampleRate: 0.1,
    });
  }
  ```

  2. Update `instrumentation.ts` to import the edge config when running in edge runtime. Currently it only handles `nodejs` runtime. Add the `edge` case:

  ```typescript
  export async function register() {
    if (process.env.NEXT_RUNTIME === "nodejs") {
      const { validateEnv } = await import("@/lib/env");
      validateEnv();
      await import("./sentry.server.config");
    }

    if (process.env.NEXT_RUNTIME === "edge") {
      await import("./sentry.edge.config");
    }
  }

  export { captureRequestError as onRequestError } from "@sentry/nextjs";
  ```

  3. Enhance `sentry.server.config.ts` to add performance monitoring and better error filtering. Update it to:
  - Increase `tracesSampleRate` to 0.2 for server (more useful than client traces)
  - Add `profilesSampleRate: 0.1` for server profiling
  - Add `beforeSend` filter matching the client config (filter ResizeObserver, AbortError, network timeout)
  - Add `ignoreErrors` array for common non-actionable errors

  4. Enhance `sentry.client.config.ts`:
  - Add `tracePropagationTargets` that includes only the app's own API routes (avoid leaking Sentry headers to third-party APIs)
  - The pattern should match: `[/^\//, /^https:\/\/.*\.sahara/]` (relative URLs and sahara domains)
  - Keep the existing `beforeSend` filter and replay config
  - Add `ignoreErrors` for common non-actionable browser errors: "Non-Error promise rejection", "Load failed", "Failed to fetch"

  IMPORTANT: Do NOT change the conditional DSN guard pattern (`if (process.env.NEXT_PUBLIC_SENTRY_DSN)`). This ensures Sentry remains inert in environments without the DSN set.
  </action>
  <verify>
  - `sentry.edge.config.ts` exists in project root
  - `instrumentation.ts` has both `nodejs` and `edge` runtime branches
  - `npx tsc --noEmit` passes (no type errors from new/modified files)
  - Build completes: `npm run build` (Sentry should remain inert since DSN is not set locally)
  </verify>
  <done>
  Edge runtime Sentry config exists. Instrumentation hooks cover all three runtimes. Enhanced error filtering prevents noisy non-actionable errors. Build passes with Sentry still conditional on DSN.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire lib/sentry.ts helpers into key API routes</name>
  <files>
    lib/sentry.ts
    app/api/chat/route.ts
    app/api/stripe/webhook/route.ts
  </files>
  <action>
  The `lib/sentry.ts` file exports `captureError`, `captureMessage`, `setUserContext`, and `addBreadcrumb` -- but ZERO files in the app import them. Wire these into the two most critical API routes:

  1. **`app/api/chat/route.ts`** (the FRED chat route -- highest traffic, most complex):
     - At the top, add: `import { captureError, setUserContext, addBreadcrumb } from "@/lib/sentry";`
     - After authentication (where userId is available), call: `setUserContext(userId, tier)` -- this tags all subsequent errors in the request with the user. If tier isn't available at that point, pass "unknown".
     - In the main try/catch error handler, call: `captureError(error instanceof Error ? error : new Error(String(error)), { route: "POST /api/chat", userId })`
     - Before the AI call, add a breadcrumb: `addBreadcrumb("Starting AI chat completion", "ai", { model: "..." })` -- use whatever model variable is available
     - Do NOT wrap individual lines in try/catch -- use the existing error handling structure

  2. **`app/api/stripe/webhook/route.ts`** (payment processing -- business critical):
     - At the top, add: `import { captureError, captureMessage } from "@/lib/sentry";`
     - In the catch block for webhook signature verification failure, add: `captureMessage("Stripe webhook signature verification failed", "warning")`
     - In catch blocks for individual event handlers, add: `captureError(error instanceof Error ? error : new Error(String(error)), { route: "POST /api/stripe/webhook", eventType: event.type })`
     - Do NOT change any business logic -- only add Sentry calls alongside existing error handling

  3. **Update `lib/sentry.ts`** to also export a `withSentryServerAction` wrapper that can be used for server actions in future plans:

  ```typescript
  export function withSentrySpan<T>(
    name: string,
    op: string,
    fn: () => Promise<T>
  ): Promise<T> {
    if (!process.env.NEXT_PUBLIC_SENTRY_DSN) return fn();
    return Sentry.startSpan({ name, op }, fn);
  }
  ```

  IMPORTANT: Be surgical. Read the full route files first. Find the existing error handling patterns and add Sentry calls next to them. Do not restructure error handling.
  </action>
  <verify>
  - `grep -r "from.*lib/sentry" app/api/chat/route.ts` shows import
  - `grep -r "from.*lib/sentry" app/api/stripe/webhook/route.ts` shows import
  - `npx tsc --noEmit` passes
  - `npm run test` passes (existing tests should not break from adding Sentry calls that are no-ops without DSN)
  </verify>
  <done>
  The two most critical API routes (chat and Stripe webhook) are wired to Sentry with user context, error capture, and breadcrumbs. lib/sentry.ts exports a new `withSentrySpan` helper for performance tracing. All Sentry calls are no-ops without DSN set.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
  Sentry is fully configured across client, server, and edge runtimes. The code is ready to activate -- but requires 4 environment variables to be set simultaneously in both Vercel AND GitHub Actions.

  CRITICAL (from Pitfall #1): Setting the DSN without SENTRY_AUTH_TOKEN causes source map uploads to fail, making Sentry errors unreadable. All 4 vars MUST be set together.
  </what-built>
  <how-to-verify>
  Set these 4 environment variables in BOTH Vercel (Build & Runtime) AND GitHub Actions secrets:

  1. `NEXT_PUBLIC_SENTRY_DSN` -- from Sentry Dashboard -> Project Settings -> Client Keys (DSN)
  2. `SENTRY_AUTH_TOKEN` -- from Sentry Dashboard -> Settings -> Auth Tokens -> Create (needs org:read, project:releases, project:write scopes)
  3. `SENTRY_ORG` -- your Sentry organization slug (from the URL)
  4. `SENTRY_PROJECT` -- your Sentry project slug

  **In Vercel:**
  - Go to Project Settings -> Environment Variables
  - Add all 4 vars for Production, Preview, AND Development environments
  - SENTRY_AUTH_TOKEN goes in "Build" environment (it's used during build, not runtime)
  - NEXT_PUBLIC_SENTRY_DSN goes in both Build and Runtime

  **In GitHub Actions:**
  - Go to repo Settings -> Secrets and variables -> Actions
  - Add SENTRY_AUTH_TOKEN as a repository secret (needed for CI builds)

  After setting vars, trigger a Vercel deployment (push a commit or redeploy).

  **Verify in Sentry Dashboard:**
  1. After deployment, visit the production site
  2. Open browser console and type: `throw new Error("Sentry test from console")`
  3. Check Sentry Dashboard -> Issues -- the error should appear within 30 seconds
  4. The stack trace should show readable source code (not minified) -- this confirms source maps work
  5. Check Sentry Dashboard -> Settings -> Source Maps -- upload artifacts should be listed

  Type "approved" once Sentry is receiving errors with readable source maps, or describe any issues.
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
- `sentry.edge.config.ts` exists and initializes Sentry for edge runtime
- `instrumentation.ts` handles nodejs AND edge runtime initialization
- `lib/sentry.ts` helpers are imported by at least 2 API route files
- `npx tsc --noEmit` passes
- `npm run build` completes without Sentry errors
- After env var activation: test error appears in Sentry with readable source maps
</verification>

<success_criteria>
1. Sentry initializes in all three runtimes (client, server, edge) when DSN is set
2. Source maps upload during build and errors show readable stack traces in Sentry
3. Key API routes (chat, Stripe webhook) send errors to Sentry with user context
4. Noisy browser errors are filtered out before sending to Sentry
5. Sentry tunnel route (`/monitoring-tunnel`) proxies events to bypass ad blockers
6. All Sentry functionality is no-op when DSN is not set (dev environments)
</success_criteria>

<output>
After completion, create `.planning/phases/59-sentry-production-monitoring/59-01-SUMMARY.md`
</output>
