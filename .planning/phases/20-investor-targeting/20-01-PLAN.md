---
phase: 20-investor-targeting
plan: 01
type: execute
wave: 2
depends_on: []
files_modified:
  - lib/db/migrations/038_investor_tables.sql
  - lib/investors/csv-parser.ts
  - lib/investors/matching.ts
  - app/api/investors/upload/route.ts
  - app/api/investors/match/route.ts
  - app/dashboard/investor-targeting/page.tsx
  - app/dashboard/investor-targeting/matches/page.tsx
autonomous: true

must_haves:
  truths:
    - "Migration 038 creates 4 tables: investor_lists, investors, investor_matches, investor_match_scores"
    - "CSV parser handles common investor CSV formats with validation and error reporting"
    - "Matching engine scores investors against founder profiles using stage, sector, and check size"
    - "Upload API accepts multipart CSV files and persists parsed investors to the database"
    - "Match API triggers AI matching and returns scored investor recommendations"
    - "Investor targeting page shows uploaded lists with investor counts"
    - "Matches page displays AI-scored investor recommendations with match reasoning"
  artifacts:
    - path: "lib/db/migrations/038_investor_tables.sql"
      provides: "4 investor-related tables with RLS policies"
    - path: "lib/investors/csv-parser.ts"
      provides: "CSV parsing with validation for investor data"
      exports: ["parseInvestorCSV", "InvestorRow"]
    - path: "lib/investors/matching.ts"
      provides: "AI-powered investor matching engine"
      exports: ["matchInvestors", "InvestorMatch"]
    - path: "app/api/investors/upload/route.ts"
      provides: "POST endpoint for CSV file upload"
    - path: "app/api/investors/match/route.ts"
      provides: "POST endpoint to trigger matching, GET to retrieve matches"
    - path: "app/dashboard/investor-targeting/page.tsx"
      provides: "Investor list management page"
    - path: "app/dashboard/investor-targeting/matches/page.tsx"
      provides: "AI-scored match results page"
  key_links:
    - from: "app/api/investors/upload/route.ts"
      to: "lib/investors/csv-parser.ts"
      via: "parses uploaded CSV via parseInvestorCSV()"
      pattern: "parseInvestorCSV"
    - from: "app/api/investors/match/route.ts"
      to: "lib/investors/matching.ts"
      via: "triggers AI matching via matchInvestors()"
      pattern: "matchInvestors"
    - from: "app/dashboard/investor-targeting/page.tsx"
      to: "app/api/investors/upload/route.ts"
      via: "uploads CSV files to upload API"
      pattern: "/api/investors/upload"
    - from: "app/dashboard/investor-targeting/matches/page.tsx"
      to: "app/api/investors/match/route.ts"
      via: "fetches match results from match API"
      pattern: "/api/investors/match"
---

<objective>
Build CSV investor list upload and AI-powered investor matching so Studio founders can upload investor lists and get scored recommendations.

Purpose: Founders waste enormous time on investor outreach that goes nowhere because of poor targeting. This plan enables CSV upload of investor lists (from admin-curated partner lists or founder's own contacts), AI matching based on stage, sector, and check size alignment, and a scored results view with match reasoning. Fred's investor experience informs the matching criteria.

Output: 1 new migration, 2 new library files, 2 new API routes, 2 new pages. No new npm dependencies (use built-in CSV parsing).
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

Key source files (READ ALL BEFORE MODIFYING):
@lib/fred-brain.ts (Fred's investor experience for matching criteria)
@lib/agents/fundraising/tools.ts (existing investor research tool for reference)
@lib/db/migrations/028_agent_tasks.sql (agent_tasks schema for reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database, CSV parser, and upload API</name>
  <files>
    lib/db/migrations/038_investor_tables.sql
    lib/investors/csv-parser.ts
    app/api/investors/upload/route.ts
  </files>
  <action>
**Step 1: Create migration `lib/db/migrations/038_investor_tables.sql`**

Create 4 tables:

```sql
-- Investor lists (one per upload)
CREATE TABLE investor_lists (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES auth.users NOT NULL,
  name text NOT NULL,
  source text NOT NULL DEFAULT 'upload', -- 'upload', 'admin', 'manual'
  investor_count integer DEFAULT 0,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- Individual investors
CREATE TABLE investors (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  list_id uuid REFERENCES investor_lists ON DELETE CASCADE NOT NULL,
  name text NOT NULL,
  firm text,
  email text,
  website text,
  stage_focus text[], -- e.g., ['pre-seed', 'seed']
  sector_focus text[], -- e.g., ['SaaS', 'FinTech']
  check_size_min integer, -- in dollars
  check_size_max integer,
  location text,
  notes text,
  raw_data jsonb, -- original CSV row for reference
  created_at timestamptz DEFAULT now()
);

-- Match results
CREATE TABLE investor_matches (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES auth.users NOT NULL,
  investor_id uuid REFERENCES investors ON DELETE CASCADE NOT NULL,
  overall_score integer NOT NULL, -- 0-100
  stage_score integer,
  sector_score integer,
  size_score integer,
  reasoning text,
  status text DEFAULT 'new', -- 'new', 'contacted', 'passed', 'interested'
  created_at timestamptz DEFAULT now(),
  UNIQUE(user_id, investor_id)
);

-- Score breakdown for transparency
CREATE TABLE investor_match_scores (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  match_id uuid REFERENCES investor_matches ON DELETE CASCADE NOT NULL,
  dimension text NOT NULL, -- 'stage', 'sector', 'size', 'location', 'track_record'
  score integer NOT NULL,
  explanation text,
  created_at timestamptz DEFAULT now()
);
```

Add RLS policies: users can only access their own investor_lists, investors (via list ownership), and investor_matches. Add indexes on investor_matches(user_id, overall_score).

**Step 2: Create `lib/investors/csv-parser.ts`**

Export `parseInvestorCSV(csvText: string): { rows: InvestorRow[]; errors: string[] }`:

Define `InvestorRow` interface:
```typescript
export interface InvestorRow {
  name: string;
  firm?: string;
  email?: string;
  website?: string;
  stageFocus?: string[];
  sectorFocus?: string[];
  checkSizeMin?: number;
  checkSizeMax?: number;
  location?: string;
  notes?: string;
  rawData: Record<string, string>;
}
```

Implementation:
1. Split CSV text by newlines, parse header row
2. Normalize header names (lowercase, trim, handle common variations):
   - "investor name" / "name" / "contact" -> name
   - "firm" / "fund" / "company" / "organization" -> firm
   - "email" / "email address" -> email
   - "website" / "url" / "site" -> website
   - "stage" / "stage focus" / "stage preference" -> stageFocus (split by comma/semicolon)
   - "sector" / "sector focus" / "industry" / "vertical" -> sectorFocus (split by comma/semicolon)
   - "check size" / "ticket size" / "min check" -> checkSizeMin (parse dollar amounts)
   - "max check" / "check size max" -> checkSizeMax
   - "location" / "city" / "geography" -> location
   - "notes" / "comments" -> notes
3. Validate: name is required. Skip rows without name, add to errors array.
4. Parse dollar amounts: handle "$", "K", "M" suffixes (e.g., "$500K" -> 500000)
5. Return parsed rows and any validation errors

**Step 3: Create `app/api/investors/upload/route.ts`**

POST endpoint:
1. Authenticate user (must be Studio tier -- check subscription)
2. Accept multipart/form-data with a CSV file field
3. Read file content as text
4. Call parseInvestorCSV() on the content
5. If errors exceed 50% of rows, return 400 with errors
6. Create an investor_lists row, then bulk insert investors
7. Return 201 with: `{ listId, investorCount, errors }`
8. Max file size: 1MB. Return 413 if exceeded.
  </action>
  <verify>
1. `test -f lib/db/migrations/038_investor_tables.sql` -- migration exists
2. `grep 'investor_lists\|investors\|investor_matches\|investor_match_scores' lib/db/migrations/038_investor_tables.sql` -- all 4 tables
3. `test -f lib/investors/csv-parser.ts` -- parser exists
4. `grep 'parseInvestorCSV\|InvestorRow' lib/investors/csv-parser.ts` -- exports present
5. `test -f app/api/investors/upload/route.ts` -- upload API exists
6. `npx tsc --noEmit` passes with no errors
  </verify>
  <done>
Migration 038 creates 4 investor tables with RLS and indexes. CSV parser handles common formats with flexible header mapping and dollar amount parsing. Upload API accepts multipart CSV, validates, and bulk inserts with error reporting.
  </done>
</task>

<task type="auto">
  <name>Task 2: Matching engine and UI</name>
  <files>
    lib/investors/matching.ts
    app/api/investors/match/route.ts
    app/dashboard/investor-targeting/page.tsx
    app/dashboard/investor-targeting/matches/page.tsx
  </files>
  <action>
**Step 1: Create `lib/investors/matching.ts`**

Export `matchInvestors(userId: string, listId?: string): Promise<InvestorMatch[]>`:

1. Load the user's profile (stage, industry, funding history) from profiles table
2. Load investors from investor_lists (optionally filtered by listId)
3. For each investor, calculate match scores across dimensions:
   - **Stage score (0-100)**: How well investor's stage_focus matches founder's stage
   - **Sector score (0-100)**: How well investor's sector_focus matches founder's industry
   - **Size score (0-100)**: Whether founder's likely raise amount falls within check_size range
   - **Location score (0-30 bonus)**: Geographic proximity bonus
4. Calculate overall_score as weighted average: stage 35%, sector 35%, size 30% + location bonus
5. Generate reasoning string explaining why each investor is a good/poor match
6. Use AI (generateText) for reasoning generation with Fred's investor voice
7. Upsert results into investor_matches and investor_match_scores tables
8. Return matches sorted by overall_score desc, limit to top 25

Export `InvestorMatch` interface matching the database schema.

**Step 2: Create `app/api/investors/match/route.ts`**

- POST: Authenticate user (Studio tier). Accept optional `{ listId }` body. Call matchInvestors(userId, listId). Return scored matches.
- GET: Authenticate user. Return existing matches from investor_matches table, ordered by overall_score desc. Accept optional `listId` query param.

**Step 3: Create `app/dashboard/investor-targeting/page.tsx`**

"use client" page at /dashboard/investor-targeting:
- Page header: "Investor Targeting" with subtitle about AI-powered matching
- **Upload section**:
  - File input accepting .csv files
  - Upload button with progress indicator
  - Display upload results (investor count, any parsing errors)
- **Lists section**:
  - Fetch existing investor_lists for the user
  - Card for each list showing: name, investor count, upload date
  - "Run Matching" button on each list that POSTs to /api/investors/match
  - "View Matches" link to /dashboard/investor-targeting/matches?listId=xxx
- **Empty state**: "Upload your first investor list to get started"
- Studio tier gating: wrap with FeatureLock component

**Step 4: Create `app/dashboard/investor-targeting/matches/page.tsx`**

"use client" page at /dashboard/investor-targeting/matches:
- Fetch matches from GET /api/investors/match (with optional listId query param)
- Display as a scored list with:
  - Investor name, firm
  - Overall match score (color-coded: green 70+, yellow 40-69, red <40)
  - Score breakdown bars: stage, sector, size
  - AI reasoning summary
  - Contact info (email, website) with action buttons
  - Status badge (new, contacted, passed, interested)
- Sort by match score (default) or name
- Loading skeleton and empty state
  </action>
  <verify>
1. `test -f lib/investors/matching.ts` -- matching engine exists
2. `grep 'matchInvestors' lib/investors/matching.ts` -- function exported
3. `test -f app/api/investors/match/route.ts` -- match API exists
4. `test -f app/dashboard/investor-targeting/page.tsx` -- targeting page exists
5. `test -f app/dashboard/investor-targeting/matches/page.tsx` -- matches page exists
6. `npx tsc --noEmit` passes with no errors
  </verify>
  <done>
Matching engine scores investors across stage, sector, and size dimensions with AI-generated reasoning. Match API triggers matching and retrieves results. Targeting page manages uploads and lists. Matches page displays scored results with breakdown and actions.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Database migration:**
   ```bash
   test -f lib/db/migrations/038_investor_tables.sql && echo "EXISTS"
   grep -c 'CREATE TABLE' lib/db/migrations/038_investor_tables.sql
   # Should be 4
   ```

2. **Library files:**
   ```bash
   test -f lib/investors/csv-parser.ts && test -f lib/investors/matching.ts && echo "EXISTS"
   ```

3. **API routes:**
   ```bash
   test -f app/api/investors/upload/route.ts && test -f app/api/investors/match/route.ts && echo "EXISTS"
   ```

4. **UI pages:**
   ```bash
   test -f app/dashboard/investor-targeting/page.tsx && test -f app/dashboard/investor-targeting/matches/page.tsx && echo "EXISTS"
   ```

5. **TypeScript compiles:**
   ```bash
   npx tsc --noEmit
   ```
</verification>

<success_criteria>
- Migration creates 4 investor tables (lists, investors, matches, scores) with RLS
- CSV parser handles common header variations and dollar amount formats
- Upload API validates, parses, and persists CSV data with error reporting
- Matching engine scores investors across stage (35%), sector (35%), size (30%) + location bonus
- AI generates match reasoning in Fred's investor voice
- Targeting page manages uploads and lists with FeatureLock for Studio tier
- Matches page displays scored results with breakdown bars and contact actions
- No new npm dependencies
- TypeScript compiles with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/20-investor-targeting/20-01-SUMMARY.md`
</output>
