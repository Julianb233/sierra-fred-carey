---
phase: 12-data-fixes-production-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - middleware.ts
  - lib/auth/middleware-utils.ts
  - app/robots.ts
  - app/sitemap.ts
  - lib/api/cors.ts
  - lib/api/rate-limit.ts
  - lib/rate-limit.ts
  - lib/env.ts
  - scripts/validate-env.ts
  - package.json
autonomous: true
user_setup:
  - service: upstash
    why: "Redis-based rate limiting for multi-instance Vercel deployment"
    env_vars:
      - name: UPSTASH_REDIS_REST_URL
        source: "Upstash Console -> Create Redis Database -> REST API URL"
      - name: UPSTASH_REDIS_REST_TOKEN
        source: "Upstash Console -> Create Redis Database -> REST API Token"
    dashboard_config:
      - task: "Create a Redis database"
        location: "https://console.upstash.com -> Create Database -> choose region closest to Vercel deployment"

must_haves:
  truths:
    - "Unauthenticated users visiting /dashboard, /settings, /agents, or /chat are redirected to /login with a redirect query param"
    - "robots.txt is served at /robots.txt with correct disallow rules for private routes"
    - "sitemap.xml is served at /sitemap.xml listing all public pages"
    - "All API routes return CORS headers (Access-Control-Allow-Origin) on responses"
    - "Rate limiting uses @upstash/ratelimit with Redis backend (no in-memory Map)"
    - "Missing required env vars cause a clear startup failure with named missing vars"
  artifacts:
    - path: "middleware.ts"
      provides: "Root edge middleware for auth protection"
      exports: ["middleware", "config"]
    - path: "app/robots.ts"
      provides: "Dynamic robots.txt generation"
      exports: ["default"]
    - path: "app/sitemap.ts"
      provides: "Dynamic sitemap.xml generation"
      exports: ["default"]
    - path: "lib/api/cors.ts"
      provides: "Centralized CORS utility"
      exports: ["corsHeaders", "withCorsHeaders", "handleCorsOptions"]
    - path: "lib/api/rate-limit.ts"
      provides: "Upstash-backed rate limiting (replaces in-memory)"
      exports: ["checkRateLimit", "checkRateLimitForUser", "RATE_LIMIT_TIERS"]
    - path: "scripts/validate-env.ts"
      provides: "Standalone env var validation script"
    - path: "lib/env.ts"
      provides: "Expanded Zod schema with Stripe and Upstash vars"
  key_links:
    - from: "middleware.ts"
      to: "lib/supabase/middleware.ts"
      via: "import updateSession"
      pattern: "updateSession"
    - from: "middleware.ts"
      to: "/login"
      via: "NextResponse.redirect"
      pattern: "redirect.*login"
    - from: "lib/api/rate-limit.ts"
      to: "@upstash/ratelimit"
      via: "import Ratelimit"
      pattern: "Ratelimit"
    - from: "instrumentation.ts"
      to: "lib/env.ts"
      via: "import validateEnv"
      pattern: "validateEnv"
---

<objective>
Harden production infrastructure by adding edge middleware for auth protection, SEO files (robots.txt, sitemap.xml), centralized CORS handling, Redis-based rate limiting via Upstash, and comprehensive env var validation.

Purpose: The application lacks root middleware (any URL is accessible without auth), has no robots.txt or sitemap for SEO, uses in-memory rate limiting that resets on cold starts and doesn't share across Vercel instances, and only validates 4 of 20+ env vars at startup.

Output: Complete production infrastructure layer -- protected routes, SEO files, CORS utility, Upstash rate limiting, and fail-fast env validation.
</objective>

<execution_context>
@/opt/agency-workspace/sierra-fred-carey/.planning/workflows/execute-plan.md
@/opt/agency-workspace/sierra-fred-carey/.planning/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-data-fixes-production-hardening/12-RESEARCH.md

Key source files:
@lib/supabase/middleware.ts
@lib/auth/middleware-utils.ts
@lib/api/rate-limit.ts
@lib/rate-limit.ts
@lib/env.ts
@instrumentation.ts
@lib/stripe/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create root middleware, robots.ts, sitemap.ts, and CORS utility</name>
  <files>
    middleware.ts
    lib/auth/middleware-utils.ts
    app/robots.ts
    app/sitemap.ts
    lib/api/cors.ts
  </files>
  <action>
**Step 1: Add /chat to protected routes in lib/auth/middleware-utils.ts (PROD-01)**

Update the DEFAULT_PROTECTED_ROUTES paths array (line ~34) to include '/chat':

```typescript
export const DEFAULT_PROTECTED_ROUTES: ProtectedRouteConfig = {
  paths: ['/dashboard', '/agents', '/documents', '/settings', '/profile', '/chat'],
  patterns: [/^\/api\/protected\//],
};
```

**Step 2: Create root middleware.ts (PROD-01)**

Create `middleware.ts` at the project root (NOT in lib/ or app/). This file:

1. Calls `updateSession()` from `lib/supabase/middleware.ts` to refresh auth tokens
2. Checks if the current route is protected using the existing `isProtectedRoute()` from `lib/auth/middleware-utils.ts`
3. Redirects unauthenticated users to `/login?redirect=<pathname>`
4. Uses the standard Next.js matcher to exclude static assets

```typescript
import { type NextRequest, NextResponse } from "next/server";
import { updateSession } from "@/lib/supabase/middleware";
import { isProtectedRoute } from "@/lib/auth/middleware-utils";

export async function middleware(request: NextRequest) {
  // Refresh auth session on every request
  const { response, user } = await updateSession(request);
  const { pathname } = request.nextUrl;

  // Check if this route requires authentication
  if (isProtectedRoute(pathname) && !user) {
    const loginUrl = new URL('/login', request.url);
    loginUrl.searchParams.set('redirect', pathname);
    return NextResponse.redirect(loginUrl);
  }

  return response;
}

export const config = {
  matcher: [
    /*
     * Match all paths except:
     * - _next/static (static files)
     * - _next/image (image optimization)
     * - favicon.ico
     * - Static assets (svg, png, jpg, jpeg, gif, webp, ico)
     */
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp|ico)$).*)',
  ],
};
```

IMPORTANT: The `updateSession` function already returns `{ response, user }` where `user` is null when not authenticated. This middleware leverages the existing Supabase SSR auth infrastructure. Do NOT create a separate auth check -- use the existing `updateSession` which internally calls `supabase.auth.getUser()`.

**Step 3: Create app/robots.ts (PROD-02)**

Create `app/robots.ts` using Next.js MetadataRoute API (NOT a static file in /public/):

```typescript
import type { MetadataRoute } from 'next';

export default function robots(): MetadataRoute.Robots {
  const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'https://joinsahara.com';

  return {
    rules: [
      {
        userAgent: '*',
        allow: '/',
        disallow: [
          '/dashboard/',
          '/api/',
          '/admin/',
          '/settings/',
          '/agents/',
          '/chat/',
          '/onboarding/',
          '/check-ins/',
          '/documents/',
          '/profile/',
        ],
      },
    ],
    sitemap: `${baseUrl}/sitemap.xml`,
  };
}
```

**Step 4: Create app/sitemap.ts (PROD-03)**

Create `app/sitemap.ts` using Next.js MetadataRoute API. Include all public-facing routes discovered in the research. Exclude all authenticated/private routes.

```typescript
import type { MetadataRoute } from 'next';

export default function sitemap(): MetadataRoute.Sitemap {
  const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'https://joinsahara.com';
  const now = new Date();

  return [
    // Core pages
    { url: baseUrl, lastModified: now, changeFrequency: 'weekly', priority: 1 },
    { url: `${baseUrl}/about`, lastModified: now, changeFrequency: 'monthly', priority: 0.8 },
    { url: `${baseUrl}/pricing`, lastModified: now, changeFrequency: 'monthly', priority: 0.9 },
    { url: `${baseUrl}/features`, lastModified: now, changeFrequency: 'monthly', priority: 0.8 },
    { url: `${baseUrl}/product`, lastModified: now, changeFrequency: 'monthly', priority: 0.8 },
    { url: `${baseUrl}/interactive`, lastModified: now, changeFrequency: 'monthly', priority: 0.7 },

    // Content & engagement
    { url: `${baseUrl}/blog`, lastModified: now, changeFrequency: 'weekly', priority: 0.7 },
    { url: `${baseUrl}/contact`, lastModified: now, changeFrequency: 'yearly', priority: 0.5 },
    { url: `${baseUrl}/support`, lastModified: now, changeFrequency: 'monthly', priority: 0.5 },
    { url: `${baseUrl}/waitlist`, lastModified: now, changeFrequency: 'monthly', priority: 0.6 },
    { url: `${baseUrl}/links`, lastModified: now, changeFrequency: 'monthly', priority: 0.4 },
    { url: `${baseUrl}/video`, lastModified: now, changeFrequency: 'monthly', priority: 0.5 },

    // Auth pages (public entry points)
    { url: `${baseUrl}/login`, lastModified: now, changeFrequency: 'yearly', priority: 0.4 },
    { url: `${baseUrl}/signup`, lastModified: now, changeFrequency: 'yearly', priority: 0.5 },
    { url: `${baseUrl}/get-started`, lastModified: now, changeFrequency: 'monthly', priority: 0.7 },

    // Legal
    { url: `${baseUrl}/privacy`, lastModified: now, changeFrequency: 'yearly', priority: 0.3 },
    { url: `${baseUrl}/terms`, lastModified: now, changeFrequency: 'yearly', priority: 0.3 },

    // Demo pages
    { url: `${baseUrl}/demo/reality-lens`, lastModified: now, changeFrequency: 'monthly', priority: 0.6 },
    { url: `${baseUrl}/demo/investor-lens`, lastModified: now, changeFrequency: 'monthly', priority: 0.6 },
    { url: `${baseUrl}/demo/virtual-team`, lastModified: now, changeFrequency: 'monthly', priority: 0.6 },
    { url: `${baseUrl}/demo/pitch-deck`, lastModified: now, changeFrequency: 'monthly', priority: 0.6 },
    { url: `${baseUrl}/demo/boardy`, lastModified: now, changeFrequency: 'monthly', priority: 0.6 },

    // Tools
    { url: `${baseUrl}/tools/investor-readiness`, lastModified: now, changeFrequency: 'monthly', priority: 0.6 },
  ];
}
```

**Step 5: Create lib/api/cors.ts (PROD-06)**

Create a centralized CORS utility. This replaces the per-route OPTIONS handlers currently in pitch-deck routes.

```typescript
import { NextRequest, NextResponse } from "next/server";

const ALLOWED_ORIGINS = new Set([
  process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000",
  "http://localhost:3000",
  "http://localhost:3001",
]);

// Webhook origins that bypass CORS (they use signature verification instead)
const WEBHOOK_PATHS = new Set([
  "/api/stripe/webhook",
  "/api/sms/webhook",
  "/api/boardy/callback",
]);

/**
 * Get CORS headers for a given origin
 */
export function corsHeaders(origin?: string | null): Record<string, string> {
  const allowedOrigin = origin && ALLOWED_ORIGINS.has(origin)
    ? origin
    : (process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000");

  return {
    "Access-Control-Allow-Origin": allowedOrigin,
    "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type, Authorization, X-Requested-With",
    "Access-Control-Max-Age": "86400",
  };
}

/**
 * Add CORS headers to an existing NextResponse
 */
export function withCorsHeaders(
  response: NextResponse,
  origin?: string | null
): NextResponse {
  const headers = corsHeaders(origin);
  for (const [key, value] of Object.entries(headers)) {
    response.headers.set(key, value);
  }
  return response;
}

/**
 * Handle OPTIONS preflight request
 */
export function handleCorsOptions(request: NextRequest): NextResponse {
  const origin = request.headers.get("origin");
  const response = new NextResponse(null, { status: 204 });
  return withCorsHeaders(response, origin);
}

/**
 * Check if a path is a webhook endpoint (skips CORS)
 */
export function isWebhookPath(pathname: string): boolean {
  return WEBHOOK_PATHS.has(pathname);
}
```

**Step 6: Verify PROD-04 (Image optimization)**

Run a grep to confirm no `<img` tags exist in source files:
```bash
grep -rn '<img ' app/ components/ lib/ --include="*.tsx" --include="*.ts"
```

If this returns ZERO results, PROD-04 is already complete. Document in the summary. If any results are found, convert those to `next/image` Image components.
  </action>
  <verify>
1. **Middleware exists and compiles:**
   ```bash
   ls middleware.ts
   npx tsc --noEmit 2>&1 | head -20
   ```

2. **robots.ts serves correctly:**
   ```bash
   # Verify file exists and exports default function
   grep 'export default function robots' app/robots.ts
   ```

3. **sitemap.ts serves correctly:**
   ```bash
   # Verify file exists and exports default function
   grep 'export default function sitemap' app/sitemap.ts
   ```

4. **CORS utility exports:**
   ```bash
   grep 'export function' lib/api/cors.ts
   ```

5. **Protected routes include /chat:**
   ```bash
   grep "'/chat'" lib/auth/middleware-utils.ts
   ```

6. **Image audit (PROD-04):**
   ```bash
   grep -rn '<img ' app/ components/ lib/ --include="*.tsx" --include="*.ts" | wc -l
   # Should be 0
   ```
  </verify>
  <done>
PROD-01: Root middleware.ts at project root protects /dashboard, /settings, /agents, /chat, /documents, /profile routes. Unauthenticated users redirected to /login?redirect=<path>. Uses existing Supabase SSR updateSession infrastructure.
PROD-02: app/robots.ts generated via Next.js MetadataRoute API. Disallows /dashboard/, /api/, /admin/, /settings/, /agents/, /chat/, /onboarding/, /check-ins/, /documents/, /profile/. Links to sitemap.
PROD-03: app/sitemap.ts generated via Next.js MetadataRoute API. Lists 24 public pages with appropriate priority and changeFrequency values.
PROD-04: Verified -- no <img> tags found in source files. All images already use next/image.
PROD-06: lib/api/cors.ts created with corsHeaders(), withCorsHeaders(), handleCorsOptions(), and isWebhookPath() utilities. Webhook paths excluded from CORS to prevent blocking Stripe/Twilio/Boardy callbacks.
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace in-memory rate limiting with Upstash Redis and expand env var validation</name>
  <files>
    package.json
    lib/api/rate-limit.ts
    lib/rate-limit.ts
    lib/env.ts
    scripts/validate-env.ts
  </files>
  <action>
**Step 1: Install Upstash packages (PROD-05)**

```bash
npm install @upstash/ratelimit @upstash/redis
```

**Step 2: Rewrite lib/api/rate-limit.ts to use Upstash (PROD-05)**

Replace the in-memory Map-based implementation with @upstash/ratelimit. CRITICALLY IMPORTANT: Preserve the EXACT same exported interface so all 14 consuming files continue to work without changes. The existing exports are:
- `checkRateLimit(identifier, config)` -- used by diagnostic, onboard, auth/login, admin/login routes
- `checkRateLimitForUser(req, userId, tier)` -- used by fred/chat, fred/memory, fred/history, fred/analyze, fred/decide routes
- `createRateLimitResponse(result)` -- used by diagnostic routes
- `applyRateLimitHeaders(response, result)` -- used by fred/memory, fred/analyze, fred/decide routes
- `RATE_LIMIT_TIERS` -- used by fred/chat, fred/analyze, fred/decide routes
- `withRateLimit(handler, config)` -- middleware wrapper
- `RateLimitConfig` interface -- used in type annotations
- `RateLimitResult` interface -- used in type annotations

Rewrite approach:

```typescript
/**
 * Rate Limiting Middleware -- Upstash Redis Backend
 *
 * Production-ready rate limiter using @upstash/ratelimit with Redis.
 * Falls back to in-memory for development when UPSTASH vars are not set.
 */

import { NextRequest, NextResponse } from "next/server";
import { Ratelimit } from "@upstash/ratelimit";
import { Redis } from "@upstash/redis";

// ... keep the same RateLimitConfig, RateLimitResult interfaces

// Create Redis client (module-scope for connection reuse across warm invocations)
const redis = process.env.UPSTASH_REDIS_REST_URL
  ? new Redis({
      url: process.env.UPSTASH_REDIS_REST_URL,
      token: process.env.UPSTASH_REDIS_REST_TOKEN!,
    })
  : null;

// Pre-built limiters for each tier (module-scope to avoid cold-start overhead)
const rateLimiters = redis
  ? {
      free: new Ratelimit({ redis, limiter: Ratelimit.slidingWindow(20, "60 s"), prefix: "rl:free" }),
      pro: new Ratelimit({ redis, limiter: Ratelimit.slidingWindow(100, "60 s"), prefix: "rl:pro" }),
      studio: new Ratelimit({ redis, limiter: Ratelimit.slidingWindow(500, "60 s"), prefix: "rl:studio" }),
      unlimited: new Ratelimit({ redis, limiter: Ratelimit.slidingWindow(10000, "60 s"), prefix: "rl:unlimited" }),
    }
  : null;
```

Then rewrite `checkRateLimit` to use `rateLimiters[tier].limit(identifier)` when Redis is available, falling back to the existing in-memory approach for local development (when UPSTASH env vars are not set).

Keep the RATE_LIMIT_TIERS export with the same shape:
```typescript
export const RATE_LIMIT_TIERS = {
  free: { limit: 20, windowSeconds: 60 },
  pro: { limit: 100, windowSeconds: 60 },
  studio: { limit: 500, windowSeconds: 60 },
  unlimited: { limit: 10000, windowSeconds: 60 },
} as const;
```

For the in-memory fallback (dev mode), keep a simple Map-based approach inline in the same file (do not import from lib/rate-limit.ts). Wrap the fallback with a `console.warn` on first use: `"[rate-limit] UPSTASH_REDIS_REST_URL not set, using in-memory fallback (not suitable for production)"`.

Keep ALL existing function signatures identical:
- `checkRateLimit(identifier: string, config: RateLimitConfig): RateLimitResult` -- must remain synchronous for in-memory fallback BUT needs to be `async` for Upstash. Change signature to `Promise<RateLimitResult>` and update all callers if needed. HOWEVER, check if callers already await it -- if not, this is a breaking change. In that case, keep the sync signature for in-memory and create a new `checkRateLimitAsync` that the code can migrate to.

Actually, looking at the callers: `checkRateLimit` is called without `await` in the API routes. The `checkRateLimitForUser` also returns synchronously. Since Upstash requires async, the approach should be:

1. Make `checkRateLimit` return `Promise<RateLimitResult>` (add `async`)
2. Make `checkRateLimitForUser` return `Promise<{ response: NextResponse | null; result: RateLimitResult }>`
3. Update all calling sites to add `await` -- there are 14 callers identified:
   - `app/api/diagnostic/route.ts`
   - `app/api/diagnostic/positioning/route.ts`
   - `app/api/diagnostic/investor/route.ts`
   - `app/api/onboard/route.ts`
   - `app/api/auth/login/route.ts`
   - `app/api/admin/login/route.ts`
   - `app/api/fred/reality-lens/route.ts`
   - `app/api/fred/memory/route.ts`
   - `app/api/fred/chat/route.ts`
   - `app/api/fred/history/route.ts`
   - `app/api/fred/analyze/route.ts`
   - `app/api/fred/decide/route.ts`

For each caller, find the call to `checkRateLimit(...)` or `checkRateLimitForUser(...)` and add `await` before it. These are already in `async` route handler functions, so adding `await` is safe.

Also update the `withRateLimit` wrapper to await the internal `checkRateLimit` call.

**Step 3: Deprecate lib/rate-limit.ts (PROD-05)**

Add a deprecation notice to the top of lib/rate-limit.ts:

```typescript
/**
 * @deprecated Use lib/api/rate-limit.ts instead (Upstash Redis backend).
 * This in-memory rate limiter is kept only for the single consumer
 * (app/api/onboard/invite/route.ts) that imports RateLimiter directly.
 */
```

Check if `app/api/onboard/invite/route.ts` uses the RateLimiter class from this file. If so, migrate it to use `checkRateLimit` from `lib/api/rate-limit.ts` instead, then mark lib/rate-limit.ts as fully deprecated.

**Step 4: Expand lib/env.ts server schema (PROD-07)**

Expand the `serverEnvSchema` to include Stripe and Upstash vars as required in production:

```typescript
const serverEnvSchema = z.object({
  SUPABASE_SERVICE_ROLE_KEY: z
    .string()
    .min(1, "SUPABASE_SERVICE_ROLE_KEY is required"),
  JWT_SECRET: z.string().min(1, "JWT_SECRET is required"),
  // Stripe (required for billing)
  STRIPE_SECRET_KEY: z
    .string()
    .min(1, "STRIPE_SECRET_KEY is required")
    .optional()
    .default(""),
  STRIPE_WEBHOOK_SECRET: z
    .string()
    .optional()
    .default(""),
  // Upstash Redis (required for production rate limiting)
  UPSTASH_REDIS_REST_URL: z
    .string()
    .url("UPSTASH_REDIS_REST_URL must be a valid URL")
    .optional()
    .default(""),
  UPSTASH_REDIS_REST_TOKEN: z
    .string()
    .optional()
    .default(""),
});
```

Note: These are marked `.optional().default("")` so dev environments without them don't crash. The validation script (Step 5) will enforce them for production.

Also update the clientEnvSchema to include Stripe publishable key:

```typescript
const clientEnvSchema = z.object({
  NEXT_PUBLIC_SUPABASE_URL: z
    .string()
    .url("NEXT_PUBLIC_SUPABASE_URL must be a valid URL"),
  NEXT_PUBLIC_SUPABASE_ANON_KEY: z
    .string()
    .min(1, "NEXT_PUBLIC_SUPABASE_ANON_KEY is required"),
  NEXT_PUBLIC_APP_URL: z
    .string()
    .url()
    .optional()
    .default("http://localhost:3000"),
});
```

**Step 5: Create scripts/validate-env.ts (PROD-07)**

Create a standalone validation script that can be run before deployment. This is the "startup validation script" mentioned in the success criteria.

```typescript
#!/usr/bin/env npx tsx
/**
 * Production Environment Variable Validation
 *
 * Run before deploy: npx tsx scripts/validate-env.ts
 * Exits with code 1 if any required vars are missing.
 */

import { z } from "zod";

const productionEnvSchema = z.object({
  // Core (always required)
  NEXT_PUBLIC_SUPABASE_URL: z.string().url("Must be a valid URL"),
  NEXT_PUBLIC_SUPABASE_ANON_KEY: z.string().min(1),
  SUPABASE_SERVICE_ROLE_KEY: z.string().min(1),
  JWT_SECRET: z.string().min(32, "JWT_SECRET must be at least 32 characters"),

  // Stripe (required for billing)
  STRIPE_SECRET_KEY: z.string().startsWith("sk_"),
  STRIPE_WEBHOOK_SECRET: z.string().startsWith("whsec_"),
  NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY: z.string().startsWith("pk_"),
  NEXT_PUBLIC_STRIPE_FUNDRAISING_PRICE_ID: z.string().startsWith("price_"),
  NEXT_PUBLIC_STRIPE_VENTURE_STUDIO_PRICE_ID: z.string().startsWith("price_"),

  // Upstash (required for rate limiting)
  UPSTASH_REDIS_REST_URL: z.string().url("Must be a valid URL"),
  UPSTASH_REDIS_REST_TOKEN: z.string().min(1),

  // App URL (required for CORS, emails, webhooks)
  NEXT_PUBLIC_APP_URL: z.string().url("Must be a valid URL"),

  // AI (at least one required)
  OPENAI_API_KEY: z.string().optional(),
  ANTHROPIC_API_KEY: z.string().optional(),
  GOOGLE_API_KEY: z.string().optional(),
});

function validate() {
  console.log("Validating production environment variables...\n");

  const result = productionEnvSchema.safeParse(process.env);

  if (!result.success) {
    console.error("VALIDATION FAILED\n");
    for (const issue of result.error.issues) {
      console.error(`  ${issue.path.join(".")}: ${issue.message}`);
    }
    console.error(`\n${result.error.issues.length} issue(s) found.`);
    process.exit(1);
  }

  // Check AI provider (at least one needed)
  const hasAI = result.data.OPENAI_API_KEY || result.data.ANTHROPIC_API_KEY || result.data.GOOGLE_API_KEY;
  if (!hasAI) {
    console.error("VALIDATION FAILED\n");
    console.error("  At least one AI provider key is required (OPENAI_API_KEY, ANTHROPIC_API_KEY, or GOOGLE_API_KEY)");
    process.exit(1);
  }

  console.log("All required environment variables present.");

  // Report optional vars
  const optional = [
    "ADMIN_SECRET_KEY",
    "CRON_SECRET",
    "TWILIO_ACCOUNT_SID",
    "TWILIO_AUTH_TOKEN",
    "TWILIO_MESSAGING_SERVICE_SID",
    "LIVEKIT_API_KEY",
    "LIVEKIT_API_SECRET",
    "LIVEKIT_URL",
    "NEXT_PUBLIC_LIVEKIT_URL",
    "RESEND_API_KEY",
    "SLACK_WEBHOOK_URL",
  ];

  const missing = optional.filter((v) => !process.env[v]);
  if (missing.length > 0) {
    console.log(`\nOptional vars not set (features may be limited):`);
    for (const v of missing) {
      console.log(`  - ${v}`);
    }
  }

  console.log("\nValidation passed.");
}

validate();
```

Also add a convenience script to package.json:
```json
"validate-env": "tsx scripts/validate-env.ts"
```
  </action>
  <verify>
1. **Upstash packages installed:**
   ```bash
   grep '@upstash/ratelimit' package.json
   grep '@upstash/redis' package.json
   ```

2. **Rate limiter uses Upstash:**
   ```bash
   grep 'Ratelimit' lib/api/rate-limit.ts
   grep '@upstash' lib/api/rate-limit.ts
   # Should NOT have 'new Map' as primary store
   grep -c 'new Map' lib/api/rate-limit.ts
   # Should be 0 or only in fallback section
   ```

3. **All callers await rate limit checks:**
   ```bash
   grep -rn 'checkRateLimit\|checkRateLimitForUser' app/api/ --include="*.ts" | grep -v 'await\|import'
   # Should return nothing (all calls should be awaited)
   ```

4. **Env validation script runs:**
   ```bash
   # This will fail in dev (missing production vars) but should run and report
   npx tsx scripts/validate-env.ts 2>&1 | head -10
   ```

5. **Env schema expanded:**
   ```bash
   grep 'UPSTASH' lib/env.ts
   grep 'STRIPE' lib/env.ts
   ```

6. **Validate-env script in package.json:**
   ```bash
   grep 'validate-env' package.json
   ```

7. **TypeScript compilation:**
   ```bash
   npx tsc --noEmit 2>&1 | head -20
   ```
  </verify>
  <done>
PROD-05: Rate limiting rewritten to use @upstash/ratelimit + @upstash/redis. Module-scope Redis client and Ratelimit instances for connection reuse. Fallback to in-memory for dev environments. All 14 API route callers updated to await async rate limit checks. lib/rate-limit.ts deprecated.
PROD-07: lib/env.ts serverEnvSchema expanded with Stripe and Upstash vars. Standalone scripts/validate-env.ts created with comprehensive production validation (core, Stripe, Upstash, AI provider, app URL). Reports missing optional vars. Added "validate-env" convenience script to package.json.
  </done>
</task>

</tasks>

<verification>
After both tasks complete, verify the full production infrastructure:

1. **Auth middleware protects routes:**
   ```bash
   # middleware.ts exists at root
   test -f middleware.ts && echo "EXISTS" || echo "MISSING"
   # Protected routes include all required paths
   grep -c "dashboard\|settings\|agents\|chat" middleware.ts
   ```

2. **SEO files exist:**
   ```bash
   test -f app/robots.ts && echo "robots.ts EXISTS" || echo "MISSING"
   test -f app/sitemap.ts && echo "sitemap.ts EXISTS" || echo "MISSING"
   ```

3. **CORS utility exists:**
   ```bash
   test -f lib/api/cors.ts && echo "cors.ts EXISTS" || echo "MISSING"
   grep 'export function' lib/api/cors.ts
   ```

4. **Rate limiting uses Redis:**
   ```bash
   grep '@upstash/ratelimit' lib/api/rate-limit.ts
   ```

5. **Env validation script works:**
   ```bash
   npx tsx scripts/validate-env.ts 2>&1 | head -5
   ```

6. **Full TypeScript compilation:**
   ```bash
   npx tsc --noEmit
   ```
</verification>

<success_criteria>
- middleware.ts exists at project root, imports updateSession and isProtectedRoute, redirects unauthenticated users on /dashboard, /settings, /agents, /chat to /login
- app/robots.ts serves robots.txt with disallow rules for all private route prefixes
- app/sitemap.ts serves sitemap.xml listing 24 public pages with correct priorities
- lib/api/cors.ts provides corsHeaders(), withCorsHeaders(), and handleCorsOptions() with webhook path exclusions
- PROD-04 verified: no <img> tags in source files (all use next/image)
- lib/api/rate-limit.ts uses @upstash/ratelimit with Redis backend, falls back to in-memory for dev
- All 14 API route callers of checkRateLimit/checkRateLimitForUser updated with await
- lib/env.ts schema expanded with Stripe and Upstash variables
- scripts/validate-env.ts runs and reports all missing required vars with clear error messages
- package.json has "validate-env" script
- TypeScript compilation passes with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/12-data-fixes-production-hardening/12-02-SUMMARY.md`
</output>
