---
phase: 67-content-library-frontend
plan: 03
type: execute
wave: 3
depends_on: [67-01, 67-02]
files_modified:
  - components/chat/chat-message.tsx
  - components/content/course-card-inline.tsx
autonomous: true

must_haves:
  truths:
    - "CourseCardInline component exists showing course title, description, and link for FRED chat"
    - "chat-message.tsx renders course cards when message content contains structured course data from the content-recommender tool"
    - "FRED chat content chip suggestions updated to include content library"
    - "pnpm build passes with zero TypeScript errors"
  artifacts:
    - path: "components/content/course-card-inline.tsx"
      provides: "Compact course card for display inside FRED chat messages"
      contains: "CourseCardInline\|/dashboard/content"
    - path: "components/chat/chat-message.tsx"
      provides: "Renders course cards when FRED recommends content"
      contains: "CourseCardInline\|course"
---

<objective>
Wire FRED's content-recommender tool output into the chat UI. When FRED calls recommendContent and returns courses, display compact course cards in the chat message instead of raw JSON. Also run pnpm build to verify zero errors.

Purpose: The content-recommender tool is already wired to the real DB (Phase 66). But currently if FRED returns course recommendations, the frontend has no special rendering — it would just show the assistant text response. This plan adds inline course cards so founders can click directly from the chat to a course.

IMPORTANT CONSTRAINT: The current chat system (chat-message.tsx) renders messages as simple text/markdown — it does NOT process AI tool results directly. FRED's LLM uses the tool result to compose a text response, which appears as a normal assistant message. The approach here is to parse structured course data embedded in FRED's text response using a simple marker pattern, OR to add a separate `courses` field to the Message type that can be populated alongside the text content.

Looking at the existing chat infrastructure: the Message type in chat-message.tsx is:
```ts
interface Message {
  id: string;
  content: string;
  role: "user" | "assistant";
  timestamp: Date;
  isStreaming?: boolean;
}
```

And the FRED chat hook (lib/hooks/use-fred-chat.ts) builds messages from SSE events. The cleanest approach without major refactoring: extend Message with an optional `courses` field, and have the chat route/hook detect when a tool result includes courses and attach them to the next assistant message.

However, modifying the SSE protocol and hook is complex. A simpler MVP approach: the chat-message.tsx can parse a special markdown-like pattern from FRED's text. When FRED recommends content, it responds with text that includes course slugs in a structured way, and we parse those.

SIMPLEST CORRECT APPROACH: Extend Message type to include optional `courses` field. When FRED returns a message that contains structured course JSON in a code block tagged `:::courses`, extract it and render CourseCardInline components below the message text. This requires:
1. The FRED system prompt (or tool result handling) to include course data in a parseable format — but we can't force that without modifying the AI response.
2. OR: parse the tool result data from SSE events in use-fred-chat.ts.

ACTUAL PRAGMATIC APPROACH for this phase:
- Extend the Message interface with `courses?: Array<{id: string; title: string; description: string; slug: string; tier_required: string; stage?: string}>`
- In chat-message.tsx, after rendering message content, if message.courses exists, render CourseCardInline for each
- In use-fred-chat.ts, parse tool_result SSE events for the recommendContent tool and attach courses to the pending assistant message
- This is minimal, targeted, and doesn't break existing functionality

Output: Founders see course cards in FRED chat when content is recommended.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@components/chat/chat-message.tsx
@components/chat/chat-interface.tsx
@lib/hooks/use-fred-chat.ts
@lib/fred/tools/content-recommender.ts
</context>

<tasks>

<task id="1" type="auto">
  <name>Create CourseCardInline component</name>
  <action>
Create `components/content/course-card-inline.tsx`.

This is a compact course card designed for display inside FRED chat messages. It should be visually distinct from the full CourseCard on the catalog page — smaller, more inline.

```tsx
"use client";

import Link from "next/link";
import { Badge } from "@/components/ui/badge";
import { BookOpen, Lock } from "lucide-react";
import { cn } from "@/lib/utils";

export interface CourseCardInlineProps {
  id: string;
  title: string;
  description: string;
  slug: string;
  tier_required: string;
  stage?: string;
}

export function CourseCardInline({
  id,
  title,
  description,
  tier_required,
  stage,
}: CourseCardInlineProps) {
  const isGated = tier_required === "pro" || tier_required === "studio";

  return (
    <Link
      href={`/dashboard/content/${id}`}
      className={cn(
        "flex items-start gap-3 p-3 rounded-lg border",
        "bg-white/5 border-white/10 hover:bg-white/10",
        "dark:bg-gray-800/50 dark:border-gray-700",
        "transition-colors duration-150 no-underline block mt-2"
      )}
    >
      <div className="shrink-0 h-8 w-8 rounded-md bg-orange-500/20 flex items-center justify-center">
        <BookOpen className="h-4 w-4 text-orange-400" />
      </div>
      <div className="flex-1 min-w-0">
        <div className="flex items-center gap-2 flex-wrap">
          <span className="font-medium text-sm text-foreground">{title}</span>
          {isGated && (
            <span className="inline-flex items-center gap-1 text-xs text-muted-foreground">
              <Lock className="h-3 w-3" />
              {tier_required === "studio" ? "Studio" : "Pro"}
            </span>
          )}
          {stage && (
            <Badge variant="secondary" className="text-xs capitalize">
              {stage}
            </Badge>
          )}
        </div>
        <p className="text-xs text-muted-foreground mt-0.5 line-clamp-2">{description}</p>
      </div>
    </Link>
  );
}
```
  </action>
  <verify>
Run: `ls components/content/course-card-inline.tsx && grep -c "CourseCardInline\|/dashboard/content" components/content/course-card-inline.tsx`
Expected: file exists with at least 2 matches.
  </verify>
  <done>components/content/course-card-inline.tsx exists with CourseCardInline component that links to /dashboard/content/[id].</done>
</task>

<task id="2" type="auto">
  <name>Extend Message type and wire course cards into chat-message.tsx</name>
  <action>
Read the full current content of `components/chat/chat-message.tsx` first.

Extend the `Message` interface to include an optional courses field:
```tsx
export interface Message {
  id: string;
  content: string;
  role: "user" | "assistant";
  timestamp: Date;
  isStreaming?: boolean;
  /** Course recommendations from FRED's content-recommender tool */
  courses?: Array<{
    id: string;
    title: string;
    description: string;
    slug: string;
    tier_required: string;
    stage?: string;
  }>;
}
```

Then in the ChatMessage component's render, after the ReactMarkdown block (inside the message bubble), add:
```tsx
{/* Course recommendations from FRED content-recommender tool */}
{!isUser && message.courses && message.courses.length > 0 && (
  <div className="mt-3 space-y-1">
    <p className="text-xs text-muted-foreground font-medium">Recommended Courses:</p>
    {message.courses.map((course) => (
      <CourseCardInline
        key={course.id}
        id={course.id}
        title={course.title}
        description={course.description}
        slug={course.slug}
        tier_required={course.tier_required}
        stage={course.stage}
      />
    ))}
  </div>
)}
```

Add the import at the top:
```tsx
import { CourseCardInline } from "@/components/content/course-card-inline";
```

This is a non-breaking change — existing messages without `courses` field will render exactly as before.
  </action>
  <verify>
Run: `grep -n "courses\|CourseCardInline" components/chat/chat-message.tsx`
Expected: shows courses field in Message interface and CourseCardInline import/usage.
  </verify>
  <done>chat-message.tsx has courses field in Message interface and renders CourseCardInline components for FRED course recommendations.</done>
</task>

<task id="3" type="auto">
  <name>Parse tool results in use-fred-chat.ts to populate courses on messages</name>
  <action>
Read the full content of `lib/hooks/use-fred-chat.ts` first.

Find where SSE events are processed — look for where assistant messages are built from SSE `data` events. The hook processes events from `/api/fred/chat`.

Look for how the hook handles message building. In the current implementation, the hook likely has a pattern where it:
1. Receives SSE events (text tokens, tool calls, tool results)
2. Builds up an assistant message

Add parsing for `tool_result` SSE events from the `recommendContent` tool.

Find the section that handles incoming SSE data and add logic to detect tool results containing course data. The FRED chat route sends SSE events — look for where tool-related events are handled.

If the hook uses `useChat` from the AI SDK: the AI SDK `useChat` hook exposes `messages` which include tool invocations. In that case, look for how to access tool call results in the message objects.

If the hook uses a custom SSE implementation: look for `event.data` parsing and add:

```ts
// When a tool_result event with recommendContent arrives, extract courses
// and attach to the pending assistant message
if (event.type === 'tool_result' && event.toolName === 'recommendContent') {
  const result = JSON.parse(event.data);
  if (result.status === 'success' && result.courses?.length > 0) {
    // Attach courses to the pending/last assistant message
  }
}
```

IMPORTANT: Read the actual hook implementation first and adapt to its actual structure. If the hook uses the Vercel AI SDK `useChat` hook, the integration point is different than a custom SSE loop.

If the hook is complex to modify without risk of breaking chat (which is a critical feature), use a simpler approach: add a `parseCourses` utility that parses course data from the assistant message text content. FRED's response when recommending content will include course titles and IDs if the tool result is incorporated into the response. But this is unreliable.

SAFEST APPROACH if the hook is complex:
- Skip hooking into the SSE event stream for this MVP
- Instead, add page-level suggestion chips on the content catalog page that say "Ask FRED to recommend courses"
- Document this as a deferred integration in the Summary
- The CourseCardInline component is already built and ready for when the integration is wired

If you CAN safely add course extraction to the hook without risk, do it. If the hook is too complex/risky to modify (it's a critical path), add the page chips approach and document the deferral.

Document your decision in the Summary either way.
  </action>
  <verify>
Run: `grep -n "courses\|recommendContent\|tool_result" lib/hooks/use-fred-chat.ts | head -20`
Check if integration was added or if it was deferred with documentation.
  </verify>
  <done>Either (a) use-fred-chat.ts parses recommendContent tool results and attaches courses to assistant messages, OR (b) deferral is documented with reason and the CourseCardInline component is ready for future wiring.</done>
</task>

<task id="4" type="auto">
  <name>Add content-library suggestion chips to chat interface</name>
  <action>
Read `components/chat/chat-interface.tsx`.

In the `PAGE_CHIPS` record, add an entry for the content library page:
```tsx
"/dashboard/content": [
  "Recommend a course for my stage",
  "What should I learn about fundraising?",
  "Show me courses on product-market fit",
],
```

This provides quick-start prompts when founders open FRED chat from the content pages, triggering the content-recommender tool naturally.
  </action>
  <verify>
Run: `grep -n "dashboard/content\|Recommend a course" components/chat/chat-interface.tsx`
Expected: shows the new chip entries.
  </verify>
  <done>chat-interface.tsx has content library suggestion chips for /dashboard/content path.</done>
</task>

<task id="5" type="auto">
  <name>Run pnpm build to verify zero errors</name>
  <action>
Run the build to catch any TypeScript or compilation errors:

```bash
cd /opt/agency-workspace/sierra-fred-carey && pnpm build 2>&1 | tail -40
```

If there are TypeScript errors in the files created in this phase (67), fix them before committing.

Common issues to watch for:
- MuxPlayer TypeScript types might require `@types` or have a different default export
- The `courses` field extension on Message might conflict if Message is imported/extended elsewhere
- The `onTimeUpdate` handler in the video player page might have type issues

Fix any errors found. If a fix requires a deviation from the plan, apply Rule 1-3 as appropriate and document.

After fixing all errors, confirm `pnpm build` exits with code 0.
  </action>
  <verify>
Run: `cd /opt/agency-workspace/sierra-fred-carey && pnpm build 2>&1 | grep -E "error|Error|compiled|Route" | tail -20`
Expected: shows "Compiled successfully" or routes listed without TypeScript errors. No "error TS" lines.
  </verify>
  <done>pnpm build completes with zero TypeScript errors. All Phase 67 pages compile successfully.</done>
</task>

</tasks>

<verification>
1. `ls components/content/course-card-inline.tsx` — component exists
2. `grep "courses" components/chat/chat-message.tsx` — Message type extended
3. `grep "/dashboard/content" components/chat/chat-interface.tsx` — suggestion chips added
4. `pnpm build 2>&1 | grep -c "error TS"` — should output 0
5. All three content pages exist: catalog, detail, video player
</verification>

<success_criteria>
- CourseCardInline component renders course link cards in FRED chat
- Message type extended with optional courses field (non-breaking)
- Content library suggestion chips in chat for /dashboard/content path
- pnpm build passes with zero errors
- All Phase 67 deliverables complete
</success_criteria>

<output>
After completion, create `.planning/phases/67-content-library-frontend/67-03-SUMMARY.md` documenting what was built, decisions made (especially the tool result integration decision), and any deviations.

Then update `.planning/STATE.md` to reflect Phase 67 complete.
</output>
