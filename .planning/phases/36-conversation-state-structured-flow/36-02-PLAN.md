# Phase 36-02: Structured Flow Control & Step Advancement

**Phase:** 36 — Conversation State & Structured Flow
**Plan:** 02 of 2
**Wave:** 1 (depends on 36-01 for data flow)
**Status:** PENDING
**Depends on:** 36-01 (conversation state must be loaded and available in FredContext)
**Autonomous:** true
**Authority:** `.planning/OPERATING-BIBLE.md` (canonical reference for all behavior rules)

## Files Modified

- `lib/fred/actors/validate-input.ts` — Add step-relevance detection and drift detection
- `lib/fred/actors/decide.ts` — Enforce structured flow, gentle redirects, Next 3 Actions
- `lib/fred/actors/execute.ts` — Post-response state updates (evidence storage, step advancement, diagnostic tag updates)
- `lib/fred/actors/synthesize.ts` — Step-aware synthesis that factors in conversation state
- `lib/ai/prompts.ts` — Add `buildDriftRedirectBlock`, `buildFastTrackBlock` for prompt-layer injection
- `lib/db/conversation-state.ts` — Add `determineStepFastTrack`, `applyStepFastTrack` for experienced-founder auto-advance
- `lib/ai/frameworks/startup-process.ts` — Add `"assumed"` to `StepStatus` type
- `app/api/fred/chat/route.ts` — Wire fast-track check on fresh conversation states

## Goal

Implement the behavioral side of FRED's structured mentoring flow. This is what makes FRED lead conversations rather than passively respond:

1. **FRED drives conversations** (CHAT-01): Asks specific step-relevant questions and guides to next steps
2. **Reframe-before-prescribe** (CHAT-02): Identifies real underlying goal before answering literal question
3. **Critical-thinking default** (CHAT-03): Surfaces assumptions, bottlenecks, tests, or decision criteria in every substantive response
4. **Gentle redirect** (CHAT-04): When founder drifts off track, acknowledges what they said and steers back
5. **State tracking** (CHAT-05): Updates conversation state after each response — stores evidence, advances steps, updates diagnostic tags

Note: Reframe-before-prescribe and critical-thinking are primarily prompt-driven behaviors (Layer 1 from Phase 34-01). This plan ensures the pipeline ENFORCES them through structural checks, not just hopes the prompt does it.

## Architecture

```
User Message
  │
  ├─ chat route (pre-pipeline)
  │   ├─ [EXISTING] Load conversation state (Phase 36-01)
  │   ├─ [NEW] Fast-track check: if fresh state + experienced founder, auto-advance steps
  │   └─ [NEW] Drift redirect block: if drift detected, inject instruction into system prompt
  │
  ├─ validate-input.ts
  │   ├─ [EXISTING] Intent, entities, topic detection
  │   ├─ [NEW] Step-relevance scoring: is this message about the current step?
  │   └─ [NEW] Drift detection: is the founder asking about a downstream step?
  │
  ├─ synthesize.ts
  │   ├─ [EXISTING] 7-factor scoring, recommendation, alternatives
  │   └─ [NEW] Step-aware synthesis: factor in what's been established
  │
  ├─ prompt assembly (prompts.ts)
  │   ├─ [NEW] buildDriftRedirectBlock: prompt instruction for gentle redirect
  │   └─ [NEW] buildFastTrackBlock: prompt instruction for experienced-founder acknowledgment
  │
  ├─ decide.ts
  │   ├─ [EXISTING] Action determination (auto_execute, recommend, escalate, clarify)
  │   ├─ [NEW] Next 3 Actions enforcement: append to every substantive response
  │   └─ [NEW] Step question injection: when current step needs more data, add question
  │
  └─ execute.ts
      ├─ [EXISTING] Memory storage
      ├─ [NEW] Evidence extraction: detect and store step evidence from the conversation
      ├─ [NEW] Step advancement check: if current step requirements met, advance
      └─ [NEW] Diagnostic tag update: update silent tags based on conversation signals
```

## Tasks

### Task 1: Add step-relevance and drift detection to `validate-input.ts`

Add two new detection functions that analyze the user's message in the context of their conversation state:

```typescript
import type { ConversationStateContext } from "../types";
import { STARTUP_STEPS, STEP_ORDER, type StartupStep } from "@/lib/ai/frameworks/startup-process";

/**
 * Detect which startup step the user's message relates to.
 * Returns the detected step and confidence, or null if no step signal found.
 *
 * Uses two signal types:
 * - Exact phrases (multi-word): matched with includes() (e.g., "pain point", "go to market")
 * - Single keywords: matched with word-boundary regex to avoid false positives
 *   (e.g., "scale" should match "scale" and "scaling" but not "escalate")
 */
function detectStepRelevance(
  message: string,
  keywords: string[],
  currentStep: StartupStep
): { targetStep: StartupStep; confidence: number } | null {
  // Each signal is either a multi-word phrase (matched with includes)
  // or a regex pattern (matched with word boundaries)
  const stepSignals: Record<StartupStep, Array<string | RegExp>> = {
    problem: [/\bproblem\b/, "pain point", /\bissue\b/, /\bfrustrat\w*\b/, /\bbroken\b/, /\binefficient\b/, /\bstruggl\w*\b/],
    buyer: [/\bcustomer\b/, /\bbuyer\b/, /\buser\b/, /\baudience\b/, "target market", "who buys", /\bicp\b/, /\bpersona\b/],
    "founder-edge": [/\badvantage\b/, /\bedge\b/, /\bunfair\b/, /\bexperience\b/, /\bcredib\w*\b/, "why me", "founder-market"],
    solution: [/\bsolution\b/, /\bproduct\b/, /\bbuild\b/, /\bfeature\b/, /\bmvp\b/, /\bprototype\b/],
    validation: [/\bvalidat\w*\b/, /\btest\b/, /\bprov\w*\b/, "customer interview", "willing to pay", /\bdemand\b/],
    gtm: ["go to market", /\bdistribution\b/, /\bchannel\b/, /\bsales\b/, "reach customers", /\bacquir\w*\b/, /\bmarketing\b/],
    execution: [/\bexecut\w*\b/, /\bprioritiz\w*\b/, "this week", /\bcadence\b/, /\bsprint\b/, /\bownership\b/, /\bfocus\b/],
    pilot: [/\bpilot\b/, /\bbeta\b/, /\btrial\b/, "early customers", "first users", /\blaunch\b/],
    "scale-decision": [/\bscal\w*\b/, /\bfundrais\w*\b/, "double down", /\bpivot\b/, /\bgrowth\b/, /\bseries\b/],
  };

  let bestMatch: { targetStep: StartupStep; confidence: number } | null = null;
  const lowerMessage = message.toLowerCase();

  for (const [step, signals] of Object.entries(stepSignals) as [StartupStep, Array<string | RegExp>][]) {
    const matchCount = signals.filter((s) => {
      if (s instanceof RegExp) {
        return s.test(lowerMessage) || keywords.some((k) => s.test(k));
      }
      // Multi-word phrase: use includes
      return lowerMessage.includes(s) || keywords.some((k) => k.includes(s));
    }).length;

    if (matchCount > 0) {
      const confidence = Math.min(0.5 + matchCount * 0.15, 0.95);
      if (!bestMatch || confidence > bestMatch.confidence) {
        bestMatch = { targetStep: step, confidence };
      }
    }
  }

  return bestMatch;
}

/**
 * Detect if the founder is drifting to a downstream step before
 * the current step is validated.
 */
function detectDrift(
  stepRelevance: { targetStep: StartupStep; confidence: number } | null,
  conversationState: ConversationStateContext
): { isDrift: boolean; targetStep: StartupStep; currentStep: StartupStep } | null {
  if (!stepRelevance || stepRelevance.confidence < 0.6) return null;

  const currentIdx = STEP_ORDER.indexOf(conversationState.currentStep);
  const targetIdx = STEP_ORDER.indexOf(stepRelevance.targetStep);

  // Drift = asking about a step that's 2+ steps ahead AND current step is not validated
  if (
    targetIdx > currentIdx + 1 &&
    conversationState.stepStatuses[conversationState.currentStep] !== "validated"
  ) {
    return {
      isDrift: true,
      targetStep: stepRelevance.targetStep,
      currentStep: conversationState.currentStep,
    };
  }

  return null;
}
```

Add to the `ValidatedInput` return type in `types.ts`:

```typescript
export interface ValidatedInput {
  // ... existing fields ...
  stepRelevance?: { targetStep: StartupStep; confidence: number } | null;
  driftDetected?: { isDrift: boolean; targetStep: StartupStep; currentStep: StartupStep } | null;
}
```

Call these from `validateInputActor` when `conversationState` is available (passed via `memoryContext` or a new parameter):

```typescript
// In validateInputActor, after existing detection:
let stepRelevance = null;
let driftDetected = null;

// Access conversation state from the machine context if available
if (conversationStateContext) {
  stepRelevance = detectStepRelevance(
    sanitizedMessage,
    keywords,
    conversationStateContext.currentStep
  );
  driftDetected = detectDrift(stepRelevance, conversationStateContext);
}

return {
  // ... existing fields ...
  stepRelevance,
  driftDetected,
};
```

**Note:** The `validateInputActor` currently receives `(input, memoryContext)`. To pass conversation state, extend the actor signature to also accept `conversationState`:

```typescript
export async function validateInputActor(
  input: UserInput,
  memoryContext: MemoryContext | null,
  conversationState?: ConversationStateContext | null
): Promise<ValidatedInput>
```

Update the machine's `validateInput` actor invocation in `machine.ts`:

```typescript
validateInput: fromPromise<ValidatedInput, { input: UserInput; memoryContext: MemoryContext | null; conversationState: ConversationStateContext | null }>(
  async ({ input }) => validateInputActor(input.input, input.memoryContext, input.conversationState)
),

// In the intake state:
invoke: {
  src: "validateInput",
  input: ({ context }) => ({
    input: context.input!,
    memoryContext: context.memoryContext,
    conversationState: context.conversationState,  // NEW
  }),
```

### Task 2: Prompt-driven gentle redirect (CHAT-04)

Per the Operating Bible's layered architecture, redirect LANGUAGE belongs in the prompt layer, not hardcoded in `decide.ts`. The drift DETECTION stays structural (in `validate-input.ts` from Task 1), but the redirect INSTRUCTION is injected into the system prompt so the LLM generates contextually appropriate language.

**In `lib/ai/prompts.ts`**, add a prompt injection function:

```typescript
import { STARTUP_STEPS, type StartupStep } from "@/lib/ai/frameworks/startup-process";

/**
 * Build a prompt block instructing FRED to redirect the founder back to the current step.
 * Injected into the system prompt when drift is detected.
 * The LLM generates the actual redirect language — we provide the instruction and context.
 */
export function buildDriftRedirectBlock(
  currentStep: StartupStep,
  targetStep: StartupStep
): string {
  const currentStepName = STARTUP_STEPS[currentStep]?.name || currentStep;
  const targetStepName = STARTUP_STEPS[targetStep]?.name || targetStep;

  return `## REDIRECT INSTRUCTION (Active This Turn)

The founder is asking about "${targetStepName}" but has not yet validated "${currentStepName}".

Your response MUST:
1. Acknowledge what they asked about ("I hear you on ${targetStepName.toLowerCase()}...")
2. Explain why you need to finish the current step first — downstream work built on unvalidated assumptions fails
3. Redirect to a specific question or action for "${currentStepName}"
4. Be warm but firm — do not let the founder skip ahead

Do NOT ignore their question entirely. Briefly note it, then redirect.`;
}
```

**In `app/api/fred/chat/route.ts`** (or wherever the system prompt is assembled), inject this block when drift is detected:

```typescript
import { buildDriftRedirectBlock } from "@/lib/ai/prompts";

// After drift detection in the chat route:
let systemPromptSuffix = "";
if (stepGuidanceBlock) {
  systemPromptSuffix += "\n\n" + stepGuidanceBlock;
}
if (driftDetected?.isDrift) {
  systemPromptSuffix += "\n\n" + buildDriftRedirectBlock(
    driftDetected.currentStep,
    driftDetected.targetStep
  );
}
```

**In `decide.ts`**, remove the hardcoded `buildRedirectPrefix` function. Instead, the `decide.ts` code only needs to know drift was detected for metadata/logging:

```typescript
function buildResponseContent(
  action: DecisionAction,
  synthesis: SynthesisResult,
  input: ValidatedInput
): string {
  // NOTE: Redirect language is handled by the prompt layer (buildDriftRedirectBlock).
  // The LLM will naturally incorporate the redirect instruction into its response.
  // decide.ts does NOT prepend hardcoded redirect text.

  // ... existing switch on action (unchanged) ...

  // Append Next 3 Actions to every substantive response (CHAT-01)
  if (action !== "clarify" && action !== "defer") {
    content = appendNextActions(content, synthesis);
  }

  return content;
}
```

**Why prompt-driven?**
- The LLM generates more natural, context-aware redirects than a hardcoded template
- The redirect tone matches the rest of the response (consistent voice)
- The Operating Bible's layered architecture keeps behavioral language in the prompt, not code
- The redirect instruction can reference what the founder specifically asked about

**What stays structural?**
- Drift DETECTION in `validate-input.ts` (code decides IF there's drift)
- Next 3 Actions appending in `decide.ts` (structural enforcement)
- The DECISION to inject the redirect block (code decides WHEN to inject)
- Only the LANGUAGE is prompt-driven (LLM decides HOW to say it)

### Task 3: Enforce Next 3 Actions in `decide.ts`

Add the `appendNextActions` helper that ensures every substantive response ends with actionable next steps:

```typescript
/**
 * Append "Next 3 Actions" to every substantive response.
 * Operating Bible Section 3.3 Output Standard.
 */
function appendNextActions(content: string, synthesis: SynthesisResult): string {
  if (!synthesis.nextSteps || synthesis.nextSteps.length === 0) return content;

  const actions = synthesis.nextSteps.slice(0, 3);
  return `${content}\n\n## Next 3 Actions\n${actions.map((a, i) => `${i + 1}. ${a}`).join("\n")}`;
}
```

This is already called in the updated `buildResponseContent` from Task 2.

### Task 4: Add step question injection to `decide.ts`

When the founder's message doesn't clearly advance the current step, and the step still needs data, add a follow-up question:

```typescript
/**
 * When the current step needs more information, inject a step-relevant follow-up question.
 * This makes FRED "drive the conversation" (CHAT-01).
 */
function injectStepQuestion(
  content: string,
  conversationState: ConversationStateContext | null,
  input: ValidatedInput
): string {
  if (!conversationState) return content;

  const currentStep = conversationState.currentStep;
  const status = conversationState.stepStatuses[currentStep];

  // Only inject questions when step is in_progress (not validated or skipped)
  if (status !== "in_progress") return content;

  // Don't inject if the founder is already answering a step question
  if (input.stepRelevance?.targetStep === currentStep && input.stepRelevance.confidence > 0.7) {
    return content;
  }

  const step = STARTUP_STEPS[currentStep];
  if (!step || !step.questions.length) return content;

  // Pick the first unanswered question (we don't track which are answered yet,
  // so pick the first one — evidence tracking in Task 5 will improve this later)
  const question = step.questions[0];

  return `${content}\n\n---\n\nTo keep us moving forward on **${step.name}**: ${question}`;
}
```

Call this in `buildResponseContent` before the Next 3 Actions:

```typescript
// After redirect + main content, before Next 3 Actions:
if (action !== "clarify" && action !== "defer" && conversationState) {
  content = injectStepQuestion(content, conversationState, input);
}
```

**Note:** The `decideActor` function signature needs to accept `conversationState`:

```typescript
export async function decideActor(
  synthesis: SynthesisResult,
  validatedInput: ValidatedInput,
  founderContext?: string | null,
  conversationState?: ConversationStateContext | null  // NEW
): Promise<DecisionResult>
```

Update the machine's `decide` actor invocation:

```typescript
decide: fromPromise<DecisionResult, { synthesis: SynthesisResult; validatedInput: ValidatedInput; founderContext: string | null; conversationState: ConversationStateContext | null }>(
  async ({ input }) => decideActor(input.synthesis, input.validatedInput, input.founderContext, input.conversationState)
),

// In the decide state:
invoke: {
  src: "decide",
  input: ({ context }) => ({
    synthesis: context.synthesis!,
    validatedInput: context.validatedInput!,
    founderContext: context.founderContext,
    conversationState: context.conversationState,  // NEW
  }),
```

### Task 5: Add post-response state updates to `execute.ts`

After the response is generated and delivered, update the conversation state based on what happened in the conversation. This runs in `executeActor` as fire-and-forget side effects:

```typescript
import {
  updateStepStatus,
  advanceToStep,
  storeStepEvidence,
  updateDiagnosticTags,
  updateFounderSnapshot,
} from "@/lib/db/conversation-state";
import { STARTUP_STEPS, getNextStep, type StartupStep } from "@/lib/ai/frameworks/startup-process";

/**
 * Post-response conversation state updates.
 * Called at the end of executeActor, non-blocking.
 */
async function updateConversationState(
  userId: string,
  validatedInput: ValidatedInput,
  decision: DecisionResult,
  conversationState: ConversationStateContext | null
): Promise<void> {
  if (!conversationState) return;

  try {
    // 1. Store evidence from user statements
    if (validatedInput.stepRelevance?.targetStep === conversationState.currentStep) {
      await storeStepEvidence(
        userId,
        conversationState.currentStep,
        "user_statement",
        validatedInput.originalMessage.slice(0, 500),
        { source: "conversation", confidence: validatedInput.stepRelevance.confidence }
      );
    }

    // 2. Update diagnostic tags based on conversation signals
    const tagUpdates = extractDiagnosticSignals(validatedInput);
    if (Object.keys(tagUpdates).length > 0) {
      await updateDiagnosticTags(userId, tagUpdates);
    }

    // 3. Update founder snapshot from entities
    const snapshotUpdates = extractSnapshotUpdates(validatedInput);
    if (Object.keys(snapshotUpdates).length > 0) {
      await updateFounderSnapshot(userId, snapshotUpdates);
    }
  } catch (error) {
    // Non-blocking: state updates failing should not break the response
    console.warn("[FRED Execute] Failed to update conversation state:", error);
  }
}

/**
 * Extract diagnostic tags from the validated input.
 * Operating Bible Section 5.2: Silent diagnosis during early messages.
 */
function extractDiagnosticSignals(input: ValidatedInput): Record<string, string> {
  const tags: Record<string, string> = {};
  const msg = input.originalMessage.toLowerCase();

  // Positioning clarity signals
  if (/everyone|anybody|all\s+business/i.test(msg)) {
    tags.positioningClarity = "low";
  } else if (input.stepRelevance?.targetStep === "buyer" && input.stepRelevance.confidence > 0.7) {
    tags.positioningClarity = "med";
  }

  // Investor readiness signals
  if (/fundrais|investor|vc|valuation|series\s+[a-c]|term\s+sheet/i.test(msg)) {
    tags.investorReadinessSignal = "med";
  }

  // Stage detection
  if (/idea|concept|thinking about/i.test(msg)) {
    tags.stage = "idea";
  } else if (/mvp|prototype|building/i.test(msg)) {
    tags.stage = "pre-seed";
  } else if (/revenue|customers|paying/i.test(msg)) {
    tags.stage = "seed";
  } else if (/series|scale|expand|growing/i.test(msg)) {
    tags.stage = "growth";
  }

  return tags;
}

/**
 * Extract founder snapshot updates from entities.
 */
function extractSnapshotUpdates(input: ValidatedInput): Record<string, unknown> {
  const updates: Record<string, unknown> = {};

  // Extract traction from money entities
  const moneyEntities = input.entities.filter((e) => e.type === "money");
  if (moneyEntities.length > 0) {
    updates.traction = moneyEntities.map((e) => e.value).join(", ");
  }

  return updates;
}
```

Call this at the end of `executeActor`:

```typescript
export async function executeActor(
  decision: DecisionResult,
  validatedInput: ValidatedInput,
  userId: string,
  sessionId: string,
  conversationState?: ConversationStateContext | null  // NEW
): Promise<void> {
  // ... existing execute logic ...

  // Phase 36: Update conversation state (fire-and-forget)
  updateConversationState(userId, validatedInput, decision, conversationState || null)
    .catch((err) => console.warn("[FRED Execute] State update failed:", err));
}
```

Update the machine's `execute` actor invocation:

```typescript
execute: fromPromise<void, { decision: DecisionResult; validatedInput: ValidatedInput; userId: string; sessionId: string; conversationState: ConversationStateContext | null }>(
  async ({ input }) => {
    await executeActor(input.decision, input.validatedInput, input.userId, input.sessionId, input.conversationState);
  }
),

// In the execute state:
invoke: {
  src: "execute",
  input: ({ context }) => ({
    decision: context.decision!,
    validatedInput: context.validatedInput!,
    userId: context.userId,
    sessionId: context.sessionId,
    conversationState: context.conversationState,  // NEW
  }),
```

### Task 6: Step-aware synthesis in `synthesize.ts`

Enhance synthesis to factor in what has been established vs what needs validation:

```typescript
/**
 * Build step-aware context for synthesis.
 * This ensures FRED's recommendation considers what's been validated.
 */
function buildStepContext(conversationState: ConversationStateContext | null): string {
  if (!conversationState) return "";

  const current = conversationState.currentStep;
  const validated = Object.entries(conversationState.stepStatuses)
    .filter(([, s]) => s === "validated")
    .map(([k]) => k);
  const blockers = conversationState.currentBlockers;

  let ctx = `\nConversation Position: Step "${current}"`;
  if (validated.length > 0) {
    ctx += ` | Validated: ${validated.join(", ")}`;
  }
  if (blockers.length > 0) {
    ctx += ` | Blockers: ${blockers.join("; ")}`;
  }
  return ctx;
}
```

Pass conversation state through to `synthesizeActor`:

```typescript
export async function synthesizeActor(
  validatedInput: ValidatedInput,
  mentalModels: MentalModelResult[],
  memoryContext: MemoryContext | null,
  conversationState?: ConversationStateContext | null  // NEW
): Promise<SynthesisResult>
```

Inject the step context into the synthesis prompt/logic where the AI generates recommendations. Append `buildStepContext(conversationState)` to the context that the synthesis AI call uses.

Update the machine's `synthesize` actor invocation:

```typescript
synthesize: fromPromise<SynthesisResult, { validatedInput: ValidatedInput; mentalModels: MentalModelResult[]; memoryContext: MemoryContext | null; conversationState: ConversationStateContext | null }>(
  async ({ input }) => synthesizeActor(input.validatedInput, input.mentalModels, input.memoryContext, input.conversationState)
),

// In the synthesis state:
invoke: {
  src: "synthesize",
  input: ({ context }) => ({
    validatedInput: context.validatedInput!,
    mentalModels: context.mentalModels,
    memoryContext: context.memoryContext,
    conversationState: context.conversationState,  // NEW
  }),
```

### Task 7: Experienced-founder fast-track (auto-advance early steps)

**Problem:** A seed-stage founder with revenue who signs up gets placed at Step 1 (Define the Real Problem) by default. Every time they ask about GTM, scaling, or fundraising, they get redirected. There is no mechanism to auto-advance steps based on actual stage, traction, or profile data. Experienced founders feel patronized and churn.

**Solution:** Add a fast-track function that runs once on first conversation (when all steps are `not_started` except step 1) and uses the founder's profile data to auto-validate or mark early steps as `assumed`, advancing `currentStep` to match their actual position.

**How it works:**

1. Fast-track triggers ONLY when the conversation state is fresh (first message from this user, all steps at `not_started`/`in_progress`)
2. It reads the `founderSnapshot` from conversation state (populated by Phase 35's `syncSnapshotFromProfile`)
3. Based on profile signals, it marks early steps as `assumed` (not `validated` — they haven't been deeply explored, but there's enough evidence to not start from scratch)
4. It advances `currentStep` to the first step that ISN'T assumed
5. It injects a fast-track prompt instruction so FRED acknowledges what's established and starts at the right place

**In `lib/db/conversation-state.ts`**, add:

```typescript
import { STEP_ORDER, type StartupStep, type StepStatus } from "@/lib/ai/frameworks/startup-process";

interface FastTrackResult {
  /** Whether fast-track was applied */
  applied: boolean;
  /** Steps that were auto-assumed */
  assumedSteps: StartupStep[];
  /** The step FRED should start at */
  startStep: StartupStep;
  /** Summary of what was established (for prompt injection) */
  establishedSummary: string;
}

/**
 * Determine which steps can be fast-tracked based on founder profile data.
 *
 * This is a HEURISTIC, not a formal validation. Steps are marked "assumed",
 * meaning FRED won't force the founder through them but may quick-confirm
 * with a single question if relevant.
 *
 * Rules:
 * - stage=seed or growth + traction exists → assume steps 1-5 (problem through validation)
 * - stage=pre-seed + productStatus exists → assume steps 1-4 (problem through solution)
 * - stage=idea → no fast-track (start at step 1)
 * - revenue/traction signals → assume validation (step 5)
 * - primaryConstraint=distribution → assume up to step 5, start at gtm (step 6)
 * - Always conservative: if data is ambiguous, don't assume
 */
export function determineStepFastTrack(
  snapshot: FounderSnapshot,
  diagnosticTags: DiagnosticTags
): FastTrackResult {
  const stage = snapshot.stage || diagnosticTags.stage;
  const hasTraction = !!(snapshot.traction && snapshot.traction !== "none" && snapshot.traction !== "no");
  const hasProduct = !!(snapshot.productStatus && snapshot.productStatus !== "idea" && snapshot.productStatus !== "concept");
  const hasRevenue = snapshot.traction?.toLowerCase().includes("revenue") ||
    snapshot.traction?.toLowerCase().includes("paying") ||
    snapshot.traction?.toLowerCase().includes("arr");
  const constraint = snapshot.primaryConstraint || diagnosticTags.primaryConstraint;

  const assumedSteps: StartupStep[] = [];
  const established: string[] = [];

  // No fast-track for idea-stage or unknown stage
  if (!stage || stage === "idea") {
    return { applied: false, assumedSteps: [], startStep: "problem", establishedSummary: "" };
  }

  // Pre-seed with product: assume problem + buyer + founder-edge + solution
  if (stage === "pre-seed" && hasProduct) {
    assumedSteps.push("problem", "buyer", "founder-edge", "solution");
    established.push("problem defined", "buyer identified", "founder edge established", "solution defined");
    if (hasTraction) {
      assumedSteps.push("validation");
      established.push("early validation signals present");
    }
  }

  // Seed or growth: assume steps 1-5 (problem through validation)
  if (stage === "seed" || stage === "growth") {
    const seedSteps: StartupStep[] = ["problem", "buyer", "founder-edge", "solution", "validation"];
    for (const s of seedSteps) {
      if (!assumedSteps.includes(s)) assumedSteps.push(s);
    }
    established.push("problem defined", "buyer identified", "founder edge established", "solution defined", "validation evidence exists");

    // If they have revenue, also assume GTM
    if (hasRevenue) {
      assumedSteps.push("gtm");
      established.push("initial go-to-market motion working");
    }

    // Growth stage: assume execution too
    if (stage === "growth") {
      if (!assumedSteps.includes("gtm")) assumedSteps.push("gtm");
      assumedSteps.push("execution");
      established.push("execution cadence installed");
    }
  }

  // Determine start step: first step NOT in assumedSteps
  let startStep: StartupStep = "problem";
  for (const step of STEP_ORDER) {
    if (!assumedSteps.includes(step)) {
      startStep = step;
      break;
    }
  }

  // If everything was assumed, start at scale-decision
  if (assumedSteps.length === STEP_ORDER.length) {
    startStep = "scale-decision";
  }

  return {
    applied: assumedSteps.length > 0,
    assumedSteps,
    startStep,
    establishedSummary: established.length > 0
      ? `Based on your profile: ${established.join(", ")}. Starting at Step ${STARTUP_STEPS[startStep]?.stepNumber}: ${STARTUP_STEPS[startStep]?.name}.`
      : "",
  };
}

/**
 * Apply fast-track to a fresh conversation state.
 * Marks assumed steps, advances currentStep, stores reasoning.
 */
export async function applyStepFastTrack(
  userId: string,
  conversationState: ConversationState
): Promise<{ state: ConversationState; fastTrack: FastTrackResult }> {
  const fastTrack = determineStepFastTrack(
    conversationState.founderSnapshot,
    conversationState.diagnosticTags
  );

  if (!fastTrack.applied) {
    return { state: conversationState, fastTrack };
  }

  // Update step statuses: mark assumed steps
  const newStatuses = { ...conversationState.stepStatuses };
  for (const step of fastTrack.assumedSteps) {
    newStatuses[step] = "assumed" as StepStatus;
  }
  // Mark the start step as in_progress
  newStatuses[fastTrack.startStep] = "in_progress";

  const supabase = createServiceClient();
  const { data, error } = await supabase
    .from("fred_conversation_state")
    .update({
      current_step: fastTrack.startStep,
      step_statuses: newStatuses,
      updated_at: new Date().toISOString(),
    })
    .eq("user_id", userId)
    .select()
    .single();

  if (error) {
    console.warn("[ConvState] Fast-track update failed:", error);
    return { state: conversationState, fastTrack };
  }

  return { state: transformStateRow(data), fastTrack };
}
```

**In `app/api/fred/chat/route.ts`**, add fast-track check after loading conversation state:

```typescript
import { applyStepFastTrack, type FastTrackResult } from "@/lib/db/conversation-state";

// After loading conversation state (Phase 36 block):
let fastTrackResult: FastTrackResult | null = null;
if (conversationState) {
  // Fast-track only on fresh states (all steps not_started except step 1)
  const isFreshState = Object.entries(conversationState.stepStatuses)
    .filter(([step]) => step !== "problem")
    .every(([, status]) => status === "not_started");

  if (isFreshState && conversationState.currentStep === "problem") {
    try {
      const result = await applyStepFastTrack(userId, conversationState);
      conversationState = result.state;
      fastTrackResult = result.fastTrack;
    } catch (err) {
      console.warn("[FRED Chat] Fast-track failed (non-blocking):", err);
    }
  }
}
```

**In `lib/ai/prompts.ts`**, add a fast-track prompt block:

```typescript
/**
 * Build a prompt block for experienced-founder fast-track.
 * Instructs FRED to acknowledge what's established and start at the right step.
 */
export function buildFastTrackBlock(
  establishedSummary: string,
  startStep: StartupStep,
  assumedSteps: StartupStep[]
): string {
  const stepName = STARTUP_STEPS[startStep]?.name || startStep;

  return `## EXPERIENCED FOUNDER FAST-TRACK (Active This Conversation)

This founder has established context from their profile. Do NOT force them through early steps they've already completed.

**What's established (assumed from profile):**
${establishedSummary}

**Your approach:**
1. Acknowledge what they've already built/proven: "I can see you've already [established context]. Let's pick up where it matters most."
2. Start your guidance at **Step ${STARTUP_STEPS[startStep]?.stepNumber}: ${stepName}**
3. For assumed steps (${assumedSteps.join(", ")}): only revisit if the founder's statements reveal gaps. Use a quick-confirm, not a deep dive: "You mentioned [X] as your buyer — is that still accurate, or has it shifted?"
4. Do NOT ask basic intake questions (what are you building, who is it for) if that data already exists in the founder context above
5. If you discover an assumed step actually has gaps, flag it directly: "I assumed your [step] was solid, but [specific gap]. Worth a quick look before we move on."`;
}
```

Inject this in the chat route when fast-track is applied:

```typescript
// After fast-track check:
let fastTrackBlock = "";
if (fastTrackResult?.applied) {
  fastTrackBlock = buildFastTrackBlock(
    fastTrackResult.establishedSummary,
    fastTrackResult.startStep,
    fastTrackResult.assumedSteps
  );
}

// Include in full context assembly:
const fullContext = [founderContext, stepGuidanceBlock, fastTrackBlock]
  .filter(Boolean)
  .join("\n\n");
```

**Adding "assumed" as a valid StepStatus:**

The `StepStatus` type in `startup-process.ts` currently allows: `"not_started" | "in_progress" | "validated" | "blocked" | "skipped"`. Add `"assumed"`:

```typescript
export type StepStatus = "not_started" | "in_progress" | "validated" | "blocked" | "skipped" | "assumed";
```

The `"assumed"` status means:
- The step has evidence from the profile, but hasn't been formally validated through conversation
- FRED won't force the founder through it, but may quick-confirm with one question
- It's displayed differently from `"validated"` in progress context (shows "assumed" not "validated")
- If FRED discovers gaps in an assumed step, it can be demoted back to `"in_progress"`

**Why this is critical for retention:**
- A seed-stage founder with 50 paying customers should NOT be asked "Who specifically experiences this problem?" on their first message
- An experienced founder who feels patronized by Step 1 questions will leave
- The fast-track respects what they've already done while keeping the gate process intact for actual gaps

**Why it's safe:**
- Fast-track only runs on FIRST conversation (fresh state)
- Steps are marked `"assumed"`, not `"validated"` — FRED can revisit if gaps emerge
- The prompt explicitly instructs FRED to flag discovered gaps
- Conservative heuristics: idea-stage gets no fast-track, ambiguous data gets no fast-track

## Verification

- [ ] `validateInputActor` detects which step the user's message relates to
- [ ] Drift detection fires when founder asks about a step 2+ ahead of current
- [ ] Drift detection does NOT fire for adjacent steps (step N → step N+1 is natural progression)
- [ ] `buildDriftRedirectBlock` in `prompts.ts` generates redirect instruction for the system prompt
- [ ] Redirect LANGUAGE is prompt-driven (LLM generates it), not hardcoded in `decide.ts`
- [ ] Redirect DETECTION remains structural in `validate-input.ts`
- [ ] Drift redirect block injected into system prompt in the chat route when drift is detected
- [ ] Next 3 Actions appended to every response except "clarify" and "defer"
- [ ] Step question injection adds a follow-up question when the current step needs data
- [ ] Step question injection does NOT fire when the founder is already addressing the current step
- [ ] Post-response evidence storage captures user statements about the current step
- [ ] Diagnostic tags update from conversation signals (positioning clarity, investor readiness, stage)
- [ ] Founder snapshot updates from entity extraction (money → traction)
- [ ] State updates are fire-and-forget — failures do not break the response
- [ ] `synthesizeActor` factors in conversation position (current step, validated steps, blockers)
- [ ] Machine actor invocations pass `conversationState` through to all actors
- [ ] `decideActor` signature accepts `conversationState` parameter
- [ ] `executeActor` signature accepts `conversationState` parameter
- [ ] `validateInputActor` signature accepts `conversationState` parameter
- [ ] `synthesizeActor` signature accepts `conversationState` parameter
- [ ] All actor changes are backward-compatible (new params are optional)
- [ ] Fast-track runs only on fresh conversation states (first message)
- [ ] Fast-track marks steps as `"assumed"`, not `"validated"`
- [ ] `StepStatus` type includes `"assumed"`
- [ ] Seed-stage founder with traction starts at step 6 (GTM), not step 1
- [ ] Growth-stage founder starts at step 8 (pilot) or step 9 (scale-decision)
- [ ] Idea-stage founder gets no fast-track (starts at step 1)
- [ ] Fast-track prompt instructs FRED to quick-confirm assumed steps, not skip them entirely
- [ ] Fast-track prompt instructs FRED to flag gaps discovered in assumed steps
- [ ] Fast-track failure is non-blocking — defaults to step 1 if anything goes wrong
- [ ] `npx tsc --noEmit` passes
- [ ] Existing chat API contract is preserved
- [ ] Existing tests pass

## Must-Haves

1. Gentle redirect is prompt-driven (language in `buildDriftRedirectBlock`, not hardcoded in `decide.ts`) — the instruction tells the LLM to acknowledge what the founder asked, then redirect. Drift DETECTION stays structural in `validate-input.ts`
2. Step question injection must feel natural — it's a follow-up from a mentor, not a quiz. "To keep us moving forward on X: ..."
3. All state updates are fire-and-forget — they must NEVER block the response or cause errors to surface to the user
4. Drift detection has a threshold (2+ steps ahead) — asking about the next step is natural progression, not drift
5. Next 3 Actions enforcement is structural (in `decide.ts`), not just prompt-based — it runs even if the prompt doesn't produce them. This is intentionally different from redirects (which ARE prompt-driven) because Next 3 Actions has a fixed format while redirects need contextual language
6. Evidence storage is conservative — only store when step relevance confidence > 0.6
7. All actor signature changes are backward-compatible — new parameters are optional with defaults
8. No new database tables or migrations — uses existing `fred_conversation_state` and `fred_step_evidence` tables
9. **Experienced-founder fast-track** runs only on fresh states (first message). Steps are marked `"assumed"` (not `"validated"`). FRED quick-confirms assumed steps rather than forcing full deep-dives. Conservative heuristics: idea-stage gets no fast-track. Fast-track failure falls back silently to step 1
10. **`"assumed"` is a distinct status from `"validated"`** — assumed steps can be demoted to `"in_progress"` if FRED discovers gaps. The prompt explicitly instructs FRED to flag gaps in assumed steps
