# Phase 36-01: Wire Conversation State into Chat Pipeline

**Phase:** 36 — Conversation State & Structured Flow
**Plan:** 01 of 2
**Wave:** 1 (foundation for 36-02)
**Status:** PENDING
**Depends on:** Phase 34 (layered prompt system + buildMentorSystemPrompt must exist)
**Autonomous:** true
**Authority:** `.planning/OPERATING-BIBLE.md` (canonical reference for all behavior rules)

## Files Modified

- `app/api/fred/chat/route.ts` — Load conversation state, inject progress context into prompt assembly
- `lib/fred/service.ts` — Accept `conversationState` in FredServiceOptions, pass to machine
- `lib/fred/machine.ts` — Add `conversationState` to FredContext, pass through to actors
- `lib/fred/types.ts` — Add ConversationStateContext type to FredContext
- `lib/fred/context-builder.ts` — Extend buildFounderContext to include step progress data
- `lib/ai/prompts.ts` — Add `buildProgressContextBlock` to format step progress for prompt injection

## Goal

Wire the conversation state tracking (fred_conversation_state table + DAL from Phase 34-04) into the chat pipeline so that every FRED response knows:
- Where the founder is in the 9-Step Startup Process
- What has been established (validated steps) vs what needs validation
- What evidence has been collected at the current step
- What blockers exist on the current step
- The founder's diagnostic tags (positioning clarity, investor readiness signal, etc.)

This is the DATA FLOW plan — it loads and injects state. Plan 36-02 handles the BEHAVIORAL changes (structured flow, redirects, step advancement).

## Architecture

```
Chat Route (POST /api/fred/chat)
  │
  ├─ [EXISTING] Auth, rate limit, tier check
  ├─ [EXISTING] buildFounderContext (profile + semantic facts)
  │
  ├─ [NEW] Load conversation state via getOrCreateConversationState(userId)
  ├─ [NEW] Load step progress via buildProgressContext(userId)
  ├─ [NEW] Inject progress context into buildMentorSystemPrompt options
  │
  ├─ [MODIFIED] createFredService({ ..., conversationState })
  │     └─ machine context includes conversationState
  │           └─ actors can read current step, blockers, evidence
  │
  └─ [EXISTING] Process message, stream response, store memory
```

## Tasks

### Task 1: Add `ConversationStateContext` to FredContext in `lib/fred/types.ts`

Add a lightweight type that carries conversation state through the machine:

```typescript
import type { StartupStep, StepStatus } from "@/lib/ai/frameworks/startup-process";

/** Conversation state passed through the XState machine */
export interface ConversationStateContext {
  currentStep: StartupStep;
  stepStatuses: Record<StartupStep, StepStatus>;
  processStatus: string;
  currentBlockers: string[];
  diagnosticTags: Record<string, string>;
  founderSnapshot: Record<string, unknown>;
  /** Pre-built progress context string for prompt injection */
  progressContext: string;
}
```

Add to `FredContext`:
```typescript
export interface FredContext {
  // ... existing fields ...
  conversationState: ConversationStateContext | null;
}
```

### Task 2: Extend `buildFounderContext` in `lib/fred/context-builder.ts`

Extend the existing `buildFounderContext` function to also load and include step progress data. The function already loads profile + semantic facts — add conversation state alongside:

```typescript
export async function buildFounderContext(
  userId: string,
  hasPersistentMemory: boolean
): Promise<string> {
  try {
    const [profile, facts, progressContext] = await Promise.all([
      loadFounderProfile(userId),
      loadSemanticFacts(userId, hasPersistentMemory),
      loadProgressContext(userId),   // NEW
    ]);

    let context = buildContextBlock({ profile, facts });

    // Append step progress if available
    if (progressContext) {
      context += "\n\n" + progressContext;
    }

    return context;
  } catch (error) {
    console.warn("[FRED Context] Failed to build founder context (non-blocking):", error);
    return "";
  }
}
```

Add the `loadProgressContext` helper that wraps the DAL:

```typescript
async function loadProgressContext(userId: string): Promise<string | null> {
  try {
    const { buildProgressContext } = await import("@/lib/db/conversation-state");
    const context = await buildProgressContext(userId);
    return context || null;
  } catch {
    return null;
  }
}
```

This uses the existing `buildProgressContext` from `lib/db/conversation-state.ts` which already formats:
- Founder snapshot
- Diagnostic tags
- Current step with `<-- CURRENT` marker
- Step statuses with evidence (outputs, facts, kill signals)
- Current blockers

### Task 3: Add `buildStepGuidanceBlock` to `lib/ai/prompts.ts`

Create a function that generates step-specific guidance for the system prompt. This tells FRED what to focus on at the current step:

```typescript
import { STARTUP_STEPS, type StartupStep } from "@/lib/ai/frameworks/startup-process";

export function buildStepGuidanceBlock(
  currentStep: StartupStep,
  stepStatuses: Record<StartupStep, string>,
  blockers: string[]
): string {
  const step = STARTUP_STEPS[currentStep];
  if (!step) return "";

  const lines: string[] = [];
  lines.push(`## CURRENT PROCESS POSITION`);
  lines.push("");
  lines.push(`You are guiding this founder through **Step ${step.stepNumber}: ${step.name}**`);
  lines.push("");
  lines.push(`**Objective:** ${step.objective}`);
  lines.push("");

  // Key questions to ask
  lines.push("**Your priority questions for this step:**");
  for (const q of step.questions) {
    lines.push(`- ${q}`);
  }
  lines.push("");

  // What the founder needs to produce
  lines.push(`**Required output before advancing:** ${step.requiredOutput}`);
  lines.push("");

  // Do not advance conditions
  lines.push("**Do NOT advance to the next step if:**");
  for (const d of step.doNotAdvanceIf) {
    lines.push(`- ${d}`);
  }

  // Current blockers
  if (blockers.length > 0) {
    lines.push("");
    lines.push("**Active blockers on this step:**");
    for (const b of blockers) {
      lines.push(`- ${b}`);
    }
    lines.push("Address these before moving forward.");
  }

  // Validated steps summary
  const validatedSteps = Object.entries(stepStatuses)
    .filter(([, status]) => status === "validated")
    .map(([step]) => step);
  if (validatedSteps.length > 0) {
    lines.push("");
    lines.push(`**Steps already validated:** ${validatedSteps.join(", ")}`);
    lines.push("Do not re-ask questions that have been answered in validated steps.");
  }

  return lines.join("\n");
}
```

### Task 4: Wire conversation state loading into `app/api/fred/chat/route.ts`

In the `handlePost` function, after the existing `buildFounderContext` call, load the conversation state and inject the step guidance into the prompt assembly:

```typescript
import { getOrCreateConversationState } from "@/lib/db/conversation-state";
import { buildStepGuidanceBlock } from "@/lib/ai/prompts";

// ... in handlePost, after founderContext is built ...

// Phase 36: Load conversation state for structured flow
let conversationState: ConversationState | null = null;
let stepGuidanceBlock = "";
try {
  conversationState = await getOrCreateConversationState(userId);
  stepGuidanceBlock = buildStepGuidanceBlock(
    conversationState.currentStep,
    conversationState.stepStatuses,
    conversationState.currentBlockers
  );
} catch (error) {
  console.warn("[FRED Chat] Failed to load conversation state (non-blocking):", error);
}
```

This step guidance block gets appended to the system prompt. If `buildMentorSystemPrompt` from Phase 34 is available, pass it as an additional option. If not yet wired, append it directly:

```typescript
// Append step guidance to the system prompt if available
let systemPromptSuffix = "";
if (stepGuidanceBlock) {
  systemPromptSuffix = "\n\n" + stepGuidanceBlock;
}
```

### Task 5: Pass conversation state to FredService and machine

Update `FredServiceOptions` in `lib/fred/service.ts`:

```typescript
export interface FredServiceOptions {
  userId: string;
  sessionId: string;
  enableObservability?: boolean;
  founderContext?: string;
  conversationState?: ConversationStateContext | null;  // NEW
  onStateChange?: (state: string, context: FredContext) => void;
  onError?: (error: Error) => void;
}
```

Pass through to the XState machine input in `createFredService`:

```typescript
const actor = createActor(fredMachine, {
  input: {
    userId: options.userId,
    sessionId: options.sessionId,
    founderContext: options.founderContext,
    conversationState: options.conversationState || null,  // NEW
  },
});
```

Update `machine.ts` — add `conversationState` to the machine input type and store in context:

```typescript
// In createInitialContext:
function createInitialContext(
  userId: string,
  sessionId: string,
  founderContext?: string,
  conversationState?: ConversationStateContext | null
): FredContext {
  return {
    // ... existing fields ...
    conversationState: conversationState || null,
  };
}

// In machine setup types:
input: {} as {
  userId: string;
  sessionId: string;
  config?: Partial<FredConfig>;
  founderContext?: string;
  conversationState?: ConversationStateContext | null;  // NEW
},

// In context initializer:
context: ({ input }) => createInitialContext(
  input.userId,
  input.sessionId,
  input.founderContext,
  input.conversationState  // NEW
),
```

### Task 6: Build ConversationStateContext in the chat route and pass to service

In `handlePost`, build the lightweight context object and pass it:

```typescript
// Build conversation state context for the machine
const stateContext: ConversationStateContext | null = conversationState
  ? {
      currentStep: conversationState.currentStep,
      stepStatuses: conversationState.stepStatuses,
      processStatus: conversationState.processStatus,
      currentBlockers: conversationState.currentBlockers,
      diagnosticTags: conversationState.diagnosticTags as Record<string, string>,
      founderSnapshot: conversationState.founderSnapshot as Record<string, unknown>,
      progressContext: stepGuidanceBlock,
    }
  : null;

// Create FRED service with conversation state
const fredService = createFredService({
  userId,
  sessionId: effectiveSessionId,
  enableObservability: true,
  founderContext,
  conversationState: stateContext,  // NEW
});
```

## Verification

- [ ] `ConversationStateContext` type is exported from `lib/fred/types.ts`
- [ ] `FredContext` includes `conversationState: ConversationStateContext | null`
- [ ] `buildFounderContext` loads step progress in parallel with profile and facts
- [ ] `buildStepGuidanceBlock` produces formatted step guidance with questions, required output, do-not-advance conditions
- [ ] `buildStepGuidanceBlock` only includes data for the current step
- [ ] `buildStepGuidanceBlock` lists validated steps so FRED doesn't re-ask
- [ ] Chat route loads conversation state via `getOrCreateConversationState`
- [ ] Chat route gracefully falls back to no state if loading fails
- [ ] `FredServiceOptions` accepts optional `conversationState`
- [ ] Machine input includes `conversationState`
- [ ] `FredContext` receives `conversationState` in `createInitialContext`
- [ ] Conversation state is accessible to all actors via `context.conversationState`
- [ ] Step guidance block appended to system prompt
- [ ] New founder (no conversation state row) gets a fresh state created automatically
- [ ] `npx tsc --noEmit` passes
- [ ] Existing chat API contract is preserved (same request/response schema)
- [ ] Existing tests pass (no breaking changes)

## Must-Haves

1. Chat route request/response schema is unchanged — purely a backend enrichment
2. Conversation state loading must NOT block the critical path if it fails — graceful fallback
3. Step guidance block must be concise — target <300 tokens to avoid eating context window
4. All new state is loaded in parallel with existing loads (profile, facts) — no serial waterfalls
5. No new database tables or migrations required — uses existing `fred_conversation_state` table (migration 049)
6. `buildProgressContext` from DAL is reused, not duplicated
7. Backward-compatible — if conversation state table doesn't exist yet (migration not run), chat still works
