# Plan 11-06: Service Role Key Scoping & Error Sanitization

**Phase:** 11 - Security Hardening
**Priority:** P2 (Medium - defense in depth)
**Estimated Scope:** 6-8 files modified

---

## Objective

Reduce the blast radius of the Supabase service role key by replacing it with user-scoped clients where possible, and sanitize error messages to prevent implementation detail leakage.

---

## Tasks

### Task 1: Audit Service Role Usage

**Action:** Review all files using `createServiceClient()` and categorize:

**Legitimate (keep service role):**
- Webhook handlers (no user context available)
- Cron jobs (server-only, no request context)
- Admin routes (already behind admin auth)
- Background document processing

**Can switch to user-scoped client:**
- `lib/db/boardy.ts` — user-initiated requests, has auth context
- `lib/db/sms.ts` — user-initiated requests, has auth context
- `lib/fred/irs/db.ts` — user-initiated, can use request-scoped client
- `lib/fred/strategy/db.ts` — user-initiated, can use request-scoped client
- `lib/fred/pitch/db.ts` — user-initiated, can use request-scoped client

### Task 2: Create User-Scoped DB Helper

**File:** `lib/db/user-client.ts` (or add to existing supabase helpers)
**Action:** Create helper that creates a Supabase client scoped to the authenticated user:

```typescript
import { createServerClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export function createUserClient() {
  const cookieStore = cookies();
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll: () => cookieStore.getAll(),
        setAll: (cookies) => cookies.forEach(({ name, value, options }) => cookieStore.set(name, value, options)),
      },
    }
  );
}
```

### Task 3: Migrate DB Modules to User-Scoped Client

**Files:** `lib/db/boardy.ts`, `lib/db/sms.ts`, `lib/fred/irs/db.ts`, `lib/fred/strategy/db.ts`, `lib/fred/pitch/db.ts`
**Action:** Accept client as parameter (dependency injection) instead of creating service client internally.

**Before:**
```typescript
export async function getMatches(userId: string) {
  const supabase = createServiceClient(); // bypasses RLS
  return supabase.from('boardy_matches').select('*').eq('user_id', userId);
}
```

**After:**
```typescript
export async function getMatches(supabase: SupabaseClient, userId: string) {
  return supabase.from('boardy_matches').select('*').eq('user_id', userId);
}
```

**Note:** This requires RLS policies on the affected tables. If RLS is not yet configured, add basic policies:
```sql
ALTER TABLE boardy_matches ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can read own matches" ON boardy_matches FOR SELECT USING (auth.uid() = user_id);
```

### Task 4: Sanitize Error Messages in API Responses

**Files:** All API routes that return `error.message` to client
**Action:** Replace detailed error messages with generic ones, log details server-side.

**Before:**
```typescript
return NextResponse.json({ error: error.message }, { status: 500 });
```

**After:**
```typescript
console.error('[RouteName] Error:', error);
return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
```

**Target routes (identified in audit):**
- `app/api/monitoring/alerts/check/route.ts`
- `app/api/monitoring/auto-promotion/check/route.ts`
- `app/api/admin/ab-tests/[id]/promote/route.ts`
- Any other routes returning raw `error.message`

---

## Verification

- [ ] DB modules accept client parameter (not creating service client internally)
- [ ] API routes called from user context use user-scoped client
- [ ] Webhook/cron/admin routes still use service client (legitimate)
- [ ] No API response contains stack traces or database column names
- [ ] All error details logged server-side (not lost)
- [ ] `npx tsc --noEmit` passes
- [ ] `npx vitest run` passes

---

## Dependencies

None - can execute independently. RLS policies may need Supabase dashboard access.

---

*Plan created: 2026-02-06*
