---
phase: 60-cicd-testing-expansion
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - playwright.config.ts
  - tests/e2e/visual-regression.spec.ts
  - tests/e2e/visual-regression-authenticated.spec.ts
  - .github/workflows/deploy.yml
autonomous: false

must_haves:
  truths:
    - "Visual regression baselines exist for key pages and detect unintended UI changes"
    - "Playwright toHaveScreenshot captures baseline screenshots that are committed to the repo"
    - "Staging environment exists for pre-production testing on the staging branch"
    - "Pushing to staging branch triggers a Vercel preview deployment"
  artifacts:
    - path: "tests/e2e/visual-regression.spec.ts"
      provides: "Visual regression tests for public pages"
      contains: "toHaveScreenshot"
    - path: "tests/e2e/visual-regression-authenticated.spec.ts"
      provides: "Visual regression tests for authenticated pages"
      contains: "toHaveScreenshot"
  key_links:
    - from: "tests/e2e/visual-regression.spec.ts"
      to: "playwright.config.ts"
      via: "snapshotDir and toHaveScreenshot config"
      pattern: "toHaveScreenshot"
    - from: ".github/workflows/deploy.yml"
      to: "staging branch"
      via: "deploy job triggers on staging push"
      pattern: "refs/heads/staging"
---

<objective>
Create visual regression test suites that capture baseline screenshots of key pages, and verify the staging environment is properly configured for pre-production testing.

Purpose: Visual regression testing catches unintended UI changes (layout shifts, broken styles, missing elements) that unit tests and a11y tests miss. The staging environment provides a safe deployment target for testing before production.

Output: Visual regression test files with toHaveScreenshot baselines + staging environment verification.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Existing files:
@playwright.config.ts
@.github/workflows/deploy.yml
@vercel.json
@tests/e2e/fixtures/auth.ts (auth fixture pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create visual regression test suites and generate baselines</name>
  <files>
    tests/e2e/visual-regression.spec.ts
    tests/e2e/visual-regression-authenticated.spec.ts
    playwright.config.ts
  </files>
  <action>
  Create visual regression tests using Playwright's built-in `toHaveScreenshot()` feature. This captures baseline PNG screenshots and compares future runs pixel-by-pixel.

  **A. Add snapshot configuration to `playwright.config.ts`:**

  In the `use` block, add snapshot configuration for visual regression:

  ```typescript
  use: {
    baseURL: process.env.BASE_URL || "http://localhost:3000",
    trace: "on-first-retry",
    screenshot: "only-on-failure",
    // Visual regression settings
    ...(!process.env.CI && {
      // Locally, update snapshots by default for convenience
      // CI always compares against committed baselines
    }),
  },
  ```

  Also add `snapshotPathTemplate` at the top level for organized snapshot storage:
  ```typescript
  snapshotPathTemplate: "{testDir}/__screenshots__/{testFilePath}/{arg}{ext}",
  ```

  And add `expect` configuration for screenshot comparison:
  ```typescript
  expect: {
    toHaveScreenshot: {
      maxDiffPixelRatio: 0.01, // Allow 1% pixel diff for anti-aliasing
      threshold: 0.2, // Per-pixel color threshold
    },
  },
  ```

  **B. Create public pages visual regression tests (`tests/e2e/visual-regression.spec.ts`):**

  ```typescript
  import { test, expect } from "@playwright/test";

  // Key public pages for visual regression baselines
  const publicPages = [
    { name: "homepage", path: "/", waitFor: "h1" },
    { name: "about", path: "/about", waitFor: "h1" },
    { name: "login", path: "/login", waitFor: 'input[type="email"]' },
    { name: "get-started", path: "/get-started", waitFor: "text=What stage" },
    { name: "pricing", path: "/pricing", waitFor: "text=Pro" },
    { name: "contact", path: "/contact", waitFor: "h1" },
  ];

  test.describe("Visual Regression: Public Pages", () => {
    for (const { name, path, waitFor } of publicPages) {
      test(`${name} matches baseline screenshot`, async ({ page }) => {
        await page.goto(path);

        // Wait for specific content to ensure page is fully rendered
        await page.waitForSelector(waitFor, { timeout: 10000 });

        // Wait for fonts and images to load
        await page.waitForLoadState("networkidle");

        // Small delay for animations to settle
        await page.waitForTimeout(500);

        await expect(page).toHaveScreenshot(`${name}.png`, {
          fullPage: true,
          // Mask dynamic content that changes between runs
          mask: [
            // Mask any live timestamps, counters, or dynamic numbers
            page.locator("[data-testid='dynamic-content']"),
          ],
        });
      });
    }
  });
  ```

  **C. Create authenticated pages visual regression tests (`tests/e2e/visual-regression-authenticated.spec.ts`):**

  ```typescript
  import { test, expect } from "./fixtures/auth";

  const authenticatedPages = [
    { name: "dashboard", path: "/dashboard", waitFor: "[data-testid='dashboard'], h1, main" },
    { name: "chat", path: "/chat", waitFor: "textarea, [data-testid='chat-input']" },
    { name: "check-ins", path: "/check-ins", waitFor: "main" },
    { name: "dashboard-settings", path: "/dashboard/settings", waitFor: "main" },
  ];

  test.describe("Visual Regression: Authenticated Pages", () => {
    for (const { name, path, waitFor } of authenticatedPages) {
      test(`${name} matches baseline screenshot`, async ({ authenticatedPage: page }) => {
        await page.goto(path);

        // Wait for content to render
        await page.waitForSelector(waitFor, { timeout: 15000 });
        await page.waitForLoadState("networkidle");

        // Wait for animations to settle
        await page.waitForTimeout(1000);

        await expect(page).toHaveScreenshot(`${name}.png`, {
          fullPage: true,
          mask: [
            // Mask user-specific content (names, emails, dates)
            page.locator("[data-testid='user-name']"),
            page.locator("[data-testid='user-email']"),
            page.locator("[data-testid='dynamic-content']"),
            page.locator("time"),
          ],
        });
      });
    }
  });
  ```

  **D. Generate baseline screenshots:**

  After creating the test files, generate the initial baseline screenshots by running:
  ```bash
  npx playwright test visual-regression --update-snapshots
  ```

  This creates the `__screenshots__` directory with baseline PNGs. These baseline images MUST be committed to git so CI can compare against them.

  If the dev server is not running or tests fail due to missing env vars (Supabase credentials needed for build), that's expected in a CI-only context. Document in the summary which baselines were successfully generated and which need to be generated when env vars are available.

  Add `tests/e2e/__screenshots__/` to git tracking (do NOT add to .gitignore -- these are intentional baselines).

  **Key design decisions:**
  - Use `fullPage: true` for comprehensive visual coverage
  - `maxDiffPixelRatio: 0.01` (1%) prevents false positives from anti-aliasing differences between CI and local
  - `threshold: 0.2` gives tolerance for minor rendering differences across platforms
  - Mask dynamic content (timestamps, user data) to prevent false failures
  - `waitFor` selectors ensure page content is loaded before screenshot
  - Chromium-only in CI (from Plan 01 config) means baselines only needed for Chromium
  - Authenticated pages use longer `waitForTimeout` because dashboard widgets load asynchronously
  </action>
  <verify>
  - `ls tests/e2e/visual-regression.spec.ts tests/e2e/visual-regression-authenticated.spec.ts` both exist
  - `grep "toHaveScreenshot" tests/e2e/visual-regression.spec.ts` confirms visual regression assertions
  - `grep "snapshotPathTemplate" playwright.config.ts` confirms snapshot path configured
  - `grep "maxDiffPixelRatio" playwright.config.ts` confirms comparison thresholds set
  - `npx tsc --noEmit` passes
  </verify>
  <done>
  Visual regression test suites created for 6 public pages and 4 authenticated pages. Playwright configured with snapshot path, comparison thresholds, and CI-appropriate settings. Baseline screenshots generated (or documented for generation when env vars are available).
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify and document staging environment</name>
  <files>
    .github/workflows/deploy.yml
  </files>
  <action>
  The staging environment is largely already configured. The workflow file already references `staging` branch in both trigger and deploy conditions. The `staging` branch exists locally and remotely. Vercel handles preview deployments automatically.

  Verify and enhance the staging setup:

  **A. Verify the deploy.yml staging configuration is correct:**

  In the existing `.github/workflows/deploy.yml`, confirm:
  1. `on.push.branches` includes `staging` -- it already does
  2. `on.pull_request.branches` includes `staging` -- it already does
  3. `deploy.environment.name` uses conditional: `${{ github.ref == 'refs/heads/main' && 'production' || 'staging' }}` -- it already does

  These are already correctly configured. No changes needed to the deploy triggers.

  **B. Add a staging label to the e2e job (added in Plan 01) so it's clear which environment the E2E tests target:**

  In the `e2e` job steps, add an environment label comment at the top of the job:

  ```yaml
  e2e:
    runs-on: ubuntu-latest
    needs: build
    timeout-minutes: 15
    # E2E tests run against a local build, not against deployed environment.
    # For staging-specific testing, use the staging Vercel URL.
  ```

  **C. Add a staging deployment URL output step:**

  In the `deploy` job, capture the Vercel deployment URL as an output. The existing `deploy` step already references `steps.deploy.outputs.deployment_url` but the actual `vercel` CLI output needs to be captured:

  Update the deploy step's run command to capture the URL:

  ```yaml
  - name: Deploy to Vercel
    id: deploy
    env:
      VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
      VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
      VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
    run: |
      npm install -g vercel
      if [ "${{ github.ref }}" == "refs/heads/main" ]; then
        DEPLOY_URL=$(vercel --prod --token $VERCEL_TOKEN 2>&1 | tail -1)
      else
        DEPLOY_URL=$(vercel --token $VERCEL_TOKEN 2>&1 | tail -1)
      fi
      echo "deployment_url=$DEPLOY_URL" >> $GITHUB_OUTPUT
      echo "Deployed to: $DEPLOY_URL"
  ```

  This captures the actual deployment URL from Vercel output so the job summary and Slack notification can reference it.

  **D. Update the Slack notification to include the deployment URL:**

  In the Slack notification payload, add the deployment URL:

  ```yaml
  - name: Notify Slack
    if: always()
    uses: slackapi/slack-github-action@v1
    continue-on-error: true
    with:
      webhook-url: ${{ secrets.SLACK_WEBHOOK }}
      payload: |
        {
          "text": "Sierra Fred Carey Deployment ${{ job.status }}",
          "blocks": [
            {
              "type": "section",
              "text": {
                "type": "mrkdwn",
                "text": "*Sierra Fred Carey Deployment*\nBranch: `${{ github.ref_name }}`\nStatus: ${{ job.status }}\nURL: ${{ steps.deploy.outputs.deployment_url || 'N/A' }}\nCommit: `${{ github.sha }}`"
              }
            }
          ]
        }
  ```

  **E. Verify staging branch exists and is in sync:**

  Run `git branch -a | grep staging` to confirm the branch exists. If staging is behind main, note it in the summary but do NOT force push or merge -- that's a user decision.

  The staging environment is considered "exists" when:
  - `staging` branch exists in git
  - Pushes to `staging` trigger the CI workflow
  - Vercel deploys staging pushes as preview deployments
  - The workflow distinguishes between `staging` and `production` environments

  All of these are already true based on the current workflow configuration.
  </action>
  <verify>
  - `grep "staging" .github/workflows/deploy.yml | wc -l` returns 4+ (branches, environment, deploy condition)
  - `git branch -a | grep staging` returns matches (branch exists)
  - `grep "deployment_url" .github/workflows/deploy.yml` confirms URL capture
  - `grep "GITHUB_OUTPUT" .github/workflows/deploy.yml` confirms URL output step
  - The deploy.yml YAML is valid (no syntax errors)
  </verify>
  <done>
  Staging environment verified: staging branch exists, CI triggers on staging pushes, Vercel deploys staging as preview. Deploy job captures and outputs the deployment URL. Slack notifications include the deployment URL for quick access.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
  Complete CI/CD testing expansion:
  - Playwright E2E job runs in CI on every PR (from Plan 01)
  - axe-core accessibility tests for 12 pages (7 public + 5 authenticated)
  - Visual regression baselines for 10 pages (6 public + 4 authenticated)
  - Staging environment verified and deployment URL captured
  </what-built>
  <how-to-verify>
  1. Check the workflow file: Open `.github/workflows/deploy.yml` and verify the `e2e` job exists with Playwright install + test steps
  2. Check that `deploy` job depends on `[build, security, e2e]`
  3. Review `tests/e2e/accessibility.spec.ts` -- should test 7 public pages with axe-core
  4. Review `tests/e2e/visual-regression.spec.ts` -- should test 6 public pages with toHaveScreenshot
  5. Verify baseline screenshots exist in `tests/e2e/__screenshots__/` (or confirm they need env vars to generate)
  6. Ensure the following GitHub Actions secrets are set (needed for CI):
     - `E2E_TEST_EMAIL` -- test account email
     - `E2E_TEST_PASSWORD` -- test account password
     - `NEXT_PUBLIC_SUPABASE_URL` -- Supabase project URL
     - `NEXT_PUBLIC_SUPABASE_ANON_KEY` -- Supabase anon key
  7. Push a commit to a branch and create a PR to verify the e2e job runs
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
- `tests/e2e/visual-regression.spec.ts` captures baselines for 6 public pages
- `tests/e2e/visual-regression-authenticated.spec.ts` captures baselines for 4 authenticated pages
- `playwright.config.ts` has snapshotPathTemplate and comparison thresholds
- Staging branch exists and CI triggers on staging pushes
- Deploy job captures Vercel deployment URL
- `npx tsc --noEmit` passes
</verification>

<success_criteria>
1. Visual regression baselines exist for 10 key pages (committed to repo or documented for generation)
2. Future UI changes that alter page appearance cause visual regression test failures
3. Staging branch deploys to Vercel preview environment
4. Deployment URL is captured and included in Slack notifications
</success_criteria>

<output>
After completion, create `.planning/phases/60-cicd-testing-expansion/60-02-SUMMARY.md`
</output>
