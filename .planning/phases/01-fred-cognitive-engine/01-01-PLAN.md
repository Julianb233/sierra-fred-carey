# Plan 01-01: Database Schema for FRED Memory

**Status:** COMPLETED
**Phase:** 01 - FRED Cognitive Engine Foundation
**Depends On:** None
**Estimated Complexity:** Medium

---

## Objective

Create the database schema for FRED's three-layer memory architecture (episodic, semantic, procedural) using Supabase Postgres with pgvector extension.

---

## Context

FRED needs persistent memory to:
1. Remember past conversations and decisions (episodic)
2. Store learned facts and patterns (semantic)
3. Know how to execute procedures (procedural)

This follows the research recommendation for a three-layer memory architecture using pgvector for semantic search capabilities.

---

## Implementation Steps

### Step 1: Enable pgvector Extension

Create migration to enable pgvector in Supabase.

**File:** `supabase/migrations/YYYYMMDD_enable_pgvector.sql`

```sql
create extension if not exists vector with schema extensions;
```

### Step 2: Create Episodic Memory Table

Store conversation history, decisions made, and their outcomes.

**File:** `supabase/migrations/YYYYMMDD_fred_episodic_memory.sql`

```sql
create table fred_episodic_memory (
  id uuid primary key default gen_random_uuid(),
  user_id uuid references auth.users(id) on delete cascade,
  session_id uuid not null,
  event_type text not null, -- 'conversation', 'decision', 'outcome'
  content jsonb not null,
  embedding vector(1536), -- OpenAI ada-002 dimension
  importance_score float default 0.5,
  created_at timestamptz default now(),
  metadata jsonb default '{}'
);

create index fred_episodic_user_idx on fred_episodic_memory(user_id);
create index fred_episodic_session_idx on fred_episodic_memory(session_id);
create index fred_episodic_embedding_idx on fred_episodic_memory
  using ivfflat (embedding vector_cosine_ops) with (lists = 100);
```

### Step 3: Create Semantic Memory Table

Store learned facts, patterns, and knowledge about the user/startup.

**File:** `supabase/migrations/YYYYMMDD_fred_semantic_memory.sql`

```sql
create table fred_semantic_memory (
  id uuid primary key default gen_random_uuid(),
  user_id uuid references auth.users(id) on delete cascade,
  category text not null, -- 'startup_facts', 'user_preferences', 'market_knowledge'
  key text not null,
  value jsonb not null,
  embedding vector(1536),
  confidence float default 1.0,
  source text, -- where this knowledge came from
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  unique(user_id, category, key)
);

create index fred_semantic_user_idx on fred_semantic_memory(user_id);
create index fred_semantic_category_idx on fred_semantic_memory(category);
create index fred_semantic_embedding_idx on fred_semantic_memory
  using ivfflat (embedding vector_cosine_ops) with (lists = 100);
```

### Step 4: Create Procedural Memory Table

Store action patterns, decision frameworks, and execution templates.

**File:** `supabase/migrations/YYYYMMDD_fred_procedural_memory.sql`

```sql
create table fred_procedural_memory (
  id uuid primary key default gen_random_uuid(),
  name text unique not null,
  description text,
  procedure_type text not null, -- 'decision_framework', 'action_template', 'analysis_pattern'
  steps jsonb not null, -- ordered array of steps
  triggers jsonb, -- conditions that activate this procedure
  success_rate float default 0.5,
  usage_count int default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Procedural memory is global (not per-user), represents FRED's learned behaviors
```

### Step 5: Create Memory Access Functions

**File:** `lib/db/fred-memory.ts`

```typescript
import { sql } from './supabase-sql';

// Episodic memory operations
export async function storeEpisode(
  userId: string,
  sessionId: string,
  eventType: 'conversation' | 'decision' | 'outcome',
  content: Record<string, unknown>,
  embedding?: number[]
) { ... }

export async function retrieveRecentEpisodes(
  userId: string,
  limit: number = 10
) { ... }

export async function searchEpisodesByEmbedding(
  userId: string,
  embedding: number[],
  limit: number = 5
) { ... }

// Semantic memory operations
export async function storeFact(
  userId: string,
  category: string,
  key: string,
  value: Record<string, unknown>,
  embedding?: number[]
) { ... }

export async function getFact(
  userId: string,
  category: string,
  key: string
) { ... }

export async function searchFactsByEmbedding(
  userId: string,
  embedding: number[],
  limit: number = 5
) { ... }

// Procedural memory operations
export async function getProcedure(name: string) { ... }

export async function recordProcedureUsage(
  name: string,
  success: boolean
) { ... }
```

### Step 6: Seed Default Procedures

**File:** `supabase/seed/fred_procedures.sql`

Seed FRED's canonical decision frameworks:
- 7-factor scoring procedure
- Reality Lens assessment procedure
- Investor readiness procedure

---

## Testing

### Unit Tests
- [ ] Test episodic memory CRUD operations
- [ ] Test semantic memory upsert behavior
- [ ] Test procedural memory retrieval
- [ ] Test embedding-based similarity search

### Integration Tests
- [ ] Test memory persistence across sessions
- [ ] Test concurrent access patterns
- [ ] Test memory cleanup/archival

---

## Verification

- [x] All migrations run successfully
- [x] pgvector extension enabled
- [x] Tables created with correct indexes
- [x] TypeScript functions compile
- [x] Basic CRUD tests pass (19 tests in fred-memory.test.ts)
- [ ] Embedding search returns relevant results (requires RPC function setup)

---

## Notes

- Using OpenAI ada-002 embeddings (1536 dimensions) as default
- IVFFlat index with 100 lists is reasonable for expected data volume
- May need to tune index parameters as data grows
- Consider adding archival strategy for episodic memory (older entries â†’ cold storage)

---

*Plan created: 2026-02-05*
