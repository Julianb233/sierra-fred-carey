# Plan 01-02: XState v5 Decision State Machine

**Status:** COMPLETED ✅
**Phase:** 01 - FRED Cognitive Engine Foundation
**Depends On:** 01-01 (memory schema for state persistence)
**Estimated Complexity:** High
**Completed:** 2026-02-05

---

## Objective

Implement FRED's core decision state machine using XState v5, following the canonical flow: INTAKE → VALIDATION → MENTAL_MODELS → SYNTHESIS → AUTO-DECIDE/ESCALATE → EXECUTE/HUMAN-IN-LOOP.

---

## Context

The state machine is FRED's brain. Every decision flows through this deterministic backbone, ensuring:
- Predictable behavior (no random agent wandering)
- Auditability (every state transition logged)
- Debuggability (visual inspection in Stately Studio)
- Reliability (explicit error handling per state)

---

## Implementation Steps

### Step 1: Install XState v5

```bash
pnpm add xstate @xstate/react
```

### Step 2: Define State Machine Types

**File:** `lib/fred/types.ts`

```typescript
export interface FredContext {
  sessionId: string;
  userId: string;
  input: UserInput | null;
  validatedInput: ValidatedInput | null;
  mentalModels: MentalModelResult[];
  synthesis: SynthesisResult | null;
  decision: DecisionResult | null;
  scores: FactorScores | null;
  error: Error | null;
  retryCount: number;
}

export interface UserInput {
  message: string;
  attachments?: Attachment[];
  context?: Record<string, unknown>;
}

export interface ValidatedInput {
  intent: 'question' | 'decision_request' | 'information' | 'feedback';
  entities: ExtractedEntity[];
  confidence: number;
  clarificationNeeded: string[];
}

export interface MentalModelResult {
  model: string; // 'first_principles', 'swot', 'jobs_to_be_done', etc.
  analysis: Record<string, unknown>;
  relevance: number;
}

export interface SynthesisResult {
  recommendation: string;
  confidence: number;
  reasoning: string;
  factors: FactorScores;
  alternatives: Alternative[];
}

export interface DecisionResult {
  action: 'auto_execute' | 'recommend' | 'escalate';
  content: string;
  confidence: number;
  requiresHumanApproval: boolean;
}

export interface FactorScores {
  strategicAlignment: number; // 0-1
  leverage: number;
  speed: number;
  revenue: number;
  time: number;
  risk: number;
  relationships: number;
  composite: number;
}
```

### Step 3: Create State Machine Definition

**File:** `lib/fred/machine.ts`

```typescript
import { setup, assign, fromPromise } from 'xstate';
import type { FredContext } from './types';

export const fredMachine = setup({
  types: {
    context: {} as FredContext,
    events: {} as
      | { type: 'START'; input: UserInput }
      | { type: 'VALIDATE_COMPLETE'; result: ValidatedInput }
      | { type: 'MODELS_COMPLETE'; results: MentalModelResult[] }
      | { type: 'SYNTHESIS_COMPLETE'; result: SynthesisResult }
      | { type: 'DECISION_COMPLETE'; result: DecisionResult }
      | { type: 'HUMAN_APPROVED' }
      | { type: 'HUMAN_REJECTED'; feedback: string }
      | { type: 'ERROR'; error: Error }
      | { type: 'RETRY' }
  },
  actors: {
    validateInput: fromPromise(async ({ input }) => { ... }),
    applyMentalModels: fromPromise(async ({ input }) => { ... }),
    synthesize: fromPromise(async ({ input }) => { ... }),
    decide: fromPromise(async ({ input }) => { ... }),
    execute: fromPromise(async ({ input }) => { ... }),
  },
  guards: {
    canAutoDecide: ({ context }) =>
      context.decision?.confidence >= 0.85 &&
      !context.decision?.requiresHumanApproval,
    needsClarification: ({ context }) =>
      context.validatedInput?.clarificationNeeded.length > 0,
    canRetry: ({ context }) => context.retryCount < 3,
  },
  actions: {
    logTransition: ({ context, event }) => { ... },
    storeToMemory: ({ context }) => { ... },
    incrementRetry: assign({ retryCount: ({ context }) => context.retryCount + 1 }),
  }
}).createMachine({
  id: 'fred',
  initial: 'idle',
  context: { ... },
  states: {
    idle: {
      on: { START: { target: 'intake', actions: 'logTransition' } }
    },
    intake: {
      invoke: {
        src: 'validateInput',
        input: ({ context }) => context.input,
        onDone: {
          target: 'validation',
          actions: assign({ validatedInput: ({ event }) => event.output })
        },
        onError: { target: 'error' }
      }
    },
    validation: {
      always: [
        { guard: 'needsClarification', target: 'clarification' },
        { target: 'mental_models' }
      ]
    },
    clarification: {
      // Wait for user to provide more info
      on: {
        START: { target: 'intake' }
      }
    },
    mental_models: {
      invoke: {
        src: 'applyMentalModels',
        input: ({ context }) => context.validatedInput,
        onDone: {
          target: 'synthesis',
          actions: assign({ mentalModels: ({ event }) => event.output })
        },
        onError: { target: 'error' }
      }
    },
    synthesis: {
      invoke: {
        src: 'synthesize',
        input: ({ context }) => ({
          input: context.validatedInput,
          models: context.mentalModels
        }),
        onDone: {
          target: 'decide',
          actions: assign({ synthesis: ({ event }) => event.output })
        },
        onError: { target: 'error' }
      }
    },
    decide: {
      invoke: {
        src: 'decide',
        input: ({ context }) => context.synthesis,
        onDone: [
          {
            guard: 'canAutoDecide',
            target: 'execute',
            actions: assign({ decision: ({ event }) => event.output })
          },
          {
            target: 'human_review',
            actions: assign({ decision: ({ event }) => event.output })
          }
        ],
        onError: { target: 'error' }
      }
    },
    human_review: {
      on: {
        HUMAN_APPROVED: { target: 'execute' },
        HUMAN_REJECTED: {
          target: 'synthesis',
          actions: assign({ /* incorporate feedback */ })
        }
      }
    },
    execute: {
      invoke: {
        src: 'execute',
        input: ({ context }) => context.decision,
        onDone: {
          target: 'complete',
          actions: 'storeToMemory'
        },
        onError: { target: 'error' }
      }
    },
    complete: {
      type: 'final',
      entry: 'storeToMemory'
    },
    error: {
      on: {
        RETRY: [
          { guard: 'canRetry', target: 'intake', actions: 'incrementRetry' },
          { target: 'failed' }
        ]
      }
    },
    failed: {
      type: 'final'
    }
  }
});
```

### Step 4: Implement Actor Functions

**File:** `lib/fred/actors/validate-input.ts`
**File:** `lib/fred/actors/mental-models.ts`
**File:** `lib/fred/actors/synthesize.ts`
**File:** `lib/fred/actors/decide.ts`
**File:** `lib/fred/actors/execute.ts`

Each actor:
1. Calls AI provider via AI SDK
2. Validates response with Zod schema
3. Returns typed result
4. Logs to observability

### Step 5: Create FRED Service

**File:** `lib/fred/service.ts`

```typescript
import { createActor } from 'xstate';
import { fredMachine } from './machine';

export function createFredSession(userId: string, sessionId: string) {
  const actor = createActor(fredMachine, {
    input: { userId, sessionId }
  });

  actor.subscribe((state) => {
    // Log all state transitions for observability
    console.log(`[FRED] ${state.value}`, state.context);
  });

  return actor;
}

export async function processFredRequest(
  userId: string,
  sessionId: string,
  input: UserInput
): Promise<DecisionResult> {
  const actor = createFredSession(userId, sessionId);
  actor.start();
  actor.send({ type: 'START', input });

  // Wait for final state
  return new Promise((resolve, reject) => {
    actor.subscribe((state) => {
      if (state.matches('complete')) {
        resolve(state.context.decision!);
      } else if (state.matches('failed')) {
        reject(state.context.error);
      }
    });
  });
}
```

### Step 6: Add Observability Hooks

**File:** `lib/fred/observability.ts`

Log every state transition, AI call, and decision for debugging and calibration tracking.

---

## Testing

### Unit Tests
- [x] Test each state transition
- [x] Test guards (canAutoDecide, needsClarification, canRetry)
- [x] Test actor functions in isolation
- [x] Test error handling and retry logic

### Integration Tests
- [x] Test full decision flow end-to-end
- [x] Test human-in-loop flow
- [ ] Test memory persistence across sessions (future)

### Visual Testing
- [ ] Export machine to Stately Studio (future)
- [x] Verify state diagram matches spec
- [x] Test edge cases visually

---

## Verification

- [x] XState v5 installed and configured
- [x] Machine compiles without TypeScript errors
- [x] All states reachable (no dead states)
- [x] Guards prevent invalid transitions
- [x] Actors return properly typed results
- [x] Observability logs all transitions
- [x] Memory persists decision context

---

## Notes

- Using XState's `setup()` API for TypeScript inference (v5 pattern)
- `fromPromise` for async actors (AI calls)
- Consider adding timeout handling for AI calls
- Stately Studio can import this machine for visual editing

---

*Plan created: 2026-02-05*
