---
phase: 47-community-data-layer-consent
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/db/migrations/053_community_data_layer.sql
autonomous: true

must_haves:
  truths:
    - "14 new tables exist with correct columns, constraints, and foreign keys"
    - "3 new columns added to existing communities table for subcommunity support"
    - "2 materialized views exist with consent-gated, k-anonymous aggregations"
    - "All 14 new tables have RLS enabled with user-scoped and service-role policies"
    - "Counter-sync triggers exist for social_feed_posts reaction_count and comment_count"
    - "Consent audit log trigger captures every consent_preferences change automatically"
    - "All tables that will use Supabase Realtime have REPLICA IDENTITY FULL set"
  artifacts:
    - path: "lib/db/migrations/053_community_data_layer.sql"
      provides: "Complete schema for Phases 47-53 community features"
      min_lines: 500
      contains: "CREATE TABLE community_profiles"
  key_links:
    - from: "consent_preferences"
      to: "benchmark_stage_aggregates"
      via: "INNER JOIN on user_id with category='benchmarks' AND enabled=true"
      pattern: "INNER JOIN consent_preferences"
    - from: "communities.parent_community_id"
      to: "communities.id"
      via: "self-referencing FK for subcommunity hierarchy"
      pattern: "parent_community_id UUID REFERENCES communities"
---

<objective>
Create the single migration file (053) containing all database schema for Phases 47-53: 14 new tables, 3 ALTER columns on communities, 2 materialized views, RLS policies, triggers, indexes, and constraints.

Purpose: This is the foundation migration that ALL community features (Phases 47-53) depend on. By creating all tables in a single migration, we ensure atomic deployment and FK consistency. No downstream phase should ever need schema changes -- only application code.

Output: `lib/db/migrations/053_community_data_layer.sql` -- a complete, production-ready SQL migration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/47-community-data-layer-consent/47-RESEARCH.md

# Existing migration patterns to follow exactly
@lib/db/migrations/051_founder_communities.sql

# Existing tables referenced by FKs in new schema
@lib/db/migrations/009_journey_tables.sql
@lib/db/migrations/025_investor_readiness_scores.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration 053 -- tables, ALTER columns, indexes, constraints</name>
  <files>lib/db/migrations/053_community_data_layer.sql</files>
  <action>
Create the migration file with these sections in order. Follow the EXACT pattern from migration 051 (DO $$ BEGIN...EXCEPTION WHEN duplicate_object THEN NULL; END $$) for all policies and constraints.

**Section 1: ALTER existing communities table**
Add 3 columns to the existing `communities` table:
- `parent_community_id UUID REFERENCES communities(id) ON DELETE CASCADE` (nullable, null = top-level)
- `is_sponsored BOOLEAN NOT NULL DEFAULT false`
- `tier_required INTEGER NOT NULL DEFAULT 0` (matches UserTier enum: 0=Free, 1=Pro, 2=Studio)
Use `ALTER TABLE communities ADD COLUMN IF NOT EXISTS` for each.
Add index: `idx_communities_parent ON communities(parent_community_id) WHERE parent_community_id IS NOT NULL`

**Section 2: Create 14 new tables**

Tables in dependency order (for FK resolution):

1. `community_profiles` -- user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE, display_name TEXT NOT NULL DEFAULT '', bio TEXT NOT NULL DEFAULT '', avatar_url TEXT, stage TEXT, industry TEXT, achievements TEXT[] NOT NULL DEFAULT '{}', visibility_settings JSONB NOT NULL DEFAULT '{"show_name":true,"show_stage":true,"show_industry":true,"show_bio":true,"show_achievements":true}'::jsonb, UNIQUE(user_id), timestamps
2. `consent_preferences` -- user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE, category TEXT NOT NULL CHECK (category IN ('benchmarks','social_feed','directory','messaging','investor_intros')), enabled BOOLEAN NOT NULL DEFAULT false, updated_at TIMESTAMPTZ DEFAULT now(), UNIQUE(user_id, category)
3. `consent_audit_log` -- user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE, category TEXT NOT NULL, previous_value BOOLEAN NOT NULL, new_value BOOLEAN NOT NULL, changed_at TIMESTAMPTZ DEFAULT now(), ip_address TEXT, user_agent TEXT (NO unique constraint, append-only)
4. `subcommunity_sponsors` -- community_id UUID NOT NULL REFERENCES communities(id) ON DELETE CASCADE, sponsor_user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, sponsor_name TEXT NOT NULL, sponsor_logo_url TEXT, sponsor_url TEXT, is_featured BOOLEAN NOT NULL DEFAULT false, started_at TIMESTAMPTZ DEFAULT now(), expires_at TIMESTAMPTZ, is_active BOOLEAN NOT NULL DEFAULT true, UNIQUE(community_id, sponsor_user_id), timestamps
5. `cohorts` -- name TEXT NOT NULL, cohort_type TEXT NOT NULL DEFAULT 'stage' CHECK ('stage','industry','custom'), max_members INTEGER NOT NULL DEFAULT 8, status TEXT NOT NULL DEFAULT 'forming' CHECK ('forming','active','archived'), match_criteria JSONB DEFAULT '{}'::jsonb, timestamps
6. `cohort_members` -- cohort_id UUID NOT NULL REFERENCES cohorts(id) ON DELETE CASCADE, user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, role TEXT NOT NULL DEFAULT 'member' CHECK ('member','facilitator'), joined_at TIMESTAMPTZ DEFAULT now(), left_at TIMESTAMPTZ, is_active BOOLEAN NOT NULL DEFAULT true, UNIQUE(cohort_id, user_id)
7. `social_feed_posts` -- author_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, post_type TEXT NOT NULL DEFAULT 'milestone' CHECK ('milestone','achievement','update','shoutout'), title TEXT NOT NULL DEFAULT '', content TEXT NOT NULL, milestone_id UUID REFERENCES milestones(id) ON DELETE SET NULL, metadata JSONB DEFAULT '{}'::jsonb, reaction_count INTEGER NOT NULL DEFAULT 0, comment_count INTEGER NOT NULL DEFAULT 0, view_count INTEGER NOT NULL DEFAULT 0, is_public BOOLEAN NOT NULL DEFAULT true, timestamps
8. `social_feed_reactions` -- post_id UUID NOT NULL REFERENCES social_feed_posts(id) ON DELETE CASCADE, user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, reaction_type TEXT NOT NULL DEFAULT 'encourage' CHECK ('encourage','celebrate','insightful'), UNIQUE(post_id, user_id, reaction_type), created_at
9. `social_feed_comments` -- post_id UUID NOT NULL REFERENCES social_feed_posts(id) ON DELETE CASCADE, author_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, content TEXT NOT NULL, parent_comment_id UUID REFERENCES social_feed_comments(id) ON DELETE CASCADE, timestamps
10. `founder_messages` -- sender_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, recipient_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, content TEXT NOT NULL, is_read BOOLEAN NOT NULL DEFAULT false, is_fred_facilitated BOOLEAN NOT NULL DEFAULT false, metadata JSONB DEFAULT '{}'::jsonb, created_at TIMESTAMPTZ DEFAULT now()
11. `founder_connections` -- requester_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, recipient_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, status TEXT NOT NULL DEFAULT 'pending' CHECK ('pending','accepted','blocked','declined'), source TEXT NOT NULL DEFAULT 'directory' CHECK ('directory','cohort','fred_suggestion','community'), UNIQUE(requester_id, recipient_id), timestamps
12. `expert_listings` -- user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, expertise_type TEXT NOT NULL CHECK ('design_review','tech_architecture','gtm_strategy','fundraising','legal','other'), title TEXT NOT NULL, description TEXT NOT NULL, is_active BOOLEAN NOT NULL DEFAULT true, timestamps
13. `reputation_events` -- user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, event_type TEXT NOT NULL CHECK ('intro_made','roundtable_participation','help_given','expertise_shared','mentor_session'), points INTEGER NOT NULL DEFAULT 1, source_id UUID, source_type TEXT, metadata JSONB DEFAULT '{}'::jsonb, created_at
14. `engagement_streaks` -- user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, current_streak INTEGER NOT NULL DEFAULT 0, longest_streak INTEGER NOT NULL DEFAULT 0, last_checkin_date DATE, streak_started_at DATE, total_checkins INTEGER NOT NULL DEFAULT 0, UNIQUE(user_id), updated_at

Every table gets:
- `id UUID PRIMARY KEY DEFAULT gen_random_uuid()`
- Appropriate indexes (at minimum: user_id columns, FK columns, created_at DESC for time-ordered queries)
- `updated_at` trigger using existing `update_updated_at_column()` function (for tables with updated_at)

**Section 3: Counter-sync triggers**
Create triggers for social_feed_posts to sync reaction_count and comment_count, following the EXACT pattern from migration 051 (sync_post_reaction_count, sync_post_reply_count).

**Section 4: Consent audit trigger**
Create a trigger on consent_preferences that fires AFTER INSERT OR UPDATE and inserts a row into consent_audit_log with the old and new values. For INSERT, previous_value should be false (the default).

**Section 5: Materialized views**

Create `benchmark_stage_aggregates`:
```sql
CREATE MATERIALIZED VIEW IF NOT EXISTS benchmark_stage_aggregates AS
SELECT
  p.stage,
  COUNT(*) as founder_count,
  AVG(irs.overall_score)::NUMERIC(5,2) as avg_irs_score,
  PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY irs.overall_score) as median_irs_score
FROM profiles p
INNER JOIN consent_preferences cp ON cp.user_id = p.id AND cp.category = 'benchmarks' AND cp.enabled = true
LEFT JOIN LATERAL (
  SELECT overall_score FROM investor_readiness_scores WHERE user_id = p.id ORDER BY created_at DESC LIMIT 1
) irs ON true
WHERE p.stage IS NOT NULL
GROUP BY p.stage
HAVING COUNT(*) >= 5;
```

Create `benchmark_industry_aggregates` (same pattern but grouped by industry instead of stage).

Add unique indexes on materialized views (required for REFRESH CONCURRENTLY):
- `CREATE UNIQUE INDEX idx_benchmark_stage_agg_stage ON benchmark_stage_aggregates(stage)`
- `CREATE UNIQUE INDEX idx_benchmark_industry_agg_industry ON benchmark_industry_aggregates(industry)`

Create refresh function:
```sql
CREATE OR REPLACE FUNCTION refresh_benchmark_aggregates()
RETURNS void AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY benchmark_stage_aggregates;
  REFRESH MATERIALIZED VIEW CONCURRENTLY benchmark_industry_aggregates;
END;
$$ LANGUAGE plpgsql;
```

**Section 6: Realtime preparation**
Set `ALTER TABLE social_feed_posts REPLICA IDENTITY FULL` and `ALTER TABLE founder_messages REPLICA IDENTITY FULL` for future Phases 49/52.

**Section 7: Table comments**
Add `COMMENT ON TABLE` for every new table explaining its purpose and which phase uses it.

IMPORTANT: The milestones table has `id` as TEXT type (from migration 009_journey_tables.sql). Check the actual column type. If milestones.id is TEXT, then social_feed_posts.milestone_id should also be TEXT (not UUID). If milestones.id is UUID, use UUID. Match the existing type exactly.
  </action>
  <verify>
1. File exists and is valid SQL: `head -5 lib/db/migrations/053_community_data_layer.sql` shows migration header
2. Count tables: `grep -c 'CREATE TABLE' lib/db/migrations/053_community_data_layer.sql` returns 14
3. Count RLS enables: `grep -c 'ENABLE ROW LEVEL SECURITY' lib/db/migrations/053_community_data_layer.sql` returns 14
4. Consent join in views: `grep 'consent_preferences' lib/db/migrations/053_community_data_layer.sql` returns matches
5. k-anonymity: `grep 'HAVING COUNT' lib/db/migrations/053_community_data_layer.sql` returns matches with >= 5
6. ALTER communities: `grep 'parent_community_id' lib/db/migrations/053_community_data_layer.sql` returns match
  </verify>
  <done>
Migration 053 exists with all 14 tables, 3 ALTER columns, 2 materialized views, RLS policies on all tables, counter-sync triggers, consent audit trigger, indexes, constraints, unique indexes for CONCURRENTLY refresh, and table comments. The migration follows the exact pattern from 051 and is ready for production deployment.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create RLS policies for all 14 new tables</name>
  <files>lib/db/migrations/053_community_data_layer.sql</files>
  <action>
This task is PART OF the same migration file as Task 1 -- append RLS policies as Section 7 of the migration.

For EACH of the 14 new tables, add RLS policies following the DO $$ BEGIN...EXCEPTION pattern from migration 051. The specific policies per table:

**community_profiles:**
- SELECT: Any authenticated user (`auth.uid() IS NOT NULL`) -- visibility filtering happens at application level via visibility_settings JSONB
- INSERT: Own profile only (`auth.uid() = user_id`)
- UPDATE: Own profile only (`auth.uid() = user_id`)
- DELETE: Own profile only (`auth.uid() = user_id`)
- ALL for service_role

**consent_preferences:**
- SELECT: Own preferences only (`auth.uid() = user_id`)
- INSERT: Own preferences only (`auth.uid() = user_id`)
- UPDATE: Own preferences only (`auth.uid() = user_id`)
- DELETE: Own preferences only (`auth.uid() = user_id`)
- ALL for service_role (needed for aggregate pipeline)

**consent_audit_log:**
- SELECT: Own audit log only (`auth.uid() = user_id`)
- No INSERT/UPDATE/DELETE for users (trigger-only writes)
- ALL for service_role

**subcommunity_sponsors:**
- SELECT: Any authenticated user (`auth.uid() IS NOT NULL`)
- INSERT/UPDATE/DELETE: Service role only (admin-managed sponsorships)
- ALL for service_role

**cohorts:**
- SELECT: Members of the cohort (EXISTS subquery on cohort_members)
- INSERT: Service role only (auto-matching creates cohorts)
- UPDATE/DELETE: Service role only
- ALL for service_role

**cohort_members:**
- SELECT: Members of the same cohort
- INSERT: Service role only (auto-matching adds members)
- DELETE: Own membership (`auth.uid() = user_id`) or service role
- ALL for service_role

**social_feed_posts:**
- SELECT: Any authenticated user (public feed)
- INSERT: Own posts (`auth.uid() = author_id`)
- UPDATE: Own posts (`auth.uid() = author_id`)
- DELETE: Own posts (`auth.uid() = author_id`)
- ALL for service_role

**social_feed_reactions:**
- SELECT: Any authenticated user
- INSERT: Own reactions (`auth.uid() = user_id`)
- DELETE: Own reactions (`auth.uid() = user_id`)
- ALL for service_role

**social_feed_comments:**
- SELECT: Any authenticated user
- INSERT: Own comments (`auth.uid() = author_id`)
- UPDATE: Own comments (`auth.uid() = author_id`)
- DELETE: Own comments (`auth.uid() = author_id`)
- ALL for service_role

**founder_messages:**
- SELECT: Sender OR recipient (`auth.uid() = sender_id OR auth.uid() = recipient_id`)
- INSERT: As sender only (`auth.uid() = sender_id`)
- No UPDATE (messages are immutable)
- No DELETE for users (admin only)
- ALL for service_role

**founder_connections:**
- SELECT: Requester OR recipient
- INSERT: As requester only (`auth.uid() = requester_id`)
- UPDATE: Recipient can accept/decline (`auth.uid() = recipient_id`), requester can cancel
- DELETE: Either party can remove
- ALL for service_role

**expert_listings:**
- SELECT: Any authenticated user
- INSERT: Own listings (`auth.uid() = user_id`)
- UPDATE: Own listings (`auth.uid() = user_id`)
- DELETE: Own listings (`auth.uid() = user_id`)
- ALL for service_role

**reputation_events:**
- SELECT: Own events (`auth.uid() = user_id`)
- INSERT: Service role only (system-generated)
- ALL for service_role

**engagement_streaks:**
- SELECT: Own streak (`auth.uid() = user_id`)
- INSERT: Service role only
- UPDATE: Service role only
- ALL for service_role

Every policy must use the DO $$ BEGIN...EXCEPTION WHEN duplicate_object THEN NULL; END $$ wrapper for idempotent reruns.
  </action>
  <verify>
1. `grep -c 'CREATE POLICY' lib/db/migrations/053_community_data_layer.sql` returns at least 40 (14 tables x ~3 policies each)
2. Every table has service_role ALL policy: `grep -c 'Service role' lib/db/migrations/053_community_data_layer.sql`
3. consent_preferences SELECT is user-scoped: `grep -A3 'read own consent' lib/db/migrations/053_community_data_layer.sql` shows `auth.uid() = user_id`
4. founder_messages SELECT allows both parties: `grep -A3 'read.*messages' lib/db/migrations/053_community_data_layer.sql`
  </verify>
  <done>
All 14 tables have comprehensive RLS policies. Consent preferences are strictly user-scoped (no other user can read your consent). Founder messages allow both sender and recipient to read. Cohorts and engagement streaks are service-role-managed. All policies are wrapped in idempotent DO blocks.
  </done>
</task>

</tasks>

<verification>
Run these checks against the completed migration:

1. **Table count:** `grep -c 'CREATE TABLE IF NOT EXISTS' lib/db/migrations/053_community_data_layer.sql` = 14
2. **RLS count:** `grep -c 'ENABLE ROW LEVEL SECURITY' lib/db/migrations/053_community_data_layer.sql` = 14
3. **Consent enforcement in views:** `grep -c 'consent_preferences' lib/db/migrations/053_community_data_layer.sql` >= 4 (two views, each with consent JOIN)
4. **k-anonymity:** `grep 'HAVING COUNT' lib/db/migrations/053_community_data_layer.sql` shows `>= 5` in both views
5. **ALTER communities:** All 3 new columns present (parent_community_id, is_sponsored, tier_required)
6. **Service role policies:** Every table has one
7. **No syntax errors:** The file can be parsed by reviewing opening/closing parentheses balance
</verification>

<success_criteria>
- Migration 053 exists as a single, complete SQL file
- All 14 new tables created with correct columns, types, constraints, and FKs
- 3 columns added to existing communities table
- 2 materialized views with consent-gating and k-anonymity (HAVING COUNT >= 5)
- RLS enabled and policies created for all 14 tables
- Counter-sync triggers for social_feed_posts
- Consent audit trigger on consent_preferences
- REPLICA IDENTITY FULL on tables that will use Realtime
- Unique indexes on materialized views for CONCURRENTLY refresh
- File follows exact pattern from migration 051
</success_criteria>

<output>
After completion, create `.planning/phases/47-community-data-layer-consent/47-01-SUMMARY.md`
</output>
