---
phase: 06-tier-stripe-wiring
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - app/dashboard/layout.tsx
  - app/dashboard/page.tsx
  - app/dashboard/settings/page.tsx
autonomous: true

must_haves:
  truths:
    - "Dashboard sidebar shows real user name, email, and tier from auth + TierProvider (not hardcoded Fred Cary)"
    - "Dashboard page derives tier from useTier() context (not profiles.tier column)"
    - "After Stripe checkout success redirect, tier refreshes and success toast appears"
    - "Settings page shows real user data and real subscription plan (not hardcoded Free)"
    - "Nav locking in sidebar uses real tier from context"
  artifacts:
    - path: "app/dashboard/layout.tsx"
      provides: "Dashboard sidebar with real user data from Supabase auth + useTier()"
      contains: "useTier"
    - path: "app/dashboard/page.tsx"
      provides: "Dashboard overview with tier from context + post-checkout success handling"
      contains: "useTier"
    - path: "app/dashboard/settings/page.tsx"
      provides: "Settings page with real profile data + real subscription status"
      contains: "useTier"
  key_links:
    - from: "app/dashboard/layout.tsx"
      to: "lib/context/tier-context.tsx"
      via: "useTier() hook"
      pattern: "useTier\\(\\)"
    - from: "app/dashboard/page.tsx"
      to: "lib/context/tier-context.tsx"
      via: "useTier() hook for tier-aware rendering + refresh after checkout"
      pattern: "useTier\\(\\)|refresh"
    - from: "app/dashboard/settings/page.tsx"
      to: "lib/context/tier-context.tsx"
      via: "useTier() hook for subscription display"
      pattern: "useTier\\(\\)"
---

<objective>
Wire dashboard consumer components to use real user data from Supabase auth and real tier from TierProvider context. Replace all hardcoded mock data. Add post-Stripe-checkout success handling with tier refresh and toast notification.

Purpose: With TierProvider mounted and tier-context fixed (Plan 01), the dashboard layout, overview page, and settings page still use hardcoded mock data. This plan replaces those mocks with real data, completing the "Free user -> Stripe upgrade -> Pro access" flow end-to-end.

Output: Three updated dashboard pages that display real user identity and tier, with the upgrade flow completing visually after Stripe checkout redirect.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-tier-stripe-wiring/06-RESEARCH.md
@.planning/phases/06-tier-stripe-wiring/06-01-SUMMARY.md
@app/dashboard/layout.tsx
@app/dashboard/page.tsx
@app/dashboard/settings/page.tsx
@lib/context/tier-context.tsx
@lib/constants.ts
@lib/stripe/config.ts
@lib/stripe/client.ts
@lib/supabase/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace hardcoded mock in dashboard layout with real user data and tier from context</name>
  <files>
    app/dashboard/layout.tsx
  </files>
  <action>
    The dashboard layout.tsx currently has a hardcoded mock user on line 140-144:
    ```
    const user = { name: "Fred Cary", email: "founder@startup.com", tier: 0 };
    ```
    This drives the sidebar user profile, tier badge, nav locking, and upgrade banner.

    Replace with real data:

    1. Add imports at top:
       - `import { useTier } from "@/lib/context/tier-context";`
       - `import { createClient } from "@/lib/supabase/client";`
       - `import { useEffect } from "react";` (already imported? useState is imported but not useEffect -- add it)

    2. Inside DashboardLayout component, replace the hardcoded user with:
       ```typescript
       const { tier, tierName, isLoading: tierLoading } = useTier();
       const [userInfo, setUserInfo] = useState<{ name: string; email: string } | null>(null);

       useEffect(() => {
         async function fetchUser() {
           const supabase = createClient();
           const { data: { user: authUser } } = await supabase.auth.getUser();
           if (authUser) {
             const { data: profile } = await supabase
               .from("profiles")
               .select("name")
               .eq("id", authUser.id)
               .single();
             setUserInfo({
               name: profile?.name || authUser.email?.split("@")[0] || "Founder",
               email: authUser.email || "",
             });
           }
         }
         fetchUser();
       }, []);

       const user = {
         name: userInfo?.name || "Loading...",
         email: userInfo?.email || "",
         tier: tier, // From TierProvider context, not hardcoded 0
       };
       ```

    3. The existing tierNames array ["Free", "Pro", "Studio"] and tierColors array can stay -- they use user.tier as index which now comes from context.

    4. The existing nav locking logic `item.tier !== undefined && user.tier < item.tier` will now work correctly because user.tier is real.

    5. The UpgradeBanner `currentTier={user.tier as UserTier}` will now receive the real tier.

    6. Keep the existing SidebarContent structure exactly as-is -- only the data source changes, not the UI.

    IMPORTANT: Do NOT change the navItems array or any styling. Only change where user data comes from.
  </action>
  <verify>
    1. Grep layout.tsx for "Fred Cary" -- should NOT appear.
    2. Grep layout.tsx for "useTier" -- should appear.
    3. Grep layout.tsx for "founder@startup.com" -- should NOT appear.
    4. Run `npx tsc --noEmit 2>&1 | grep "layout.tsx"` -- should have no errors.
  </verify>
  <done>
    Dashboard sidebar displays real user name/email from Supabase auth and real tier from TierProvider context. Nav locking and upgrade banner respond to actual subscription status.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix dashboard page tier source and add post-checkout success handling</name>
  <files>
    app/dashboard/page.tsx
  </files>
  <action>
    The dashboard page currently reads tier from `profiles.tier` (line 62: `const tier = profile?.tier || 0`), which is never updated by Stripe webhooks. It also ignores `?success=true&tier=X` query params from Stripe checkout redirect.

    Fix both issues:

    1. Add imports:
       - `import { useTier } from "@/lib/context/tier-context";`
       - `import { toast } from "sonner";` (sonner is installed -- used elsewhere in the app)

    2. Inside DashboardPage, add useTier():
       ```typescript
       const { tier: contextTier, refresh: refreshTier, isLoading: tierLoading } = useTier();
       ```

    3. Modify the existing getUserData useEffect:
       - Keep the Supabase auth check and profile fetch for name/email
       - REMOVE the tier derivation from profiles.tier (delete `const tier = profile?.tier || 0;`)
       - Set user state WITHOUT tier: `setUser({ name: ..., email: ..., tier: contextTier });`
       - Actually, better approach: change the user state type to omit tier. The component should read tier from useTier() everywhere. But to minimize changes to the existing JSX that reads `user.tier`, keep the user object but set tier from contextTier.
       - Update the user state setting to use contextTier instead of profile?.tier.

    4. Add a useEffect to keep user.tier in sync with contextTier:
       ```typescript
       useEffect(() => {
         if (user) {
           setUser(prev => prev ? { ...prev, tier: contextTier } : prev);
         }
       }, [contextTier]);
       ```

    5. Add post-checkout success handling -- new useEffect:
       ```typescript
       useEffect(() => {
         const isSuccess = searchParams.get("success") === "true";
         if (isSuccess) {
           // Poll for tier update (webhook may not have processed yet)
           let attempts = 0;
           const pollInterval = setInterval(async () => {
             attempts++;
             await refreshTier();
             if (attempts >= 5) {
               clearInterval(pollInterval);
             }
           }, 2000);

           toast.success("Payment successful! Your plan has been upgraded.");
           // Clean up URL
           router.replace("/dashboard", { scroll: false });

           return () => clearInterval(pollInterval);
         }
       }, [searchParams, router, refreshTier]);
       ```
       Note: This is separate from the existing welcome modal useEffect. The welcome handler checks `?welcome=true`, this checks `?success=true`. Keep both.

    6. The existing stats, quickActions, and upgrade CTA all use `user.tier` which will now be correct.

    IMPORTANT: Keep the existing welcome modal logic unchanged. Keep all UI/styling unchanged. Only change data sources and add success handling.
  </action>
  <verify>
    1. Grep page.tsx for "profile?.tier" -- should NOT appear.
    2. Grep page.tsx for "useTier" -- should appear.
    3. Grep page.tsx for "success.*true" -- should appear (checkout success handling).
    4. Grep page.tsx for "toast.success" -- should appear.
    5. Run `npx tsc --noEmit 2>&1 | grep "dashboard/page.tsx"` -- should have no errors.
  </verify>
  <done>
    Dashboard page reads tier from TierProvider (not profiles.tier). Post-Stripe checkout redirect triggers tier refresh polling + success toast. URL is cleaned of query params after processing.
  </done>
</task>

<task type="auto">
  <name>Task 3: Fix settings page to show real user data and subscription status</name>
  <files>
    app/dashboard/settings/page.tsx
  </files>
  <action>
    Settings page has hardcoded mock data on lines 22-27:
    ```
    const [profile, setProfile] = useState({ name: "Fred Cary", email: "founder@startup.com", company: "My Startup Inc." });
    const [currentPlan] = useState<"Free" | "Pro" | "Studio">("Free");
    ```
    Also has wrong plan prices ($49/$199 vs actual $99/$249) and generic feature lists.

    Fix:

    1. Add imports:
       - `import { useTier } from "@/lib/context/tier-context";`
       - `import { createClient } from "@/lib/supabase/client";`
       - `import { useEffect } from "react";` (if not already imported)
       - `import { PLANS } from "@/lib/stripe/config";`
       - `import { UserTier, TIER_NAMES, TIER_FEATURES } from "@/lib/constants";`
       - `import { redirectToPortal } from "@/lib/stripe/client";`

    2. Add hooks inside component:
       ```typescript
       const { tier, tierName, isSubscriptionActive, isLoading: tierLoading } = useTier();
       const [isProfileLoading, setIsProfileLoading] = useState(true);
       ```

    3. Add useEffect to fetch real profile data:
       ```typescript
       useEffect(() => {
         async function fetchProfile() {
           const supabase = createClient();
           const { data: { user: authUser } } = await supabase.auth.getUser();
           if (authUser) {
             const { data: profileData } = await supabase
               .from("profiles")
               .select("name, company_name")
               .eq("id", authUser.id)
               .single();
             setProfile({
               name: profileData?.name || authUser.email?.split("@")[0] || "",
               email: authUser.email || "",
               company: profileData?.company_name || "",
             });
           }
           setIsProfileLoading(false);
         }
         fetchProfile();
       }, []);
       ```

    4. Replace currentPlan usage:
       - Remove `const [currentPlan] = useState<"Free" | "Pro" | "Studio">("Free");`
       - Use `tierName` from useTier() wherever `currentPlan` was used.
       - Replace the hardcoded planPrices object with:
         ```typescript
         const planPrice = tier === UserTier.STUDIO ? "$249/month"
           : tier === UserTier.PRO ? "$99/month"
           : "$0/month";
         ```
       - Replace planFeatures usage with `TIER_FEATURES[tier]` from constants.

    5. Wire the "Manage Subscription" button to `redirectToPortal()`:
       ```typescript
       const [portalLoading, setPortalLoading] = useState(false);
       const handleManageSubscription = async () => {
         try {
           setPortalLoading(true);
           await redirectToPortal();
         } catch (err) {
           console.error("Portal error:", err);
         } finally {
           setPortalLoading(false);
         }
       };
       ```
       Wire the "Manage Subscription" button's onClick to handleManageSubscription.

    6. Wire the "Upgrade Plan" button -- use the UpgradeTier component that already exists:
       - Import UpgradeTier from "@/components/dashboard/UpgradeTier"
       - Replace the static "Upgrade Plan" button with `<UpgradeTier currentTier={tier} isSubscriptionActive={isSubscriptionActive} />`

    7. Fix Avatar initials to use real name:
       - Change hardcoded "FC" to `profile.name.split(" ").map(n => n[0]).join("").toUpperCase() || "?"`.

    IMPORTANT: Keep the Notification Settings section, General Notifications section, and Danger Zone section unchanged. Only fix the Profile and Subscription sections.
  </action>
  <verify>
    1. Grep settings/page.tsx for "Fred Cary" -- should NOT appear.
    2. Grep settings/page.tsx for "founder@startup.com" -- should NOT appear.
    3. Grep settings/page.tsx for "useTier" -- should appear.
    4. Grep settings/page.tsx for "$49" -- should NOT appear (was wrong price).
    5. Grep settings/page.tsx for "redirectToPortal" -- should appear.
    6. Run `npx tsc --noEmit 2>&1 | grep "settings/page.tsx"` -- should have no errors.
  </verify>
  <done>
    Settings page displays real user name/email/company from Supabase, real tier from TierProvider, correct plan pricing, and functional "Manage Subscription" (Stripe portal) and "Upgrade Plan" (UpgradeTier component) buttons.
  </done>
</task>

</tasks>

<verification>
1. No hardcoded "Fred Cary" or "founder@startup.com" in any dashboard file
2. All three files import and use useTier() from tier-context
3. Dashboard page handles ?success=true with tier refresh and toast
4. Settings page wires to Stripe portal for subscription management
5. TypeScript compilation succeeds for all modified files
6. Nav locking in sidebar responds to real tier value
</verification>

<success_criteria>
- Dashboard sidebar shows real user identity and real tier badge
- Dashboard overview page uses tier from context (not profiles.tier)
- Post-Stripe checkout triggers tier refresh polling + success toast
- Settings page shows real subscription data with working Manage/Upgrade buttons
- No hardcoded mock user data remains in any modified file
- All three consumer pages correctly respond to tier changes from TierProvider
</success_criteria>

<output>
After completion, create `.planning/phases/06-tier-stripe-wiring/06-02-SUMMARY.md`
</output>
