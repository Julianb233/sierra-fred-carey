---
phase: 06-tier-stripe-wiring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/db/migrations/033_user_subscriptions.sql
  - lib/db/migrations/034_stripe_events.sql
  - app/providers.tsx
  - lib/context/tier-context.tsx
  - lib/api/tier-middleware.ts
autonomous: true

must_haves:
  truths:
    - "TierProvider is mounted in the component tree so useTier() does not throw"
    - "tier-context.tsx reads data.plan.id and data.isActive from API (not data.subscriptionStatus/data.planId)"
    - "Server-side tier middleware queries user_subscriptions table (not subscriptions)"
    - "Migrations exist for user_subscriptions and stripe_events tables"
  artifacts:
    - path: "lib/db/migrations/033_user_subscriptions.sql"
      provides: "user_subscriptions table with user_id, stripe_customer_id, stripe_subscription_id, stripe_price_id, status, period dates"
      contains: "CREATE TABLE IF NOT EXISTS user_subscriptions"
    - path: "lib/db/migrations/034_stripe_events.sql"
      provides: "stripe_events table for webhook idempotency"
      contains: "CREATE TABLE IF NOT EXISTS stripe_events"
    - path: "app/providers.tsx"
      provides: "TierProvider mounted wrapping children"
      contains: "TierProvider"
    - path: "lib/context/tier-context.tsx"
      provides: "Fixed fetchTier reading data.plan.id and data.isActive"
      contains: "data.plan"
    - path: "lib/api/tier-middleware.ts"
      provides: "getUserTier querying user_subscriptions with getPlanByPriceId"
      contains: "user_subscriptions"
  key_links:
    - from: "app/providers.tsx"
      to: "lib/context/tier-context.tsx"
      via: "import TierProvider"
      pattern: "import.*TierProvider.*tier-context"
    - from: "lib/context/tier-context.tsx"
      to: "/api/user/subscription"
      via: "fetch in fetchTier"
      pattern: "data\\.plan"
    - from: "lib/api/tier-middleware.ts"
      to: "lib/db/subscriptions.ts"
      via: "getUserSubscription import or user_subscriptions query"
      pattern: "user_subscriptions"
---

<objective>
Fix the tier infrastructure foundation: mount TierProvider, align API response consumption, fix server-side tier table reference, and ensure database tables exist.

Purpose: Without these fixes, client-side tier detection always returns FREE (TierProvider not mounted, response shape mismatch), and server-side tier gating queries a non-existent "subscriptions" table. This plan establishes the working infrastructure that Plan 02 consumer components depend on.

Output: Working TierProvider in component tree, correct tier derivation from subscription API, server-side tier middleware querying the right table, and migration files for user_subscriptions + stripe_events.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-tier-stripe-wiring/06-RESEARCH.md
@lib/context/tier-context.tsx
@app/providers.tsx
@lib/api/tier-middleware.ts
@app/api/user/subscription/route.ts
@lib/db/subscriptions.ts
@lib/stripe/config.ts
@lib/constants.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database migrations for user_subscriptions and stripe_events</name>
  <files>
    lib/db/migrations/033_user_subscriptions.sql
    lib/db/migrations/034_stripe_events.sql
  </files>
  <action>
    Create migration 033_user_subscriptions.sql:
    - CREATE TABLE IF NOT EXISTS user_subscriptions with columns matching what lib/db/subscriptions.ts expects:
      - id UUID DEFAULT gen_random_uuid() PRIMARY KEY
      - user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE
      - stripe_customer_id TEXT NOT NULL
      - stripe_subscription_id TEXT
      - stripe_price_id TEXT NOT NULL
      - status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active','canceled','past_due','trialing','unpaid'))
      - current_period_start TIMESTAMPTZ
      - current_period_end TIMESTAMPTZ
      - canceled_at TIMESTAMPTZ
      - cancel_at_period_end BOOLEAN DEFAULT false
      - trial_start TIMESTAMPTZ
      - trial_end TIMESTAMPTZ
      - created_at TIMESTAMPTZ DEFAULT now()
      - updated_at TIMESTAMPTZ DEFAULT now()
    - Add UNIQUE constraint on user_id (the ON CONFLICT (user_id) in lib/db/subscriptions.ts requires this)
    - Add index on stripe_customer_id for webhook lookups
    - Add index on stripe_subscription_id
    - Enable RLS and add policies: service_role can do everything, authenticated users can SELECT their own row

    Create migration 034_stripe_events.sql:
    - CREATE TABLE IF NOT EXISTS stripe_events with columns:
      - id UUID DEFAULT gen_random_uuid() PRIMARY KEY
      - stripe_event_id TEXT NOT NULL UNIQUE
      - stripe_customer_id TEXT
      - type TEXT NOT NULL
      - status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('processed','pending','failed'))
      - payload JSONB DEFAULT '{}'
      - error TEXT
      - created_at TIMESTAMPTZ DEFAULT now()
      - processed_at TIMESTAMPTZ
    - Add index on stripe_event_id for idempotency checks
    - Add index on type for filtering
    - Enable RLS, service_role full access policy
  </action>
  <verify>
    Both migration files exist and contain valid SQL. Verify with: check that the column names match what lib/db/subscriptions.ts references (snake_case: user_id, stripe_customer_id, stripe_subscription_id, stripe_price_id, status, current_period_start, current_period_end, canceled_at, cancel_at_period_end, trial_start, trial_end, created_at, updated_at for user_subscriptions; stripe_event_id, stripe_customer_id, type, status, payload, error, created_at, processed_at for stripe_events).
  </verify>
  <done>
    Migration files exist at lib/db/migrations/033_user_subscriptions.sql and 034_stripe_events.sql with all columns matching the TypeScript interfaces in lib/db/subscriptions.ts. UNIQUE constraint on user_id enables the ON CONFLICT upsert pattern.
  </done>
</task>

<task type="auto">
  <name>Task 2: Mount TierProvider and fix tier-context response shape + tier-middleware table name</name>
  <files>
    app/providers.tsx
    lib/context/tier-context.tsx
    lib/api/tier-middleware.ts
  </files>
  <action>
    **Fix 1: app/providers.tsx**
    - Import TierProvider from "@/lib/context/tier-context"
    - Wrap children with TierProvider INSIDE ThemeProvider:
      ```
      <NextThemesProvider ...>
        <TierProvider>
          {children}
        </TierProvider>
      </NextThemesProvider>
      ```
    - This enables useTier() to work in any component under Providers.

    **Fix 2: lib/context/tier-context.tsx -- TierProvider.fetchTier()**
    - The API /api/user/subscription returns: { plan: { id, name, price, priceId, features }, subscription: { status, currentPeriodEnd, cancelAtPeriodEnd } | null, isActive: boolean }
    - Current code reads data.subscriptionStatus (UNDEFINED) and data.planId (UNDEFINED). Fix to:
      ```
      const data = await response.json();
      if (data.isActive && data.subscription?.status === "active" || data.subscription?.status === "trialing") {
        setIsSubscriptionActive(true);
        // Use getTierFromString which already maps "fundraising"->PRO, "venture_studio"->STUDIO
        setTier(getTierFromString(data.plan?.id || "free"));
      } else {
        setTier(UserTier.FREE);
        setIsSubscriptionActive(false);
      }
      ```
    - Import getTierFromString from "@/lib/constants" (add to existing import).
    - ALSO fix the standalone useUserTier() hook (lines 164-221) with the SAME fix -- it has identical broken code reading data.subscriptionStatus and data.planId. Apply the same fix using data.isActive, data.subscription?.status, and getTierFromString(data.plan?.id).
    - Keep the TierProvider's refresh() function working (it's just fetchTier bound as a callback, which is already correct).

    **Fix 3: lib/api/tier-middleware.ts -- getUserTier()**
    - Current code queries .from("subscriptions") with .select("status, price_id, products(name)") -- this table does not exist.
    - Replace the entire getUserTier function body to use getUserSubscription from lib/db/subscriptions.ts and getPlanByPriceId + getTierFromString from existing modules:
      ```
      import { getUserSubscription } from "@/lib/db/subscriptions";
      import { getPlanByPriceId } from "@/lib/stripe/config";
      import { getTierFromString } from "@/lib/constants";

      export async function getUserTier(userId: string): Promise<UserTier> {
        try {
          const subscription = await getUserSubscription(userId);
          if (!subscription || !["active", "trialing"].includes(subscription.status)) {
            return UserTier.FREE;
          }
          const plan = getPlanByPriceId(subscription.stripePriceId);
          if (!plan) return UserTier.FREE;
          return getTierFromString(plan.id);
        } catch (error) {
          console.error("[TierMiddleware] Error fetching user tier:", error);
          return UserTier.FREE;
        }
      }
      ```
    - Remove the import of createServiceClient since getUserTier no longer needs it directly (BUT keep it for the requireTier middleware and other functions that use supabase.auth.getUser()). Only remove createServiceClient if no other function in the file uses it -- check first. The requireTier function at line 137 uses createServiceClient, so KEEP the import.
    - Remove getPlanByPriceId import if added -- wait, we need it. Add imports for getUserSubscription from "@/lib/db/subscriptions" and getPlanByPriceId from "@/lib/stripe/config" and getTierFromString from "@/lib/constants".
  </action>
  <verify>
    1. Run `npx tsc --noEmit 2>&1 | head -30` to check for TypeScript errors in modified files.
    2. Verify providers.tsx contains "TierProvider" import and wraps children.
    3. Verify tier-context.tsx fetchTier reads data.plan?.id (not data.planId) and data.isActive (not data.subscriptionStatus).
    4. Verify tier-middleware.ts getUserTier uses getUserSubscription (not .from("subscriptions")).
    5. Verify the standalone useUserTier hook also has the fixed response shape reading.
  </verify>
  <done>
    - TierProvider mounted in providers.tsx -- useTier() no longer throws
    - tier-context.tsx TierProvider AND useUserTier both read correct API response shape (data.plan.id, data.isActive)
    - tier-middleware.ts queries user_subscriptions via getUserSubscription (not non-existent "subscriptions" table)
    - All imports resolve correctly, no TypeScript errors
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation succeeds: `npx tsc --noEmit` passes without errors in modified files
2. providers.tsx wraps children with TierProvider inside ThemeProvider
3. tier-context.tsx reads data.plan?.id and data.isActive (not data.subscriptionStatus, data.planId)
4. tier-middleware.ts references "user_subscriptions" (not "subscriptions")
5. Both migration files exist with correct column schemas
6. No duplicate imports or broken references
</verification>

<success_criteria>
- TierProvider is in the component tree (useTier() will not throw at runtime)
- tier-context.tsx correctly maps API response to UserTier enum using getTierFromString
- tier-middleware.ts server-side tier check queries the correct table
- Database migration files exist for user_subscriptions and stripe_events
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-tier-stripe-wiring/06-01-SUMMARY.md`
</output>
