---
phase: 16-red-flag-detection
plan: 01
type: execute
wave: 2
depends_on:
  - 13-voice-core-ai-engines
files_modified:
  - lib/fred/types.ts
  - lib/fred/risks/detection-engine.ts
  - lib/db/migrations/036_red_flags.sql
  - lib/db/red-flags.ts
  - app/api/red-flags/route.ts
  - app/api/red-flags/[id]/route.ts
  - lib/fred/actors/synthesize.ts
  - app/api/fred/chat/route.ts
  - components/chat/red-flag-badge.tsx
  - components/chat/chat-message.tsx
  - lib/hooks/use-fred-chat.ts
  - components/dashboard/red-flags-widget.tsx
  - app/dashboard/page.tsx
autonomous: true

must_haves:
  truths:
    - "RedFlag, RedFlagCategory, Severity, and FlagStatus types are exported from lib/fred/types.ts"
    - "Detection engine analyzes SynthesisResult to extract business risks with category, severity, and description"
    - "fred_red_flags table stores flags per user with category, severity, status, source_message_id, and timestamps"
    - "CRUD API at /api/red-flags supports GET (list by user), POST (create), PATCH (update status), DELETE"
    - "synthesize.ts actor calls detection engine after risk extraction to produce structured RedFlag objects"
    - "Chat route persists detected flags to the database and emits them via SSE red_flag events"
    - "Inline red-flag-badge component renders warning indicators in chat messages containing risks"
    - "Dashboard widget displays a summary of current red flags grouped by severity"
  artifacts:
    - path: "lib/fred/types.ts"
      provides: "RedFlag, RedFlagCategory, Severity, FlagStatus type definitions"
      contains: "RedFlag"
    - path: "lib/fred/risks/detection-engine.ts"
      provides: "detectRedFlags() function that analyzes synthesis output for business risks"
      exports: ["detectRedFlags"]
    - path: "lib/db/migrations/036_red_flags.sql"
      provides: "fred_red_flags table with RLS policies"
    - path: "lib/db/red-flags.ts"
      provides: "CRUD operations for red flags (getRedFlags, createRedFlag, updateRedFlag, deleteRedFlag)"
      exports: ["getRedFlags", "createRedFlag", "updateRedFlag", "deleteRedFlag"]
    - path: "app/api/red-flags/route.ts"
      provides: "GET list and POST create endpoints for red flags"
    - path: "app/api/red-flags/[id]/route.ts"
      provides: "PATCH update and DELETE endpoints for individual red flags"
    - path: "components/chat/red-flag-badge.tsx"
      provides: "Inline warning badge component for chat messages"
      exports: ["RedFlagBadge"]
    - path: "components/dashboard/red-flags-widget.tsx"
      provides: "Dashboard widget showing red flag summary"
      exports: ["RedFlagsWidget"]
  key_links:
    - from: "lib/fred/risks/detection-engine.ts"
      to: "lib/fred/types.ts"
      via: "imports RedFlag, RedFlagCategory, Severity types"
      pattern: "import.*RedFlag.*from.*types"
    - from: "lib/fred/actors/synthesize.ts"
      to: "lib/fred/risks/detection-engine.ts"
      via: "calls detectRedFlags() after risk extraction"
      pattern: "detectRedFlags"
    - from: "app/api/fred/chat/route.ts"
      to: "lib/db/red-flags.ts"
      via: "persists detected flags via createRedFlag()"
      pattern: "createRedFlag"
    - from: "components/chat/chat-message.tsx"
      to: "components/chat/red-flag-badge.tsx"
      via: "renders RedFlagBadge when message has associated risks"
      pattern: "RedFlagBadge"
    - from: "app/dashboard/page.tsx"
      to: "components/dashboard/red-flags-widget.tsx"
      via: "renders RedFlagsWidget in dashboard grid"
      pattern: "RedFlagsWidget"
---

<objective>
Build the red flag detection engine, database persistence, chat integration, and dashboard widget so FRED identifies business risks during conversations and surfaces them persistently for founders to track and address.

Purpose: FRED currently extracts risks in the synthesize actor but does not classify, persist, or surface them to the user in a structured way. This plan adds a detection engine that categorizes risks (market, financial, team, product, legal, competitive), stores them in the database, emits them via SSE during chat, renders inline warning badges in chat messages, and provides a dashboard widget for at-a-glance risk visibility.

Output: 5 new files (detection engine, migration, DB layer, badge component, widget component), 5 modified files (types, synthesize actor, chat route, chat message, use-fred-chat hook, dashboard page). No new npm dependencies.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

Key source files (READ ALL BEFORE MODIFYING):
@lib/fred/types.ts (existing FRED type definitions -- add new types here)
@lib/fred/actors/synthesize.ts (identifyRisks() function extracts risks -- wire detection after this)
@app/api/fred/chat/route.ts (SSE streaming endpoint -- add red_flag event emission)
@lib/hooks/use-fred-chat.ts (client-side SSE handler -- add red_flag event handling)
@components/chat/chat-message.tsx (message rendering -- add RedFlagBadge integration)
@app/dashboard/page.tsx (dashboard layout -- add RedFlagsWidget)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Types, database schema, and CRUD API</name>
  <files>
    lib/fred/types.ts
    lib/db/migrations/036_red_flags.sql
    lib/db/red-flags.ts
    app/api/red-flags/route.ts
    app/api/red-flags/[id]/route.ts
  </files>
  <action>
**Step 1: Add types to `lib/fred/types.ts`**

Add the following type definitions at the end of the file (do NOT modify existing types):

```typescript
// Red Flag Detection Types
export type RedFlagCategory = "market" | "financial" | "team" | "product" | "legal" | "competitive";
export type Severity = "low" | "medium" | "high" | "critical";
export type FlagStatus = "active" | "acknowledged" | "resolved" | "dismissed";

export interface RedFlag {
  id?: string;
  userId: string;
  category: RedFlagCategory;
  severity: Severity;
  title: string;
  description: string;
  status: FlagStatus;
  sourceMessageId?: string;
  detectedAt: string;
  resolvedAt?: string;
}
```

**Step 2: Create migration `lib/db/migrations/036_red_flags.sql`**

Create the fred_red_flags table with columns matching the RedFlag interface:
- id (uuid, PK, default gen_random_uuid())
- user_id (uuid, references auth.users, NOT NULL)
- category (text, NOT NULL, CHECK against valid categories)
- severity (text, NOT NULL, CHECK against valid severities)
- title (text, NOT NULL)
- description (text, NOT NULL)
- status (text, NOT NULL, default 'active', CHECK against valid statuses)
- source_message_id (uuid, nullable)
- detected_at (timestamptz, default now())
- resolved_at (timestamptz, nullable)
- created_at (timestamptz, default now())
- updated_at (timestamptz, default now())

Add index on (user_id, status) for efficient dashboard queries.
Add RLS policy: users can only SELECT/INSERT/UPDATE/DELETE their own rows.

**Step 3: Create `lib/db/red-flags.ts`**

Create CRUD operations using Supabase client:
- `getRedFlags(userId: string, status?: FlagStatus): Promise<RedFlag[]>` -- list flags, optionally filtered by status, ordered by severity desc then detected_at desc
- `createRedFlag(flag: Omit<RedFlag, 'id' | 'detectedAt'>): Promise<RedFlag>` -- insert new flag
- `updateRedFlag(id: string, userId: string, updates: Partial<Pick<RedFlag, 'status' | 'resolvedAt'>>): Promise<RedFlag>` -- update status
- `deleteRedFlag(id: string, userId: string): Promise<void>` -- soft or hard delete

Import createServerClient from `@/lib/supabase/server` for all operations. Map snake_case DB columns to camelCase TypeScript properties.

**Step 4: Create `app/api/red-flags/route.ts`**

- GET: Authenticate user, call getRedFlags(userId), return JSON array. Accept optional `status` query param.
- POST: Authenticate user, validate body (category, severity, title, description required), call createRedFlag(), return 201 with created flag.

**Step 5: Create `app/api/red-flags/[id]/route.ts`**

- PATCH: Authenticate user, validate body (status required), call updateRedFlag(). If status is 'resolved', set resolvedAt to new Date().toISOString(). Return updated flag.
- DELETE: Authenticate user, call deleteRedFlag(). Return 204.

Both routes should return 401 if not authenticated, 404 if flag not found.
  </action>
  <verify>
1. `grep 'RedFlagCategory\|RedFlag\|Severity\|FlagStatus' lib/fred/types.ts` -- all types present
2. `test -f lib/db/migrations/036_red_flags.sql` -- migration exists
3. `grep 'fred_red_flags' lib/db/migrations/036_red_flags.sql` -- table name correct
4. `grep 'getRedFlags\|createRedFlag\|updateRedFlag\|deleteRedFlag' lib/db/red-flags.ts` -- all CRUD exports present
5. `test -f app/api/red-flags/route.ts && test -f 'app/api/red-flags/[id]/route.ts'` -- both API routes exist
6. `npx tsc --noEmit` passes with no errors
  </verify>
  <done>
Types added to lib/fred/types.ts (RedFlag, RedFlagCategory, Severity, FlagStatus). Migration 036 creates fred_red_flags table with RLS. CRUD layer in lib/db/red-flags.ts exports 4 functions. API routes handle GET/POST at /api/red-flags and PATCH/DELETE at /api/red-flags/[id].
  </done>
</task>

<task type="auto">
  <name>Task 2: Detection engine and chat integration</name>
  <files>
    lib/fred/risks/detection-engine.ts
    lib/fred/actors/synthesize.ts
    app/api/fred/chat/route.ts
  </files>
  <action>
**Step 1: Create `lib/fred/risks/detection-engine.ts`**

Create the detection engine that analyzes synthesis output for business risks.

```typescript
import { RedFlag, RedFlagCategory, Severity } from "@/lib/fred/types";
```

Export a `detectRedFlags(synthesis: SynthesisResult, userId: string): RedFlag[]` function that:
1. Reads `synthesis.risks` array (already extracted by identifyRisks() in synthesize.ts)
2. For each risk, classify into a RedFlagCategory using keyword matching on risk.description:
   - "market" keywords: market, demand, customer, competition, TAM, segment
   - "financial" keywords: burn, runway, revenue, cash, funding, capital, cost
   - "team" keywords: team, hire, founder, talent, leadership, capacity
   - "product" keywords: product, tech, technical, feature, MVP, scale, architecture
   - "legal" keywords: legal, compliance, regulation, IP, patent, liability
   - "competitive" keywords: competitor, moat, differentiation, substitute
   - Default: "market" if no keywords match
3. Determine severity based on the risk's impact score (if available from synthesis.factors):
   - composite < 30: "critical"
   - composite < 50: "high"
   - composite < 70: "medium"
   - composite >= 70: "low"
4. Return array of RedFlag objects with status "active" and detectedAt set to new Date().toISOString()

Also export a `categorizeRisk(description: string): RedFlagCategory` helper for reuse.

**Step 2: Wire detection into `lib/fred/actors/synthesize.ts`**

Import `detectRedFlags` from `@/lib/fred/risks/detection-engine`. After the `identifyRisks()` call in the synthesizeActor function, call `detectRedFlags(result, input.userId)` and attach the returned flags to the SynthesisResult. Add a `redFlags?: RedFlag[]` field to the return type or attach to a new property on the result object.

IMPORTANT: Do NOT modify any scoring logic, factor calculations, or existing return fields. Only ADD the redFlags property.

**Step 3: Wire SSE emission in `app/api/fred/chat/route.ts`**

After the synthesis step completes and before the decide step:
1. Check if `synthesisResult.redFlags` has any items
2. If yes, persist each flag via `createRedFlag()` from `lib/db/red-flags.ts`
3. Emit an SSE event `red_flag` with the array of persisted flags (including their DB-generated IDs)
4. Format: `data: ${JSON.stringify({ type: "red_flag", flags: persistedFlags })}\n\n`

Import `createRedFlag` from `@/lib/db/red-flags`.
  </action>
  <verify>
1. `test -f lib/fred/risks/detection-engine.ts` -- engine exists
2. `grep 'detectRedFlags' lib/fred/risks/detection-engine.ts` -- function exported
3. `grep 'detectRedFlags' lib/fred/actors/synthesize.ts` -- wired into synthesis
4. `grep 'red_flag' app/api/fred/chat/route.ts` -- SSE event emitted
5. `grep 'createRedFlag' app/api/fred/chat/route.ts` -- persistence wired
6. `npx tsc --noEmit` passes with no errors
  </verify>
  <done>
Detection engine at lib/fred/risks/detection-engine.ts classifies risks by category and severity. Synthesize actor calls detectRedFlags() after risk extraction. Chat route persists flags and emits red_flag SSE events.
  </done>
</task>

<task type="auto">
  <name>Task 3: UI components (chat badge, chat message integration, dashboard widget)</name>
  <files>
    components/chat/red-flag-badge.tsx
    components/chat/chat-message.tsx
    lib/hooks/use-fred-chat.ts
    components/dashboard/red-flags-widget.tsx
    app/dashboard/page.tsx
  </files>
  <action>
**Step 1: Create `components/chat/red-flag-badge.tsx`**

"use client" component that renders an inline warning indicator:
- Props: `{ category: RedFlagCategory; severity: Severity; title: string }`
- Renders a small pill/badge with:
  - Color coded by severity: critical = red-500, high = orange-500, medium = yellow-500, low = blue-500
  - Icon: AlertTriangle from lucide-react (or inline SVG)
  - Text: truncated title (max 40 chars)
  - Tooltip or title attribute showing full description
- Compact size: `inline-flex items-center gap-1 px-2 py-0.5 rounded-full text-xs`

**Step 2: Update `components/chat/chat-message.tsx`**

Add an optional `risks` prop (array of RedFlag objects) to the message component. When risks are present and non-empty, render RedFlagBadge components below the message content in a flex-wrap container. Import RedFlagBadge from `./red-flag-badge`.

IMPORTANT: Do NOT change any existing message rendering logic, styling, or props. Only ADD the optional risks prop and conditional rendering block.

**Step 3: Update `lib/hooks/use-fred-chat.ts`**

Add handling for the `red_flag` SSE event type:
- Parse the event data to extract the flags array
- Store flags in a new state variable: `const [redFlags, setRedFlags] = useState<RedFlag[]>([])`
- On receiving a red_flag event, append the new flags to the existing array
- Associate flags with the current message ID so chat-message can receive them via the risks prop
- Export `redFlags` from the hook's return value

Import the RedFlag type from `@/lib/fred/types`.

**Step 4: Create `components/dashboard/red-flags-widget.tsx`**

"use client" component that fetches and displays red flags:
- On mount, fetch GET /api/red-flags?status=active
- Display a card with title "Risk Alerts" and a count badge
- List flags grouped by severity (critical first, then high, medium, low)
- Each flag shows: category icon/label, severity color dot, title, detected date
- "Acknowledge" button on each flag that PATCHes status to "acknowledged"
- Empty state: "No active risk flags detected" with a green checkmark
- Loading state: skeleton placeholders
- Error handling: catch fetch errors gracefully

**Step 5: Add widget to `app/dashboard/page.tsx`**

Import RedFlagsWidget from `@/components/dashboard/red-flags-widget`. Add it to the dashboard grid layout in an appropriate position (near the top, before or after existing widgets). Use responsive grid sizing consistent with other dashboard widgets.

IMPORTANT: Do NOT modify existing widget rendering or layout structure. Only ADD the new widget.
  </action>
  <verify>
1. `test -f components/chat/red-flag-badge.tsx` -- badge component exists
2. `grep 'risks' components/chat/chat-message.tsx` -- risks prop added
3. `grep 'red_flag' lib/hooks/use-fred-chat.ts` -- SSE event handled
4. `grep 'redFlags' lib/hooks/use-fred-chat.ts` -- state variable exported
5. `test -f components/dashboard/red-flags-widget.tsx` -- widget exists
6. `grep 'RedFlagsWidget' app/dashboard/page.tsx` -- widget integrated
7. `npx tsc --noEmit` passes with no errors
  </verify>
  <done>
RedFlagBadge renders inline severity-coded warning indicators in chat messages. use-fred-chat hook handles red_flag SSE events and exposes redFlags state. RedFlagsWidget dashboard card fetches active flags and displays them grouped by severity with acknowledge action. Dashboard page includes the widget.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Types exist and compile:**
   ```bash
   grep -c 'RedFlag\|RedFlagCategory\|Severity\|FlagStatus' lib/fred/types.ts
   # Should be >= 4 (type definitions)
   ```

2. **Detection engine exists:**
   ```bash
   grep 'export.*detectRedFlags' lib/fred/risks/detection-engine.ts
   ```

3. **Database layer complete:**
   ```bash
   test -f lib/db/migrations/036_red_flags.sql && echo "EXISTS"
   grep -c 'export' lib/db/red-flags.ts
   # Should be >= 4 (CRUD functions)
   ```

4. **API routes exist:**
   ```bash
   test -f app/api/red-flags/route.ts && test -f 'app/api/red-flags/[id]/route.ts' && echo "EXISTS"
   ```

5. **Chat integration wired:**
   ```bash
   grep 'red_flag' app/api/fred/chat/route.ts lib/hooks/use-fred-chat.ts
   ```

6. **UI components exist:**
   ```bash
   test -f components/chat/red-flag-badge.tsx && test -f components/dashboard/red-flags-widget.tsx && echo "EXISTS"
   ```

7. **Dashboard widget integrated:**
   ```bash
   grep 'RedFlagsWidget' app/dashboard/page.tsx
   ```

8. **TypeScript compiles:**
   ```bash
   npx tsc --noEmit
   ```
</verification>

<success_criteria>
- RedFlag, RedFlagCategory, Severity, FlagStatus types exported from lib/fred/types.ts
- Detection engine classifies synthesis risks into 6 categories with 4 severity levels
- fred_red_flags table created with proper RLS and indexing
- CRUD API supports listing, creating, updating status, and deleting flags
- Synthesize actor produces RedFlag objects from extracted risks
- Chat route persists flags to DB and emits red_flag SSE events
- Chat messages display inline RedFlagBadge indicators for flagged risks
- Dashboard widget shows active red flags grouped by severity
- All existing scoring logic, chat rendering, and dashboard widgets remain unchanged
- TypeScript compiles with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/16-red-flag-detection/16-01-SUMMARY.md`
</output>
