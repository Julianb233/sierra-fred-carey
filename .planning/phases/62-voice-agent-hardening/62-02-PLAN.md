---
phase: 62-voice-agent-hardening
plan: 02
type: execute
wave: 2
depends_on: ['01']
files_modified:
  - app/api/fred/call/route.ts
  - app/api/fred/call/summary/route.ts
  - app/api/livekit/webhook/route.ts
  - lib/db/migrations/062_call_recording_columns.sql
autonomous: false
user_setup:
  - service: livekit-cloud
    why: "Call recording via Egress requires LiveKit Cloud egress service enabled"
    dashboard_config:
      - task: "Verify egress is available in your LiveKit Cloud project"
        location: "LiveKit Cloud Dashboard -> Project Settings"
  - service: supabase-storage
    why: "Audio recordings stored in S3-compatible storage"
    env_vars:
      - name: RECORDING_S3_ACCESS_KEY
        source: "Supabase Dashboard -> Settings -> Storage, or AWS S3 credentials"
      - name: RECORDING_S3_SECRET
        source: "Supabase Dashboard -> Settings -> Storage, or AWS S3 credentials"
      - name: RECORDING_S3_BUCKET
        source: "Create a bucket named 'voice-recordings' in Supabase Storage or S3"
      - name: RECORDING_S3_REGION
        source: "Same region as your Supabase project or S3 bucket"
      - name: RECORDING_S3_ENDPOINT
        source: "Supabase Storage S3 endpoint URL (if using Supabase), or omit for AWS S3"

must_haves:
  truths:
    - "Voice call recordings are captured as audio files and uploaded to cloud storage"
    - "Call transcript and summary are persisted in the database alongside the coaching session"
    - "Users can access their call recording URL after a call ends (populated by egress_ended webhook)"
    - "Summary endpoint rejects transcript arrays larger than 500 entries"
  artifacts:
    - path: "app/api/fred/call/route.ts"
      provides: "EgressClient recording start after room creation"
      contains: "EgressClient"
    - path: "app/api/fred/call/summary/route.ts"
      provides: "Transcript size limit and persistence to coaching_sessions"
      contains: "coaching_sessions"
    - path: "app/api/livekit/webhook/route.ts"
      provides: "egress_ended handler that stores recording_url"
      contains: "egress_ended"
    - path: "lib/db/migrations/062_call_recording_columns.sql"
      provides: "recording_url, transcript_json, summary columns on coaching_sessions"
      contains: "ALTER TABLE coaching_sessions"
  key_links:
    - from: "app/api/fred/call/route.ts"
      to: "livekit-server-sdk EgressClient"
      via: "startRoomCompositeEgress with audioOnly option"
      pattern: "startRoomCompositeEgress"
    - from: "app/api/livekit/webhook/route.ts"
      to: "supabase coaching_sessions.recording_url"
      via: "egress_ended webhook populates recording_url from EgressInfo file results"
      pattern: "egress_ended.*recording_url"
    - from: "app/api/fred/call/summary/route.ts"
      to: "supabase coaching_sessions"
      via: "update with transcript and summary"
      pattern: "coaching_sessions.*update"
---

<objective>
Add call recording via LiveKit Egress, persist transcripts/summaries, add transcript size limit, and handle egress_ended webhook to store the recording URL.

Purpose: Enable post-call playback and reliable transcript storage. Currently transcripts only exist in client memory and episodic memory -- if the user closes the browser, the transcript is lost. Recording and persistence complete the voice call lifecycle. The egress_ended webhook ensures recording_url is populated once LiveKit finishes uploading to S3.

Output: Call recording starts automatically when a voice call room is created, the recording URL is stored when egress completes, and transcript + summary are saved to the coaching_sessions table when the call ends. Transcript input is capped at 500 entries.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/62-voice-agent-hardening/62-RESEARCH.md
@.planning/phases/62-voice-agent-hardening/62-01-SUMMARY.md
@app/api/fred/call/route.ts
@app/api/fred/call/summary/route.ts
@app/api/livekit/webhook/route.ts
@lib/db/migrations/042_coaching_sessions.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add recording columns, start Egress recording, and add transcript size limit</name>
  <files>
    lib/db/migrations/062_call_recording_columns.sql
    app/api/fred/call/route.ts
    app/api/fred/call/summary/route.ts
  </files>
  <action>
**A. Create migration to add recording/transcript columns to coaching_sessions**

Create `lib/db/migrations/062_call_recording_columns.sql`:

```sql
-- ============================================================================
-- Migration 062: Call Recording & Transcript Columns
-- Phase 62: Voice Agent Production Hardening
-- ============================================================================

-- Add recording and transcript columns to coaching_sessions
ALTER TABLE coaching_sessions
  ADD COLUMN IF NOT EXISTS recording_url TEXT,
  ADD COLUMN IF NOT EXISTS transcript_json JSONB,
  ADD COLUMN IF NOT EXISTS summary TEXT,
  ADD COLUMN IF NOT EXISTS decisions JSONB,
  ADD COLUMN IF NOT EXISTS next_actions JSONB,
  ADD COLUMN IF NOT EXISTS call_type TEXT DEFAULT 'on-demand'
    CHECK (call_type IN ('on-demand', 'scheduled'));

-- Add unique constraint on room_name for upsert operations
-- (may already exist from webhook handler, use IF NOT EXISTS pattern)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'coaching_sessions_room_name_unique'
  ) THEN
    ALTER TABLE coaching_sessions
      ADD CONSTRAINT coaching_sessions_room_name_unique UNIQUE (room_name);
  END IF;
END $$;
```

**B. Add EgressClient recording start to call route (app/api/fred/call/route.ts)**

All imports come from `livekit-server-sdk` (which re-exports from `@livekit/protocol`):

```typescript
import { EgressClient, EncodedFileOutput, EncodedFileType, S3Upload } from 'livekit-server-sdk';
```

After the room creation (after `await roomService.createRoom(...)` and its log), add egress recording start -- wrapped in a try/catch so recording failure does NOT block the call:

```typescript
// 1.5 Start audio-only recording via Egress (non-blocking)
let egressId: string | null = null;
const s3AccessKey = process.env.RECORDING_S3_ACCESS_KEY;
const s3Secret = process.env.RECORDING_S3_SECRET;
const s3Bucket = process.env.RECORDING_S3_BUCKET;
const s3Region = process.env.RECORDING_S3_REGION;

if (s3AccessKey && s3Secret && s3Bucket && s3Region) {
  try {
    const egressClient = new EgressClient(httpUrl, apiKey, apiSecret);

    const s3Output = new S3Upload({
      accessKey: s3AccessKey,
      secret: s3Secret,
      bucket: s3Bucket,
      region: s3Region,
      endpoint: process.env.RECORDING_S3_ENDPOINT || '',
      forcePathStyle: !!process.env.RECORDING_S3_ENDPOINT,
    });

    const fileOutput = new EncodedFileOutput({
      fileType: EncodedFileType.OGG,
      filepath: `voice-recordings/${roomName}.ogg`,
      output: {
        case: 's3' as const,
        value: s3Output,
      },
    });

    const egressInfo = await egressClient.startRoomCompositeEgress(
      roomName,
      fileOutput,
      { audioOnly: true }
    );
    egressId = egressInfo.egressId;
    console.log(`[Fred Call] Recording started: egress=${egressId}`);
  } catch (egressErr) {
    console.warn('[Fred Call] Recording start failed (call will proceed without recording):', egressErr);
  }
} else {
  console.log('[Fred Call] Recording skipped: S3 credentials not configured');
}
```

The API is confirmed from the actual `livekit-server-sdk` type definitions:
- `EgressClient` constructor: `(host: string, apiKey?: string, secret?: string)`
- `startRoomCompositeEgress(roomName: string, output: EncodedFileOutput, opts?: RoomCompositeOptions)` returns `Promise<EgressInfo>`
- `RoomCompositeOptions` has `audioOnly?: boolean`
- `EncodedFileOutput` constructor takes `PartialMessage<EncodedFileOutput>` with fields: `fileType: EncodedFileType`, `filepath: string`, `output: { case: 's3', value: S3Upload }`
- `S3Upload` constructor takes `PartialMessage<S3Upload>` with fields: `accessKey`, `secret`, `bucket`, `region`, `endpoint`, `forcePathStyle`
- `EgressInfo.egressId` is a string field

Include `egressId` in the response JSON (after the existing fields):
```typescript
return NextResponse.json({
  success: true,
  token,
  url: livekitUrl,
  room: roomName,
  callType,
  maxDuration: callType === "on-demand" ? 600 : 1800,
  egressId, // null if recording not available
});
```

**C. Add transcript size limit (app/api/fred/call/summary/route.ts)**

In the `summaryRequestSchema` (around line 27), add `.max(500)` to the transcript array:

```typescript
transcript: z.array(
  z.object({
    speaker: z.enum(["user", "fred"]),
    text: z.string(),
    timestamp: z.string().optional(),
  })
).max(500),
```

This prevents malicious/buggy clients from sending huge transcript arrays causing expensive LLM calls.
  </action>
  <verify>
1. Verify the migration SQL is valid by reviewing syntax.
2. Run `npx tsc --noEmit` to confirm route.ts and summary/route.ts compile.
3. Verify imports use `livekit-server-sdk` (not `@livekit/protocol` directly) for `EgressClient`, `EncodedFileOutput`, `EncodedFileType`, `S3Upload`.
4. Verify transcript schema has `.max(500)`.
  </verify>
  <done>
Migration creates recording_url, transcript_json, summary, decisions, next_actions, call_type columns on coaching_sessions. Call route starts audio-only Egress recording when S3 credentials are configured, with graceful fallback when they are not. Transcript input capped at 500 entries. All types confirmed against actual SDK exports.
  </done>
</task>

<task type="auto">
  <name>Task 2: Persist transcript/summary to coaching_sessions and add egress_ended webhook handler</name>
  <files>
    app/api/fred/call/summary/route.ts
    app/api/livekit/webhook/route.ts
  </files>
  <action>
**A. Persist transcript and summary to coaching_sessions (app/api/fred/call/summary/route.ts)**

After the `generateCallDeliverables()` call and BEFORE the episodic memory insert, add a coaching_sessions update:

```typescript
// Persist transcript and summary to coaching_sessions
try {
  const supabase = createServiceClient();
  const { error: updateError } = await supabase
    .from('coaching_sessions')
    .update({
      transcript_json: transcript,
      summary: deliverables.summary,
      decisions: deliverables.decisions,
      next_actions: deliverables.nextActions,
      call_type: callType,
    })
    .eq('room_name', roomName)
    .eq('user_id', userId);

  if (updateError) {
    console.warn('[Fred Call Summary] Failed to persist to coaching_sessions:', updateError.message);
  } else {
    console.log(`[Fred Call Summary] Persisted transcript and summary for room: ${roomName}`);
  }
} catch (persistErr) {
  console.warn('[Fred Call Summary] coaching_sessions persistence error:', persistErr);
}
```

NOTE: Move the `const supabase = createServiceClient();` call to before BOTH the coaching_sessions update and the episodic memory insert, so it is only created once. Currently supabase is created inside the episodic memory try block -- move it above both blocks and share it.

The update targets the coaching_sessions row that was already created by the webhook's room_started handler. If no matching row exists (edge case), the update simply affects 0 rows, which is fine.

Keep the existing fred_episodic_memory insert as-is (it serves a different purpose -- conversation context for FRED).

**B. Add egress_ended webhook handler (app/api/livekit/webhook/route.ts)**

In the `switch (event.event)` block, add a new case for `egress_ended`. This handler extracts the recording file URL from the EgressInfo and stores it in coaching_sessions.recording_url.

The webhook event for egress has `event.egressInfo` (type `EgressInfo` from `@livekit/protocol`). The completed file results are in `egressInfo.fileResults` (array of `FileInfo`). Each `FileInfo` has a `filename` field with the S3 path and a `location` field with the download URL.

Add this case to the switch statement, after the existing `room_finished` case:

```typescript
case 'egress_ended': {
  const egressInfo = event.egressInfo;
  if (!egressInfo) {
    console.warn('[LiveKit Webhook] egress_ended: no egressInfo');
    break;
  }

  const roomName = egressInfo.roomName;
  if (!roomName) {
    console.warn('[LiveKit Webhook] egress_ended: no roomName in egressInfo');
    break;
  }

  // Extract file URL from file results
  // fileResults contains completed file upload info
  let recordingUrl: string | null = null;

  if (egressInfo.fileResults && egressInfo.fileResults.length > 0) {
    // location is the download URL; filename is the S3 key
    recordingUrl = egressInfo.fileResults[0].location || egressInfo.fileResults[0].filename || null;
  }

  if (!recordingUrl) {
    // Construct predictable URL from the filepath we set at recording start
    const s3Endpoint = process.env.RECORDING_S3_ENDPOINT;
    const s3Bucket = process.env.RECORDING_S3_BUCKET;
    if (s3Endpoint && s3Bucket) {
      recordingUrl = `${s3Endpoint}/${s3Bucket}/voice-recordings/${roomName}.ogg`;
    }
  }

  if (recordingUrl) {
    const { error } = await supabase
      .from('coaching_sessions')
      .update({ recording_url: recordingUrl })
      .eq('room_name', roomName);

    if (error) {
      console.error('[LiveKit Webhook] Failed to store recording URL:', error.message);
    } else {
      console.log(`[LiveKit Webhook] Recording URL stored for room ${roomName}: ${recordingUrl}`);
    }
  } else {
    console.warn(`[LiveKit Webhook] egress_ended for room ${roomName} but no recording URL found`);
  }

  break;
}
```

Note: The `supabase` client is already created at the top of the POST handler (line 46: `const supabase = createServiceClient();`), so it is available in this new case.

To verify the EgressInfo type has `fileResults`, check: `EgressInfo` from `@livekit/protocol` has a `fileResults: FileInfo[]` field. `FileInfo` has `filename: string` and `location: string`. These are populated by LiveKit when egress completes and the file is uploaded to S3.
  </action>
  <verify>
1. Run `npx tsc --noEmit` to confirm both files compile.
2. Verify the summary route persists to coaching_sessions with room_name + user_id filter.
3. Verify the webhook route has a `case 'egress_ended'` handler that updates `coaching_sessions.recording_url`.
4. Verify the egress_ended handler reads `egressInfo.fileResults[0].location` for the URL.
  </verify>
  <done>
Call summary route persists transcript_json, summary, decisions, and next_actions to coaching_sessions. The egress_ended webhook handler stores the recording_url in coaching_sessions once LiveKit finishes uploading the audio file to S3. Both write paths target the same coaching_sessions row created by room_started.
  </done>
</task>

<task type="checkpoint:decision" gate="blocking">
  <decision>Recording storage configuration</decision>
  <context>
Call recording via LiveKit Egress requires S3-compatible storage. The code has been written to gracefully skip recording when credentials are not configured, so the call functionality works either way. However, to actually enable recordings, you need to:

1. Verify Egress is available in your LiveKit Cloud plan
2. Set up S3-compatible storage (Supabase Storage or AWS S3)
3. Configure 5 environment variables (RECORDING_S3_ACCESS_KEY, RECORDING_S3_SECRET, RECORDING_S3_BUCKET, RECORDING_S3_REGION, RECORDING_S3_ENDPOINT)

The code changes are complete regardless of this decision.
  </context>
  <options>
    <option id="option-a">
      <name>Configure recording storage now</name>
      <pros>Full recording functionality immediately available</pros>
      <cons>Requires S3 setup and env var configuration</cons>
    </option>
    <option id="option-b">
      <name>Defer recording storage to later</name>
      <pros>Voice hardening ships now, recording is a bonus feature. Code is ready and waiting for credentials.</pros>
      <cons>Recordings won't work until credentials are added</cons>
    </option>
  </options>
  <resume-signal>Select: option-a or option-b. If option-b, recording will work as soon as env vars are set -- no code changes needed.</resume-signal>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no new errors
2. Migration file exists at `lib/db/migrations/062_call_recording_columns.sql`
3. `app/api/fred/call/route.ts` imports `EgressClient`, `EncodedFileOutput`, `EncodedFileType`, `S3Upload` from `livekit-server-sdk`
4. `app/api/fred/call/route.ts` starts recording when S3 credentials present, skips gracefully when missing
5. `app/api/fred/call/summary/route.ts` has `.max(500)` on transcript array
6. `app/api/fred/call/summary/route.ts` persists transcript and summary to coaching_sessions table
7. `app/api/livekit/webhook/route.ts` has `egress_ended` case that stores recording_url from fileResults
8. Response from call route includes `egressId` field
</verification>

<success_criteria>
- Database migration adds recording_url, transcript_json, summary, decisions, next_actions, call_type to coaching_sessions
- Call recording starts automatically when S3 credentials are configured
- Call recording failure does NOT block the voice call
- Transcript array input is capped at 500 entries
- Transcript and summary are persisted to coaching_sessions when call ends
- Recording URL is stored in coaching_sessions when egress_ended webhook fires
- All files pass TypeScript type checking
</success_criteria>

<output>
After completion, create `.planning/phases/62-voice-agent-hardening/62-02-SUMMARY.md`
</output>
