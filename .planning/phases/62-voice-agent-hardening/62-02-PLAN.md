---
phase: 62-voice-agent-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/api/fred/call/route.ts
  - app/api/fred/call/summary/route.ts
  - lib/db/migrations/062_call_recording_columns.sql
autonomous: false
user_setup:
  - service: livekit-cloud
    why: "Call recording via Egress requires LiveKit Cloud egress service enabled"
    dashboard_config:
      - task: "Verify egress is available in your LiveKit Cloud project"
        location: "LiveKit Cloud Dashboard -> Project Settings"
  - service: supabase-storage
    why: "Audio recordings stored in S3-compatible storage"
    env_vars:
      - name: RECORDING_S3_ACCESS_KEY
        source: "Supabase Dashboard -> Settings -> Storage, or AWS S3 credentials"
      - name: RECORDING_S3_SECRET
        source: "Supabase Dashboard -> Settings -> Storage, or AWS S3 credentials"
      - name: RECORDING_S3_BUCKET
        source: "Create a bucket named 'voice-recordings' in Supabase Storage or S3"
      - name: RECORDING_S3_REGION
        source: "Same region as your Supabase project or S3 bucket"
      - name: RECORDING_S3_ENDPOINT
        source: "Supabase Storage S3 endpoint URL (if using Supabase), or omit for AWS S3"

must_haves:
  truths:
    - "Voice call recordings are captured as audio files and uploaded to cloud storage"
    - "Call transcript and summary are persisted in the database alongside the coaching session"
    - "Users can access their call recording URL and transcript after a call ends"
  artifacts:
    - path: "app/api/fred/call/route.ts"
      provides: "EgressClient recording start after room creation"
      contains: "EgressClient"
    - path: "app/api/fred/call/summary/route.ts"
      provides: "Transcript and summary persistence to coaching_sessions"
      contains: "coaching_sessions"
    - path: "lib/db/migrations/062_call_recording_columns.sql"
      provides: "recording_url, transcript_json, summary columns on coaching_sessions"
      contains: "ALTER TABLE coaching_sessions"
  key_links:
    - from: "app/api/fred/call/route.ts"
      to: "livekit-server-sdk EgressClient"
      via: "startRoomCompositeEgress with audioOnly"
      pattern: "startRoomCompositeEgress"
    - from: "app/api/fred/call/summary/route.ts"
      to: "supabase coaching_sessions"
      via: "update with transcript and summary"
      pattern: "coaching_sessions.*update"
---

<objective>
Add call recording via LiveKit Egress and persist transcripts/summaries to the database.

Purpose: Enable post-call playback and reliable transcript storage. Currently transcripts only exist in client memory and episodic memory -- if the user closes the browser, the transcript is lost. Recording and persistence complete the voice call lifecycle.

Output: Call recording starts automatically when a voice call room is created, and transcript + summary are saved to the coaching_sessions table when the call ends.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/62-voice-agent-hardening/62-RESEARCH.md
@app/api/fred/call/route.ts
@app/api/fred/call/summary/route.ts
@lib/db/migrations/042_coaching_sessions.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add recording columns to coaching_sessions and start Egress recording on call creation</name>
  <files>
    lib/db/migrations/062_call_recording_columns.sql
    app/api/fred/call/route.ts
  </files>
  <action>
**A. Create migration to add recording/transcript columns to coaching_sessions**

Create `lib/db/migrations/062_call_recording_columns.sql`:

```sql
-- ============================================================================
-- Migration 062: Call Recording & Transcript Columns
-- Phase 62: Voice Agent Production Hardening
-- ============================================================================

-- Add recording and transcript columns to coaching_sessions
ALTER TABLE coaching_sessions
  ADD COLUMN IF NOT EXISTS recording_url TEXT,
  ADD COLUMN IF NOT EXISTS transcript_json JSONB,
  ADD COLUMN IF NOT EXISTS summary TEXT,
  ADD COLUMN IF NOT EXISTS decisions JSONB,
  ADD COLUMN IF NOT EXISTS next_actions JSONB,
  ADD COLUMN IF NOT EXISTS call_type TEXT DEFAULT 'on-demand'
    CHECK (call_type IN ('on-demand', 'scheduled'));

-- Add unique constraint on room_name for upsert operations
-- (may already exist from webhook handler, use IF NOT EXISTS pattern)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'coaching_sessions_room_name_unique'
  ) THEN
    ALTER TABLE coaching_sessions
      ADD CONSTRAINT coaching_sessions_room_name_unique UNIQUE (room_name);
  END IF;
END $$;
```

**B. Add EgressClient recording start to call route (app/api/fred/call/route.ts)**

1. Add imports at the top:
   ```typescript
   import { EgressClient, EncodedFileOutput } from 'livekit-server-sdk';
   ```

   Also import EncodedFileType from @livekit/protocol:
   ```typescript
   import { EncodedFileType } from '@livekit/protocol';
   ```

   NOTE: If `EncodedFileType` is not exported from `@livekit/protocol`, check the actual exports. The value for OGG is typically `2`. You may need to use a numeric literal or find the correct import path. Check `node_modules/@livekit/protocol` for the actual export.

2. After the room creation (after `await roomService.createRoom(...)` and its log), add egress recording start -- wrapped in a try/catch so recording failure does NOT block the call:

   ```typescript
   // 1.5 Start audio-only recording via Egress (non-blocking)
   let egressId: string | null = null;
   const s3AccessKey = process.env.RECORDING_S3_ACCESS_KEY;
   const s3Secret = process.env.RECORDING_S3_SECRET;
   const s3Bucket = process.env.RECORDING_S3_BUCKET;
   const s3Region = process.env.RECORDING_S3_REGION;

   if (s3AccessKey && s3Secret && s3Bucket && s3Region) {
     try {
       const egressClient = new EgressClient(httpUrl, apiKey, apiSecret);

       const s3Output: Record<string, unknown> = {
         accessKey: s3AccessKey,
         secret: s3Secret,
         bucket: s3Bucket,
         region: s3Region,
       };

       const s3Endpoint = process.env.RECORDING_S3_ENDPOINT;
       if (s3Endpoint) {
         s3Output.endpoint = s3Endpoint;
         s3Output.forcePathStyle = true;
       }

       const fileOutput = new EncodedFileOutput({
         fileType: EncodedFileType.OGG,
         filepath: `voice-recordings/${roomName}.ogg`,
         output: {
           case: 's3',
           value: s3Output,
         },
       });

       const egressInfo = await egressClient.startRoomCompositeEgress(
         roomName,
         { file: fileOutput },
         { audioOnly: true }
       );
       egressId = egressInfo.egressId;
       console.log(`[Fred Call] Recording started: egress=${egressId}`);
     } catch (egressErr) {
       console.warn('[Fred Call] Recording start failed (call will proceed without recording):', egressErr);
     }
   } else {
     console.log('[Fred Call] Recording skipped: S3 credentials not configured');
   }
   ```

   IMPORTANT: The EgressClient API may differ slightly. Check the actual method signature in `node_modules/livekit-server-sdk/dist/EgressClient.d.ts` before implementing. The `startRoomCompositeEgress` method signature and `EncodedFileOutput` constructor may vary. Adapt the code to match the actual API surface.

3. Include `egressId` in the response JSON (after the existing fields):
   ```typescript
   return NextResponse.json({
     success: true,
     token,
     url: livekitUrl,
     room: roomName,
     callType,
     maxDuration: callType === "on-demand" ? 600 : 1800,
     egressId, // null if recording not available
   });
   ```
  </action>
  <verify>
1. Verify the migration SQL is valid by reviewing syntax.
2. Run `npx tsc --noEmit` to confirm the route.ts compiles.
3. Check `node_modules/livekit-server-sdk/dist/EgressClient.d.ts` to verify the EgressClient API matches the implementation.
  </verify>
  <done>
Migration creates recording_url, transcript_json, summary, decisions, next_actions, call_type columns on coaching_sessions. Call route starts audio-only Egress recording when S3 credentials are configured, with graceful fallback when they are not.
  </done>
</task>

<task type="auto">
  <name>Task 2: Persist transcript and summary to coaching_sessions on call end</name>
  <files>app/api/fred/call/summary/route.ts</files>
  <action>
Update the summary route to persist deliverables into the coaching_sessions table (in addition to the existing fred_episodic_memory insert):

1. After the `generateCallDeliverables()` call and BEFORE the episodic memory insert, add a coaching_sessions update:

   ```typescript
   // Persist transcript and summary to coaching_sessions
   try {
     const supabase = createServiceClient();
     const { error: updateError } = await supabase
       .from('coaching_sessions')
       .update({
         transcript_json: transcript,
         summary: deliverables.summary,
         decisions: deliverables.decisions,
         next_actions: deliverables.nextActions,
         call_type: callType,
       })
       .eq('room_name', roomName)
       .eq('user_id', userId);

     if (updateError) {
       console.warn('[Fred Call Summary] Failed to persist to coaching_sessions:', updateError.message);
     } else {
       console.log(`[Fred Call Summary] Persisted transcript and summary for room: ${roomName}`);
     }
   } catch (persistErr) {
     console.warn('[Fred Call Summary] coaching_sessions persistence error:', persistErr);
   }
   ```

   NOTE: Move the `const supabase = createServiceClient();` call to before BOTH the coaching_sessions update and the episodic memory insert, so it is only created once. Currently supabase is created inside the episodic memory try block -- move it above both blocks and share it.

2. The update targets the coaching_sessions row that was already created by the webhook's room_started handler. If no matching row exists (edge case), the update simply affects 0 rows, which is fine.

3. Keep the existing fred_episodic_memory insert as-is (it serves a different purpose -- conversation context for FRED).
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm summary route compiles. Verify the update targets coaching_sessions with both room_name and user_id filters.
  </verify>
  <done>
Call summary route persists transcript_json, summary, decisions, and next_actions to the coaching_sessions table. Transcript and summary are now reliably stored server-side alongside the session record.
  </done>
</task>

<task type="checkpoint:decision" gate="blocking">
  <decision>Recording storage configuration</decision>
  <context>
Call recording via LiveKit Egress requires S3-compatible storage. The code has been written to gracefully skip recording when credentials are not configured, so the call functionality works either way. However, to actually enable recordings, you need to:

1. Verify Egress is available in your LiveKit Cloud plan
2. Set up S3-compatible storage (Supabase Storage or AWS S3)
3. Configure 5 environment variables (RECORDING_S3_ACCESS_KEY, RECORDING_S3_SECRET, RECORDING_S3_BUCKET, RECORDING_S3_REGION, RECORDING_S3_ENDPOINT)

The code changes are complete regardless of this decision.
  </context>
  <options>
    <option id="option-a">
      <name>Configure recording storage now</name>
      <pros>Full recording functionality immediately available</pros>
      <cons>Requires S3 setup and env var configuration</cons>
    </option>
    <option id="option-b">
      <name>Defer recording storage to later</name>
      <pros>Voice hardening ships now, recording is a bonus feature. Code is ready and waiting for credentials.</pros>
      <cons>Recordings won't work until credentials are added</cons>
    </option>
  </options>
  <resume-signal>Select: option-a or option-b. If option-b, recording will work as soon as env vars are set -- no code changes needed.</resume-signal>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no new errors
2. Migration file exists at `lib/db/migrations/062_call_recording_columns.sql`
3. `app/api/fred/call/route.ts` imports EgressClient and starts recording when S3 credentials present
4. `app/api/fred/call/route.ts` gracefully skips recording when S3 credentials missing
5. `app/api/fred/call/summary/route.ts` persists transcript and summary to coaching_sessions table
6. Response from call route includes `egressId` field
</verification>

<success_criteria>
- Database migration adds recording_url, transcript_json, summary, decisions, next_actions, call_type to coaching_sessions
- Call recording starts automatically when S3 credentials are configured
- Call recording failure does NOT block the voice call
- Transcript and summary are persisted to coaching_sessions when call ends
- All files pass TypeScript type checking
</success_criteria>

<output>
After completion, create `.planning/phases/62-voice-agent-hardening/62-02-SUMMARY.md`
</output>
