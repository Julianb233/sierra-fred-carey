---
phase: 66-content-library-backend
plan: 03
type: execute
wave: 3
depends_on:
  - 66-02
files_modified:
  - app/api/content/route.ts
  - app/api/content/[courseId]/route.ts
  - app/api/content/[courseId]/lessons/[lessonId]/playback-token/route.ts
  - app/api/content/progress/route.ts
  - lib/fred/tools/content-recommender.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/content returns published course catalog with optional stage/topic filtering"
    - "GET /api/content/[courseId] returns a single course with its modules and lessons"
    - "GET /api/content/[courseId]/lessons/[lessonId]/playback-token enforces tier access and returns a signed 1-hour JWT"
    - "POST /api/content/progress saves lesson watch progress"
    - "FRED's content-recommender tool returns real course results instead of coming_soon"
  artifacts:
    - path: "app/api/content/route.ts"
      provides: "GET handler for course catalog with stage/topic filters"
      exports: ["GET"]
    - path: "app/api/content/[courseId]/route.ts"
      provides: "GET handler for single course with modules and lessons"
      exports: ["GET"]
    - path: "app/api/content/[courseId]/lessons/[lessonId]/playback-token/route.ts"
      provides: "GET handler returning signed Mux JWT after tier check"
      exports: ["GET"]
    - path: "app/api/content/progress/route.ts"
      provides: "POST handler for lesson progress upsert"
      exports: ["POST"]
    - path: "lib/fred/tools/content-recommender.ts"
      provides: "FRED tool that queries real content library"
      contains: "searchContentLibrary"
  key_links:
    - from: "app/api/content/[courseId]/lessons/[lessonId]/playback-token/route.ts"
      to: "lib/api/tier-middleware.ts"
      via: "checkTierForRequest(req, requiredTier)"
      pattern: "checkTierForRequest"
    - from: "app/api/content/[courseId]/lessons/[lessonId]/playback-token/route.ts"
      to: "lib/mux/tokens.ts"
      via: "signPlaybackToken(lesson.mux_playback_id)"
      pattern: "signPlaybackToken"
    - from: "lib/fred/tools/content-recommender.ts"
      to: "lib/db/content.ts"
      via: "searchContentLibrary({ query, stage, format })"
      pattern: "searchContentLibrary"
---

<objective>
Create public content API routes (catalog, course detail, playback token, progress) and update FRED's content recommender stub to use real data.

Purpose: These routes are the user-facing backend for the content library. The catalog and course detail routes are called by Phase 67 frontend. The playback-token route is the tier enforcement point — it checks the user's subscription before issuing a signed JWT. The FRED tool update means FRED can immediately recommend content once courses are added to the database.
Output: 5 files — 4 API routes and the updated FRED tool.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/66-content-library-backend/66-RESEARCH.md
@.planning/phases/66-content-library-backend/66-02-SUMMARY.md
@lib/db/content.ts
@lib/mux/tokens.ts
@lib/api/tier-middleware.ts
@lib/fred/tools/content-recommender.ts
@app/api/admin/dashboard/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create public content API routes</name>
  <files>
    app/api/content/route.ts,
    app/api/content/[courseId]/route.ts,
    app/api/content/[courseId]/lessons/[lessonId]/playback-token/route.ts,
    app/api/content/progress/route.ts
  </files>
  <action>
Create 4 API route files. Follow the exact patterns from existing routes in app/api/ (see app/api/admin/dashboard/route.ts for auth pattern, app/api/fred/chat/route.ts for user auth pattern).

**app/api/content/route.ts** — public catalog (requires auth, does NOT gate by tier):
```typescript
import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@/lib/supabase/server";
import { getCatalog } from "@/lib/db/content";

export async function GET(req: NextRequest) {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const { searchParams } = new URL(req.url);
  const stage = searchParams.get("stage");
  const topic = searchParams.get("topic");

  try {
    const courses = await getCatalog({ stage, topic });
    return NextResponse.json({ courses });
  } catch (error) {
    console.error("[content] getCatalog error:", error);
    return NextResponse.json({ error: "Failed to fetch courses" }, { status: 500 });
  }
}
```

**app/api/content/[courseId]/route.ts** — single course with modules and lessons:
```typescript
import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@/lib/supabase/server";
import { getCourse } from "@/lib/db/content";

export async function GET(
  req: NextRequest,
  { params }: { params: Promise<{ courseId: string }> }
) {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const { courseId } = await params;

  try {
    const course = await getCourse(courseId);
    if (!course) {
      return NextResponse.json({ error: "Course not found" }, { status: 404 });
    }
    return NextResponse.json({ course });
  } catch (error) {
    console.error("[content] getCourse error:", error);
    return NextResponse.json({ error: "Failed to fetch course" }, { status: 500 });
  }
}
```

**app/api/content/[courseId]/lessons/[lessonId]/playback-token/route.ts** — tier-gated signed JWT:

IMPORTANT: This is the tier enforcement point. Read the lesson's tier_required from the courses table (via the module), then check the user's tier. If the lesson is_preview = true, skip the tier check (preview lessons are watchable by anyone).

```typescript
import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@/lib/supabase/server";
import { getLesson } from "@/lib/db/content";
import { signPlaybackToken } from "@/lib/mux/tokens";
import { checkTierForRequest } from "@/lib/api/tier-middleware";
import { UserTier } from "@/lib/constants";

// Helper: map normalized tier string to UserTier enum
function tierStringToEnum(tier: string): UserTier {
  if (tier === "studio") return UserTier.STUDIO;
  if (tier === "pro") return UserTier.PRO;
  return UserTier.FREE;
}

export async function GET(
  req: NextRequest,
  { params }: { params: Promise<{ courseId: string; lessonId: string }> }
) {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const { lessonId } = await params;

  // Fetch lesson
  const lesson = await getLesson(lessonId);
  if (!lesson) {
    return NextResponse.json({ error: "Lesson not found" }, { status: 404 });
  }

  // Check video is ready
  if (lesson.mux_status !== "ready" || !lesson.mux_playback_id) {
    return NextResponse.json({ error: "Video not ready" }, { status: 422 });
  }

  // Preview lessons skip tier check — free access for all authenticated users
  if (!lesson.is_preview) {
    // Get the course's tier requirement via module → course lookup
    const serviceSupabase = (await import("@/lib/supabase/server")).createServiceClient();
    const { data: moduleRow } = await serviceSupabase
      .from("modules")
      .select("course_id")
      .eq("id", lesson.module_id)
      .single();

    if (moduleRow) {
      const { data: courseRow } = await serviceSupabase
        .from("courses")
        .select("tier_required")
        .eq("id", moduleRow.course_id)
        .single();

      if (courseRow) {
        const requiredTier = tierStringToEnum(courseRow.tier_required);
        if (requiredTier > UserTier.FREE) {
          const tierCheck = await checkTierForRequest(req, requiredTier);
          if (!tierCheck.allowed) {
            return NextResponse.json(
              { error: "Upgrade required", upgradeUrl: "/pricing" },
              { status: 403 }
            );
          }
        }
      }
    }
  }

  // Generate 1-hour signed playback token
  try {
    const token = await signPlaybackToken(lesson.mux_playback_id);
    return NextResponse.json({ token, playbackId: lesson.mux_playback_id });
  } catch (error) {
    console.error("[content] signPlaybackToken error:", error);
    return NextResponse.json({ error: "Failed to generate playback token" }, { status: 500 });
  }
}
```

**app/api/content/progress/route.ts** — lesson progress tracking (Phase 67 Mux Player calls this):
```typescript
import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@/lib/supabase/server";
import { upsertProgress } from "@/lib/db/content";
import { z } from "zod";

const ProgressSchema = z.object({
  lessonId: z.string().uuid(),
  watchedPct: z.number().int().min(0).max(100),
  completed: z.boolean().default(false),
});

export async function POST(req: NextRequest) {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const body = await req.json();
  const parsed = ProgressSchema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json({ error: parsed.error.flatten() }, { status: 400 });
  }

  try {
    await upsertProgress({
      userId: user.id,
      lessonId: parsed.data.lessonId,
      watchedPct: parsed.data.watchedPct,
      completed: parsed.data.completed,
    });
    return NextResponse.json({ ok: true });
  } catch (error) {
    console.error("[content] upsertProgress error:", error);
    return NextResponse.json({ error: "Failed to save progress" }, { status: 500 });
  }
}
```

After creating all 4 files, run `npx tsc --noEmit 2>&1 | grep "app/api/content" | head -20` and fix any type errors.
  </action>
  <verify>`npx tsc --noEmit 2>&1 | grep "app/api/content" | head -10` outputs nothing. Also check: `ls app/api/content/` shows route.ts and subdirectories. `ls app/api/content/\[courseId\]/lessons/\[lessonId\]/playback-token/` shows route.ts.</verify>
  <done>4 content API routes created and compiling without TypeScript errors. Catalog route requires auth, returns all published courses. Playback-token route enforces tier for non-preview lessons and returns signed JWT.</done>
</task>

<task type="auto">
  <name>Task 2: Update FRED's content-recommender tool</name>
  <files>lib/fred/tools/content-recommender.ts</files>
  <action>
Read the current `lib/fred/tools/content-recommender.ts` file first (it's a stub returning `coming_soon`). Update ONLY the `execute` function body. Do NOT change the `description`, `inputSchema`, or any other part of the tool definition. The tool interface must remain identical because it's already wired into FRED's tool registry.

Replace the execute body from the stub that returns `{ status: "coming_soon" }` to one that calls `searchContentLibrary` from `lib/db/content.ts`:

```typescript
// Add import at top of file (after existing imports):
import { searchContentLibrary } from "@/lib/db/content";

// Replace the execute function:
execute: async ({ query, stage, format }) => {
  try {
    const courses = await searchContentLibrary({ query, stage, format });

    if (courses.length === 0) {
      return {
        status: "no_results" as const,
        query,
        message: `No content found for "${query}" yet. I'll guide you directly on this topic.`,
        courses: [],
      };
    }

    return {
      status: "success" as const,
      query,
      courses: courses.map((c) => ({
        id: c.id,
        title: c.title,
        description: c.description,
        stage: c.stage ?? undefined,
        topic: c.topic ?? undefined,
        tier_required: c.tier_required,
        slug: c.slug,
      })),
    };
  } catch {
    // Graceful degradation — if DB query fails, fall back to stub behavior
    return {
      status: "coming_soon" as const,
      query,
      message: `Content library search temporarily unavailable. Based on "${query}", I'll guide you directly.`,
      suggestedTopics: [] as string[],
    };
  }
},
```

The key requirement: the tool now tries a real DB query, returns structured course results on success, and falls back to the original coming_soon response on error. This means FRED can recommend content immediately once courses are added to the DB, without any additional wiring.

After editing, run `npx tsc --noEmit 2>&1 | grep "content-recommender" | head -10` and fix any type errors.
  </action>
  <verify>`grep "searchContentLibrary" lib/fred/tools/content-recommender.ts` shows the import and call. `grep "coming_soon" lib/fred/tools/content-recommender.ts` shows it's only used in the catch block (graceful fallback). `npx tsc --noEmit 2>&1 | grep "content-recommender"` outputs nothing.</verify>
  <done>FRED's content-recommender tool queries the real content library on execute, returns structured course results on success, and falls back gracefully to coming_soon on error. Tool interface (description, inputSchema) is unchanged.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit 2>&1 | grep -E "app/api/content|content-recommender"` — zero output
2. `ls app/api/content/` shows route.ts, [courseId]/, progress/
3. `ls "app/api/content/[courseId]/lessons/[lessonId]/playback-token/"` shows route.ts
4. `grep "checkTierForRequest" "app/api/content/[courseId]/lessons/[lessonId]/playback-token/route.ts"` shows tier check
5. `grep "signPlaybackToken" "app/api/content/[courseId]/lessons/[lessonId]/playback-token/route.ts"` shows token generation
6. `grep "searchContentLibrary" lib/fred/tools/content-recommender.ts` shows the real DB query
7. `npm run build 2>&1 | tail -5` — build should complete (or show only pre-existing errors)
</verification>

<success_criteria>
- GET /api/content: returns { courses: Course[] }, requires auth, filters by stage/topic
- GET /api/content/[courseId]: returns { course: CourseWithModules }, 404 if not found
- GET /api/content/[courseId]/lessons/[lessonId]/playback-token: returns { token, playbackId } for authorized users, 403 with upgradeUrl for unauthorized, 422 if video not ready
- POST /api/content/progress: validates body with Zod, upserts progress, returns { ok: true }
- FRED content-recommender tool queries real DB, falls back gracefully on error
- All 5 files compile without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/66-content-library-backend/66-03-SUMMARY.md` with:
- API routes created and their contracts
- FRED tool update description
- Any TypeScript issues and resolutions
- Tier enforcement logic summary
</output>
