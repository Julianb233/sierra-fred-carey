---
phase: 66-content-library-backend
plan: 02
type: execute
wave: 2
depends_on:
  - 66-01
files_modified:
  - lib/mux/client.ts
  - lib/mux/uploads.ts
  - lib/mux/tokens.ts
  - lib/db/content.ts
autonomous: true

must_haves:
  truths:
    - "Mux SDK singleton is initialized from environment variables and exported for use across the codebase"
    - "DB helper functions exist for fetching course catalog, individual courses, and searching content"
    - "The searchContentLibrary function can be called by the FRED content-recommender tool"
    - "Signed playback token generation function exists with 1-hour expiry"
    - "Direct upload URL creation function exists"
  artifacts:
    - path: "lib/mux/client.ts"
      provides: "Mux singleton initialized from MUX_TOKEN_ID and MUX_TOKEN_SECRET"
      exports: ["mux"]
    - path: "lib/mux/uploads.ts"
      provides: "createDirectUpload() and getAsset() functions"
      exports: ["createDirectUpload", "getAsset"]
    - path: "lib/mux/tokens.ts"
      provides: "signPlaybackToken() with 1h expiry using MUX_SIGNING_KEY_ID and MUX_SIGNING_PRIVATE_KEY"
      exports: ["signPlaybackToken"]
    - path: "lib/db/content.ts"
      provides: "getCatalog(), getCourse(), getLesson(), searchContentLibrary(), upsertProgress()"
      exports: ["getCatalog", "getCourse", "getLesson", "searchContentLibrary", "upsertProgress"]
  key_links:
    - from: "lib/mux/client.ts"
      to: "@mux/mux-node"
      via: "import Mux from '@mux/mux-node'"
      pattern: "from.*@mux/mux-node"
    - from: "lib/db/content.ts"
      to: "lib/db/supabase-sql.ts"
      via: "import { sql } from '@/lib/db/supabase-sql'"
      pattern: "from.*lib/db/supabase-sql"
    - from: "lib/mux/tokens.ts"
      to: "lib/mux/client.ts"
      via: "import { mux } from './client'"
      pattern: "from.*client"
---

<objective>
Create the Mux library helpers and database content helpers that all API routes in Plans 03 and 04 will import.

Purpose: These files are the shared foundation for all content API routes. Centralizing Mux initialization and DB queries prevents duplication and ensures consistent patterns. The DB search function also directly enables FRED's content recommendation tool.
Output: 4 library files: lib/mux/client.ts, lib/mux/uploads.ts, lib/mux/tokens.ts, lib/db/content.ts.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/66-content-library-backend/66-RESEARCH.md
@.planning/phases/66-content-library-backend/66-01-SUMMARY.md
@lib/db/supabase-sql.ts
@lib/auth/admin.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Mux client singleton and upload/token helpers</name>
  <files>lib/mux/client.ts, lib/mux/uploads.ts, lib/mux/tokens.ts</files>
  <action>
Create the `lib/mux/` directory with three files.

**lib/mux/client.ts** — singleton Mux instance. Reads from environment variables. Export `mux` as the singleton. Do NOT use `process.env.MUX_TOKEN_ID!` with non-null assertion if there's a cleaner pattern in the codebase (check how other clients like `lib/supabase/server.ts` handle missing env vars). Use the same guard pattern.

```typescript
/**
 * Mux client singleton
 *
 * Initialized from environment variables:
 *   MUX_TOKEN_ID       — Mux API access token ID
 *   MUX_TOKEN_SECRET   — Mux API access token secret
 *   MUX_WEBHOOK_SECRET — Mux webhook signature verification (optional, used in webhook handler)
 */
import Mux from "@mux/mux-node";

if (!process.env.MUX_TOKEN_ID || !process.env.MUX_TOKEN_SECRET) {
  // In build/test environments, allow missing credentials (routes will fail at runtime)
  console.warn("[mux] MUX_TOKEN_ID or MUX_TOKEN_SECRET not set");
}

export const mux = new Mux({
  tokenId: process.env.MUX_TOKEN_ID ?? "",
  tokenSecret: process.env.MUX_TOKEN_SECRET ?? "",
  webhookSecret: process.env.MUX_WEBHOOK_SECRET,
});
```

**lib/mux/uploads.ts** — direct upload creation and asset retrieval:

```typescript
/**
 * Mux upload helpers
 *
 * createDirectUpload(lessonId, corsOrigin) — creates a Mux direct upload URL.
 *   - playback_policies set to "signed" for tier-gated content
 *   - passthrough set to lessonId so webhook can link asset back to lesson
 *
 * getAsset(assetId) — fetches Mux asset details.
 */
import { mux } from "./client";

export interface DirectUploadResult {
  uploadId: string;
  uploadUrl: string;
}

export async function createDirectUpload(
  lessonId: string,
  corsOrigin: string
): Promise<DirectUploadResult> {
  const upload = await mux.video.uploads.create({
    cors_origin: corsOrigin,
    new_asset_settings: {
      playback_policies: ["signed"],  // NEVER "public" for gated content
      passthrough: lessonId,          // Links Mux asset back to lesson row in DB
    },
  });

  return {
    uploadId: upload.id,
    uploadUrl: upload.url,
  };
}

export async function getAsset(assetId: string) {
  return mux.video.assets.retrieve(assetId);
}
```

**lib/mux/tokens.ts** — signed playback token generation:

```typescript
/**
 * Mux playback token signing
 *
 * signPlaybackToken(playbackId) — generates a short-lived (1h) signed JWT
 * for secure video playback. Requires MUX_SIGNING_KEY_ID and
 * MUX_SIGNING_PRIVATE_KEY environment variables (base64-encoded private key).
 *
 * Do NOT generate tokens without expiration — always use "1h".
 */
import { mux } from "./client";

export async function signPlaybackToken(playbackId: string): Promise<string> {
  return mux.jwt.signPlaybackId(playbackId, {
    expiration: "1h",
    type: "playback",
  });
}
```

After creating these files, verify TypeScript compiles: `npx tsc --noEmit 2>&1 | grep "lib/mux" | head -20`. Fix any type errors before proceeding.
  </action>
  <verify>`npx tsc --noEmit 2>&1 | grep -c "lib/mux"` outputs 0 (no errors in mux files). Also verify: `grep -r "from.*@mux/mux-node" lib/mux/client.ts` shows the import.</verify>
  <done>Three Mux helper files created and compile without TypeScript errors.</done>
</task>

<task type="auto">
  <name>Task 2: Create DB content helpers</name>
  <files>lib/db/content.ts</files>
  <action>
Create `lib/db/content.ts` with database query helpers for the content library. Import `sql` from `@/lib/db/supabase-sql` (the same pattern used in all other lib/db/ files).

IMPORTANT: The `sql` template tag in this project uses a custom parser (see lib/db/supabase-sql.ts). It supports simple SELECT/INSERT/UPDATE/DELETE but NOT complex JOINs or GROUP BY with COUNT. Use the Supabase client builder pattern for complex queries via `createServiceClient()`.

```typescript
/**
 * Content library DB helpers
 *
 * Provides typed query functions for the content library tables.
 * Used by API routes in app/api/content/ and app/api/admin/content/,
 * and by FRED's content-recommender tool.
 */
import { createServiceClient } from "@/lib/supabase/server";

// ============================================================================
// Types
// ============================================================================

export interface Course {
  id: string;
  title: string;
  description: string;
  slug: string;
  thumbnail_url: string | null;
  stage: string | null;
  topic: string | null;
  tier_required: "free" | "pro" | "studio";
  is_published: boolean;
  sort_order: number;
  created_at: string;
  updated_at: string;
}

export interface Module {
  id: string;
  course_id: string;
  title: string;
  description: string;
  sort_order: number;
}

export interface Lesson {
  id: string;
  module_id: string;
  title: string;
  description: string;
  sort_order: number;
  duration_seconds: number | null;
  mux_upload_id: string | null;
  mux_asset_id: string | null;
  mux_playback_id: string | null;
  mux_status: "pending" | "processing" | "ready" | "error";
  is_preview: boolean;
}

export interface ContentProgress {
  user_id: string;
  lesson_id: string;
  watched_pct: number;
  completed: boolean;
  last_watched: string;
}

// ============================================================================
// Catalog queries
// ============================================================================

/**
 * Get published course catalog with optional filtering.
 * Used by GET /api/content (public catalog endpoint).
 * Does NOT filter by tier — returns all published courses with tier_required field
 * so frontend can show upgrade prompts. Actual video is gated at playback-token endpoint.
 */
export async function getCatalog(filters: {
  stage?: string | null;
  topic?: string | null;
}): Promise<Course[]> {
  const supabase = createServiceClient();
  let query = supabase
    .from("courses")
    .select("*")
    .eq("is_published", true)
    .order("sort_order", { ascending: true })
    .order("created_at", { ascending: false });

  if (filters.stage) query = query.eq("stage", filters.stage);
  if (filters.topic) query = query.eq("topic", filters.topic);

  const { data, error } = await query;
  if (error) throw error;
  return (data as Course[]) ?? [];
}

/**
 * Get a single course with its modules and lessons.
 * Used by GET /api/content/[courseId].
 */
export async function getCourse(courseId: string): Promise<(Course & { modules: (Module & { lessons: Lesson[] })[] }) | null> {
  const supabase = createServiceClient();

  const { data: course, error: courseError } = await supabase
    .from("courses")
    .select("*")
    .eq("id", courseId)
    .eq("is_published", true)
    .single();

  if (courseError || !course) return null;

  const { data: modules, error: modulesError } = await supabase
    .from("modules")
    .select("*")
    .eq("course_id", courseId)
    .order("sort_order", { ascending: true });

  if (modulesError) throw modulesError;

  const moduleIds = (modules ?? []).map((m: Module) => m.id);
  let lessons: Lesson[] = [];

  if (moduleIds.length > 0) {
    const { data: lessonData, error: lessonsError } = await supabase
      .from("lessons")
      .select("*")
      .in("module_id", moduleIds)
      .order("sort_order", { ascending: true });

    if (lessonsError) throw lessonsError;
    lessons = (lessonData as Lesson[]) ?? [];
  }

  const modulesWithLessons = (modules ?? []).map((m: Module) => ({
    ...m,
    lessons: lessons.filter((l) => l.module_id === m.id),
  }));

  return { ...(course as Course), modules: modulesWithLessons };
}

/**
 * Get a single lesson by ID.
 * Used by GET /api/content/[courseId]/lessons/[lessonId]/playback-token.
 */
export async function getLesson(lessonId: string): Promise<Lesson | null> {
  const supabase = createServiceClient();
  const { data, error } = await supabase
    .from("lessons")
    .select("*")
    .eq("id", lessonId)
    .single();

  if (error || !data) return null;
  return data as Lesson;
}

/**
 * Search content library by query text and optional filters.
 * Used by FRED's content-recommender tool (lib/fred/tools/content-recommender.ts).
 * Searches title and description fields with ilike (case-insensitive).
 */
export async function searchContentLibrary(params: {
  query: string;
  stage?: string | null;
  format?: "video" | "article" | "course" | "any";
}): Promise<Course[]> {
  const supabase = createServiceClient();
  let query = supabase
    .from("courses")
    .select("*")
    .eq("is_published", true)
    .or(`title.ilike.%${params.query}%,description.ilike.%${params.query}%`)
    .order("sort_order", { ascending: true })
    .limit(5);

  if (params.stage) query = query.eq("stage", params.stage);

  const { data, error } = await query;
  if (error) throw error;
  return (data as Course[]) ?? [];
}

// ============================================================================
// Progress tracking
// ============================================================================

/**
 * Upsert lesson progress for a user.
 * Called by POST /api/content/progress (from Mux Player progress events in Phase 67).
 */
export async function upsertProgress(params: {
  userId: string;
  lessonId: string;
  watchedPct: number;
  completed: boolean;
}): Promise<void> {
  const supabase = createServiceClient();
  const { error } = await supabase.from("content_progress").upsert(
    {
      user_id: params.userId,
      lesson_id: params.lessonId,
      watched_pct: params.watchedPct,
      completed: params.completed,
      last_watched: new Date().toISOString(),
    },
    { onConflict: "user_id,lesson_id" }
  );
  if (error) throw error;
}

// ============================================================================
// Admin queries (used by admin API routes)
// ============================================================================

/**
 * Get all courses (published and unpublished) for admin listing.
 */
export async function adminGetCourses(): Promise<Course[]> {
  const supabase = createServiceClient();
  const { data, error } = await supabase
    .from("courses")
    .select("*")
    .order("sort_order", { ascending: true })
    .order("created_at", { ascending: false });
  if (error) throw error;
  return (data as Course[]) ?? [];
}

/**
 * Create a new course.
 */
export async function adminCreateCourse(input: {
  title: string;
  description: string;
  slug: string;
  stage?: string | null;
  topic?: string | null;
  thumbnail_url?: string | null;
  tier_required: "free" | "pro" | "studio";
}): Promise<Course> {
  const supabase = createServiceClient();
  const { data, error } = await supabase
    .from("courses")
    .insert({
      ...input,
      is_published: false,
      sort_order: 0,
    })
    .select()
    .single();
  if (error) throw error;
  return data as Course;
}

/**
 * Update a course (partial update).
 */
export async function adminUpdateCourse(
  courseId: string,
  updates: Partial<Omit<Course, "id" | "created_at">>
): Promise<Course> {
  const supabase = createServiceClient();
  const { data, error } = await supabase
    .from("courses")
    .update({ ...updates, updated_at: new Date().toISOString() })
    .eq("id", courseId)
    .select()
    .single();
  if (error) throw error;
  return data as Course;
}

/**
 * Create a module for a course.
 */
export async function adminCreateModule(input: {
  course_id: string;
  title: string;
  description?: string;
  sort_order?: number;
}): Promise<Module> {
  const supabase = createServiceClient();
  const { data, error } = await supabase
    .from("modules")
    .insert({ ...input, description: input.description ?? "", sort_order: input.sort_order ?? 0 })
    .select()
    .single();
  if (error) throw error;
  return data as Module;
}

/**
 * Create a lesson for a module.
 */
export async function adminCreateLesson(input: {
  module_id: string;
  title: string;
  description?: string;
  sort_order?: number;
  is_preview?: boolean;
}): Promise<Lesson> {
  const supabase = createServiceClient();
  const { data, error } = await supabase
    .from("lessons")
    .insert({
      ...input,
      description: input.description ?? "",
      sort_order: input.sort_order ?? 0,
      is_preview: input.is_preview ?? false,
      mux_status: "pending",
    })
    .select()
    .single();
  if (error) throw error;
  return data as Lesson;
}

/**
 * Update lesson mux fields (called by webhook handler).
 */
export async function updateLessonMuxFields(
  lessonId: string,
  fields: {
    mux_asset_id?: string;
    mux_playback_id?: string;
    mux_status?: "pending" | "processing" | "ready" | "error";
    duration_seconds?: number;
    mux_upload_id?: string;
  }
): Promise<void> {
  const supabase = createServiceClient();
  const { error } = await supabase
    .from("lessons")
    .update({ ...fields, updated_at: new Date().toISOString() })
    .eq("id", lessonId);
  if (error) throw error;
}

/**
 * Find a lesson by mux_upload_id (fallback for webhook when passthrough is missing).
 */
export async function getLessonByUploadId(uploadId: string): Promise<Lesson | null> {
  const supabase = createServiceClient();
  const { data, error } = await supabase
    .from("lessons")
    .select("*")
    .eq("mux_upload_id", uploadId)
    .single();
  if (error || !data) return null;
  return data as Lesson;
}
```

After creating this file, verify TypeScript compiles: `npx tsc --noEmit 2>&1 | grep "lib/db/content" | head -20`. Fix any type errors.
  </action>
  <verify>`npx tsc --noEmit 2>&1 | grep -E "lib/db/content|lib/mux" | head -20` should output nothing (no errors). Run `grep -c "export" lib/db/content.ts` — should be at least 10 exported functions/types.</verify>
  <done>lib/db/content.ts exports getCatalog, getCourse, getLesson, searchContentLibrary, upsertProgress, adminGetCourses, adminCreateCourse, adminUpdateCourse, adminCreateModule, adminCreateLesson, updateLessonMuxFields, getLessonByUploadId — all without TypeScript errors.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit 2>&1 | grep -E "lib/mux|lib/db/content"` — zero output (no type errors)
2. `ls lib/mux/` shows client.ts, uploads.ts, tokens.ts
3. `grep "export async function" lib/db/content.ts | wc -l` shows 10+ exported functions
4. `grep "from.*@mux/mux-node" lib/mux/client.ts` shows Mux SDK import
5. `grep "signPlaybackId" lib/mux/tokens.ts` shows the token generation call with "1h" expiry
</verification>

<success_criteria>
- lib/mux/client.ts: exports `mux` singleton, handles missing env vars gracefully (warns, does not crash build)
- lib/mux/uploads.ts: exports `createDirectUpload(lessonId, corsOrigin)` using signed playback policy
- lib/mux/tokens.ts: exports `signPlaybackToken(playbackId)` with 1h expiry
- lib/db/content.ts: exports all 12 functions, uses createServiceClient() directly (not sql template tag) for complex queries, uses service client for admin functions
- TypeScript compiles cleanly for all 4 new files
</success_criteria>

<output>
After completion, create `.planning/phases/66-content-library-backend/66-02-SUMMARY.md` with:
- Files created and their export lists
- Any TypeScript issues encountered and how they were resolved
- Key implementation decisions (e.g., why createServiceClient() over sql template tag)
</output>
