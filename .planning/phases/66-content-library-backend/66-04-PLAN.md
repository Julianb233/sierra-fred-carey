---
phase: 66-content-library-backend
plan: 04
type: execute
wave: 3
depends_on:
  - 66-02
files_modified:
  - app/api/admin/content/route.ts
  - app/api/admin/content/[courseId]/route.ts
  - app/api/admin/content/[courseId]/modules/route.ts
  - app/api/admin/content/[courseId]/modules/[moduleId]/lessons/route.ts
  - app/api/admin/content/upload-url/route.ts
  - app/api/mux/webhooks/route.ts
autonomous: false

user_setup:
  - service: mux
    why: "Video hosting for Sahara content library"
    env_vars:
      - name: MUX_TOKEN_ID
        source: "Mux Dashboard > Settings > API Access Tokens > Create new token"
      - name: MUX_TOKEN_SECRET
        source: "Mux Dashboard > Settings > API Access Tokens > Create new token (shown once)"
      - name: MUX_WEBHOOK_SECRET
        source: "Mux Dashboard > Settings > Webhooks > Create endpoint > Copy signing secret"
      - name: MUX_SIGNING_KEY_ID
        source: "Mux Dashboard > Settings > Signing Keys > Create new key"
      - name: MUX_SIGNING_PRIVATE_KEY
        source: "Mux Dashboard > Settings > Signing Keys > base64-encoded private key (shown once)"
    dashboard_config:
      - task: "Create API Access Token with full Video permissions"
        location: "Mux Dashboard > Settings > API Access Tokens"
      - task: "Create Signing Key for signed playback tokens"
        location: "Mux Dashboard > Settings > Signing Keys"
      - task: "Create Webhook endpoint pointing to https://[your-domain]/api/mux/webhooks"
        location: "Mux Dashboard > Settings > Webhooks > Add endpoint"
      - task: "Add webhook events: video.asset.ready, video.upload.asset_created, video.upload.errored"
        location: "Mux Dashboard > Settings > Webhooks > endpoint > Events"

must_haves:
  truths:
    - "Admin can list all courses (published and unpublished) via GET /api/admin/content"
    - "Admin can create a new course via POST /api/admin/content"
    - "Admin can update/delete a course via PATCH/DELETE /api/admin/content/[courseId]"
    - "Admin can add a module to a course via POST /api/admin/content/[courseId]/modules"
    - "Admin can add a lesson to a module via POST /api/admin/content/[courseId]/modules/[moduleId]/lessons"
    - "Admin can get a signed Mux upload URL via POST /api/admin/content/upload-url"
    - "Mux webhook handler verifies HMAC signature and updates lesson rows when video.asset.ready fires"
  artifacts:
    - path: "app/api/admin/content/route.ts"
      provides: "GET (list all courses) + POST (create course) for admin"
      exports: ["GET", "POST"]
    - path: "app/api/admin/content/[courseId]/route.ts"
      provides: "PATCH (update) + DELETE (delete) course for admin"
      exports: ["PATCH", "DELETE"]
    - path: "app/api/admin/content/[courseId]/modules/route.ts"
      provides: "POST (create module)"
      exports: ["POST"]
    - path: "app/api/admin/content/[courseId]/modules/[moduleId]/lessons/route.ts"
      provides: "POST (create lesson)"
      exports: ["POST"]
    - path: "app/api/admin/content/upload-url/route.ts"
      provides: "POST (create Mux direct upload URL)"
      exports: ["POST"]
    - path: "app/api/mux/webhooks/route.ts"
      provides: "POST webhook handler with HMAC verification, updates lesson on video.asset.ready"
      exports: ["POST"]
  key_links:
    - from: "app/api/admin/content/upload-url/route.ts"
      to: "lib/mux/uploads.ts"
      via: "createDirectUpload(lessonId, corsOrigin)"
      pattern: "createDirectUpload"
    - from: "app/api/mux/webhooks/route.ts"
      to: "lib/mux/client.ts"
      via: "mux.webhooks.unwrap(body, headers)"
      pattern: "mux.webhooks.unwrap"
    - from: "app/api/mux/webhooks/route.ts"
      to: "lib/db/content.ts"
      via: "updateLessonMuxFields(lessonId, { mux_asset_id, mux_playback_id, mux_status })"
      pattern: "updateLessonMuxFields"
---

<objective>
Create admin API routes for content management and the Mux webhook handler, then guide user through required Mux dashboard configuration.

Purpose: Admins need CRUD routes to create and manage courses, modules, and lessons before any content can be served. The Mux webhook handler is how lesson rows get populated with asset IDs after a video finishes processing. The user setup checkpoint captures the required Mux credentials and dashboard config steps.
Output: 6 API route files + user checkpoint for Mux dashboard setup.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/66-content-library-backend/66-RESEARCH.md
@.planning/phases/66-content-library-backend/66-02-SUMMARY.md
@lib/db/content.ts
@lib/mux/uploads.ts
@lib/mux/client.ts
@lib/auth/admin.ts
@app/api/admin/dashboard/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create admin content CRUD routes</name>
  <files>
    app/api/admin/content/route.ts,
    app/api/admin/content/[courseId]/route.ts,
    app/api/admin/content/[courseId]/modules/route.ts,
    app/api/admin/content/[courseId]/modules/[moduleId]/lessons/route.ts,
    app/api/admin/content/upload-url/route.ts
  </files>
  <action>
Create 5 admin API routes. All routes MUST check `isAdminSession()` or `isAdminRequest()` first and return 401 if not admin. Follow the exact pattern from `app/api/admin/dashboard/route.ts`.

**app/api/admin/content/route.ts** — list and create courses:
```typescript
import { NextRequest, NextResponse } from "next/server";
import { isAdminSession } from "@/lib/auth/admin";
import { adminGetCourses, adminCreateCourse } from "@/lib/db/content";
import { z } from "zod";

export async function GET() {
  if (!(await isAdminSession())) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  try {
    const courses = await adminGetCourses();
    return NextResponse.json({ courses });
  } catch (error) {
    console.error("[admin/content] GET error:", error);
    return NextResponse.json({ error: "Failed to fetch courses" }, { status: 500 });
  }
}

const CreateCourseSchema = z.object({
  title: z.string().min(1).max(200),
  description: z.string().default(""),
  slug: z.string().min(1).max(100).regex(/^[a-z0-9-]+$/, "Slug must be lowercase alphanumeric with hyphens"),
  stage: z.string().nullable().optional(),
  topic: z.string().nullable().optional(),
  thumbnail_url: z.string().url().nullable().optional(),
  tier_required: z.enum(["free", "pro", "studio"]).default("free"),
});

export async function POST(req: NextRequest) {
  if (!(await isAdminSession())) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const body = await req.json();
  const parsed = CreateCourseSchema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json({ error: parsed.error.flatten() }, { status: 400 });
  }
  try {
    const course = await adminCreateCourse(parsed.data);
    return NextResponse.json({ course }, { status: 201 });
  } catch (error) {
    console.error("[admin/content] POST error:", error);
    return NextResponse.json({ error: "Failed to create course" }, { status: 500 });
  }
}
```

**app/api/admin/content/[courseId]/route.ts** — update and delete course:
```typescript
import { NextRequest, NextResponse } from "next/server";
import { isAdminSession } from "@/lib/auth/admin";
import { adminUpdateCourse } from "@/lib/db/content";
import { createServiceClient } from "@/lib/supabase/server";
import { z } from "zod";

const UpdateCourseSchema = z.object({
  title: z.string().min(1).max(200).optional(),
  description: z.string().optional(),
  stage: z.string().nullable().optional(),
  topic: z.string().nullable().optional(),
  thumbnail_url: z.string().url().nullable().optional(),
  tier_required: z.enum(["free", "pro", "studio"]).optional(),
  is_published: z.boolean().optional(),
  sort_order: z.number().int().optional(),
});

export async function PATCH(
  req: NextRequest,
  { params }: { params: Promise<{ courseId: string }> }
) {
  if (!(await isAdminSession())) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const { courseId } = await params;
  const body = await req.json();
  const parsed = UpdateCourseSchema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json({ error: parsed.error.flatten() }, { status: 400 });
  }
  try {
    const course = await adminUpdateCourse(courseId, parsed.data);
    return NextResponse.json({ course });
  } catch (error) {
    console.error("[admin/content] PATCH error:", error);
    return NextResponse.json({ error: "Failed to update course" }, { status: 500 });
  }
}

export async function DELETE(
  _req: NextRequest,
  { params }: { params: Promise<{ courseId: string }> }
) {
  if (!(await isAdminSession())) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const { courseId } = await params;
  try {
    const supabase = createServiceClient();
    const { error } = await supabase.from("courses").delete().eq("id", courseId);
    if (error) throw error;
    return NextResponse.json({ ok: true });
  } catch (error) {
    console.error("[admin/content] DELETE error:", error);
    return NextResponse.json({ error: "Failed to delete course" }, { status: 500 });
  }
}
```

**app/api/admin/content/[courseId]/modules/route.ts** — create module:
```typescript
import { NextRequest, NextResponse } from "next/server";
import { isAdminSession } from "@/lib/auth/admin";
import { adminCreateModule } from "@/lib/db/content";
import { z } from "zod";

const CreateModuleSchema = z.object({
  title: z.string().min(1).max(200),
  description: z.string().default(""),
  sort_order: z.number().int().default(0),
});

export async function POST(
  req: NextRequest,
  { params }: { params: Promise<{ courseId: string }> }
) {
  if (!(await isAdminSession())) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const { courseId } = await params;
  const body = await req.json();
  const parsed = CreateModuleSchema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json({ error: parsed.error.flatten() }, { status: 400 });
  }
  try {
    const module = await adminCreateModule({ ...parsed.data, course_id: courseId });
    return NextResponse.json({ module }, { status: 201 });
  } catch (error) {
    console.error("[admin/content/modules] POST error:", error);
    return NextResponse.json({ error: "Failed to create module" }, { status: 500 });
  }
}
```

**app/api/admin/content/[courseId]/modules/[moduleId]/lessons/route.ts** — create lesson:
```typescript
import { NextRequest, NextResponse } from "next/server";
import { isAdminSession } from "@/lib/auth/admin";
import { adminCreateLesson } from "@/lib/db/content";
import { z } from "zod";

const CreateLessonSchema = z.object({
  title: z.string().min(1).max(200),
  description: z.string().default(""),
  sort_order: z.number().int().default(0),
  is_preview: z.boolean().default(false),
});

export async function POST(
  req: NextRequest,
  { params }: { params: Promise<{ courseId: string; moduleId: string }> }
) {
  if (!(await isAdminSession())) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const { moduleId } = await params;
  const body = await req.json();
  const parsed = CreateLessonSchema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json({ error: parsed.error.flatten() }, { status: 400 });
  }
  try {
    const lesson = await adminCreateLesson({ ...parsed.data, module_id: moduleId });
    return NextResponse.json({ lesson }, { status: 201 });
  } catch (error) {
    console.error("[admin/content/lessons] POST error:", error);
    return NextResponse.json({ error: "Failed to create lesson" }, { status: 500 });
  }
}
```

**app/api/admin/content/upload-url/route.ts** — create Mux direct upload URL:

IMPORTANT: This creates a Mux upload URL. The lesson row must already exist (was just created via POST .../lessons). Store the mux_upload_id on the lesson row as a fallback for the webhook.

```typescript
import { NextRequest, NextResponse } from "next/server";
import { isAdminSession } from "@/lib/auth/admin";
import { createDirectUpload } from "@/lib/mux/uploads";
import { updateLessonMuxFields } from "@/lib/db/content";
import { z } from "zod";

const UploadUrlSchema = z.object({
  lessonId: z.string().uuid(),
});

export async function POST(req: NextRequest) {
  if (!(await isAdminSession())) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const body = await req.json();
  const parsed = UploadUrlSchema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json({ error: parsed.error.flatten() }, { status: 400 });
  }

  const corsOrigin = process.env.NEXT_PUBLIC_APP_URL ?? "https://sahara.ai";

  try {
    const { uploadId, uploadUrl } = await createDirectUpload(parsed.data.lessonId, corsOrigin);

    // Store uploadId on lesson row immediately as fallback for webhook
    await updateLessonMuxFields(parsed.data.lessonId, {
      mux_upload_id: uploadId,
      mux_status: "pending",
    });

    return NextResponse.json({ uploadId, uploadUrl });
  } catch (error) {
    console.error("[admin/content/upload-url] POST error:", error);
    return NextResponse.json({ error: "Failed to create upload URL" }, { status: 500 });
  }
}
```

After creating all 5 files, run `npx tsc --noEmit 2>&1 | grep "app/api/admin/content" | head -20` and fix any errors.
  </action>
  <verify>`npx tsc --noEmit 2>&1 | grep "app/api/admin/content" | head -10` outputs nothing. `ls app/api/admin/content/` shows route.ts, [courseId]/, upload-url/. `grep "isAdminSession" app/api/admin/content/route.ts` shows the auth check.</verify>
  <done>5 admin API routes created, all protected by isAdminSession(), all using Zod validation, all compiling without TypeScript errors.</done>
</task>

<task type="auto">
  <name>Task 2: Create Mux webhook handler</name>
  <files>app/api/mux/webhooks/route.ts</files>
  <action>
Create `app/api/mux/webhooks/route.ts`. This handler:
1. Reads raw body as text (CRITICAL — do NOT call req.json() before signature check)
2. Verifies HMAC signature using mux.webhooks.unwrap()
3. Handles video.asset.ready — updates lesson with mux_asset_id, mux_playback_id, mux_status='ready', duration_seconds
4. Handles video.upload.asset_created — sets mux_status='processing'
5. Handles video.upload.errored — sets mux_status='error'
6. Always returns 200 for unrecognized event types (Mux expects 200 for all received webhooks)

```typescript
import { NextRequest, NextResponse } from "next/server";
import { mux } from "@/lib/mux/client";
import { updateLessonMuxFields, getLessonByUploadId } from "@/lib/db/content";

export async function POST(req: NextRequest) {
  // CRITICAL: Read raw body as text string BEFORE any parsing.
  // mux.webhooks.unwrap() requires the raw body string.
  // Calling req.json() first will break signature verification.
  const body = await req.text();

  let event: ReturnType<typeof mux.webhooks.unwrap>;
  try {
    event = mux.webhooks.unwrap(body, req.headers);
  } catch (err) {
    console.error("[mux/webhooks] Invalid signature:", err);
    return NextResponse.json({ error: "Invalid signature" }, { status: 401 });
  }

  try {
    if (event.type === "video.asset.ready") {
      const assetId = event.object.id;
      // event.data is typed by the SDK — access fields carefully
      const data = event.data as {
        passthrough?: string;
        playback_ids?: Array<{ id: string; policy: string }>;
        duration?: number;
      };

      const playbackId = data.playback_ids?.[0]?.id;
      const lessonId = data.passthrough;
      const durationSeconds = data.duration ? Math.round(data.duration) : undefined;

      if (lessonId && assetId && playbackId) {
        await updateLessonMuxFields(lessonId, {
          mux_asset_id: assetId,
          mux_playback_id: playbackId,
          mux_status: "ready",
          ...(durationSeconds !== undefined ? { duration_seconds: durationSeconds } : {}),
        });
        console.log(`[mux/webhooks] video.asset.ready: lesson ${lessonId} ready`);
      } else {
        console.warn("[mux/webhooks] video.asset.ready: missing lessonId, assetId, or playbackId", { assetId, playbackId, lessonId });
      }
    }

    if (event.type === "video.upload.asset_created") {
      const data = event.data as { passthrough?: string; upload_id?: string };
      const lessonId = data.passthrough;

      if (lessonId) {
        await updateLessonMuxFields(lessonId, { mux_status: "processing" });
        console.log(`[mux/webhooks] video.upload.asset_created: lesson ${lessonId} processing`);
      } else if (data.upload_id) {
        // Fallback: look up lesson by upload ID if passthrough was not set
        const lesson = await getLessonByUploadId(data.upload_id);
        if (lesson) {
          await updateLessonMuxFields(lesson.id, { mux_status: "processing" });
        }
      }
    }

    if (event.type === "video.upload.errored") {
      const data = event.data as { passthrough?: string };
      const lessonId = data.passthrough;
      if (lessonId) {
        await updateLessonMuxFields(lessonId, { mux_status: "error" });
        console.error(`[mux/webhooks] video.upload.errored: lesson ${lessonId} error`);
      }
    }
  } catch (err) {
    // Log but return 200 — Mux will retry on non-2xx responses
    console.error("[mux/webhooks] Handler error:", err);
  }

  // Always return 200 for received webhooks (even for unhandled event types)
  return NextResponse.json({ ok: true });
}
```

After creating the file, run `npx tsc --noEmit 2>&1 | grep "mux/webhooks" | head -10` and fix any errors.

NOTE: The `mux.webhooks.unwrap()` return type from the SDK may be a union type. If TypeScript complains about accessing `event.data`, use `as unknown as { ... }` type assertion with the specific fields needed. Do not use `any`.
  </action>
  <verify>`npx tsc --noEmit 2>&1 | grep "mux/webhooks"` outputs nothing. `grep "await req.text()" app/api/mux/webhooks/route.ts` shows raw body reading. `grep "mux.webhooks.unwrap" app/api/mux/webhooks/route.ts` shows signature verification. `grep "updateLessonMuxFields" app/api/mux/webhooks/route.ts` shows the DB update calls.</verify>
  <done>Webhook handler created with raw body reading, HMAC verification, handlers for all 3 event types, and graceful error handling that always returns 200.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    6 API routes for admin content management and Mux webhook handling:
    - GET/POST /api/admin/content (list courses, create course)
    - PATCH/DELETE /api/admin/content/[courseId] (edit/delete course)
    - POST /api/admin/content/[courseId]/modules (create module)
    - POST /api/admin/content/[courseId]/modules/[moduleId]/lessons (create lesson)
    - POST /api/admin/content/upload-url (get Mux upload URL)
    - POST /api/mux/webhooks (Mux webhook handler with HMAC signature verification)
  </what-built>
  <how-to-verify>
    **Step 1: Verify TypeScript build**
    Run: `npx tsc --noEmit 2>&1 | grep -E "admin/content|mux/webhooks"`
    Expected: zero output (no errors in these files)

    **Step 2: Set up Mux account and credentials**
    You need a Mux account. If you don't have one: https://dashboard.mux.com

    Create these credentials in the Mux Dashboard:
    1. API Access Token: Dashboard > Settings > API Access Tokens > Create
       - Enable: Mux Video (Read + Write)
       - Save MUX_TOKEN_ID and MUX_TOKEN_SECRET (shown once)

    2. Signing Key: Dashboard > Settings > Signing Keys > Create signing key
       - Save MUX_SIGNING_KEY_ID and MUX_SIGNING_PRIVATE_KEY (base64, shown once)

    3. Webhook Endpoint: Dashboard > Settings > Webhooks > Add endpoint
       - URL: https://[your-production-domain]/api/mux/webhooks
       - Events: video.asset.ready, video.upload.asset_created, video.upload.errored
       - Save MUX_WEBHOOK_SECRET (the signing secret)

    **Step 3: Add environment variables**
    Add to .env.local:
    ```
    MUX_TOKEN_ID=your_token_id_here
    MUX_TOKEN_SECRET=your_token_secret_here
    MUX_WEBHOOK_SECRET=your_webhook_signing_secret_here
    MUX_SIGNING_KEY_ID=your_signing_key_id_here
    MUX_SIGNING_PRIVATE_KEY=your_base64_private_key_here
    ```

    Also add to Vercel environment variables for production deployment.

    **Step 4: Add to .env.example**
    Check that .env.example (or .env.local.example) has placeholder entries for all 5 Mux variables.
    If not, add them (do not put real values in .env.example).

    **Note:** You can type "skip-mux" to defer Mux setup and continue with code review only.
    The content library will work once credentials are added later.
  </how-to-verify>
  <resume-signal>
    Type "approved" once Mux credentials are added to .env.local and Vercel.
    Type "skip-mux" to defer Mux setup and mark as approved for code review.
    Type "issues: [describe problems]" if something needs to be fixed first.
  </resume-signal>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit 2>&1 | grep -E "admin/content|mux/webhooks"` — zero output
2. `ls app/api/admin/content/` shows route.ts, [courseId]/, upload-url/
3. `ls app/api/mux/webhooks/` shows route.ts
4. `grep "await req.text()" app/api/mux/webhooks/route.ts` confirms raw body (not req.json())
5. `grep "isAdminSession" app/api/admin/content/route.ts` confirms admin auth check
6. `grep "createDirectUpload" app/api/admin/content/upload-url/route.ts` confirms Mux SDK usage
7. `npm run build 2>&1 | tail -10` — build should complete
</verification>

<success_criteria>
- 5 admin API routes created, all protected with isAdminSession(), all with Zod validation
- Mux webhook handler at /api/mux/webhooks reads raw body before signature check
- Webhook handler handles video.asset.ready, video.upload.asset_created, video.upload.errored
- Upload URL route stores mux_upload_id on lesson row as fallback for webhook
- All 6 files compile without TypeScript errors
- User has Mux credentials configured (or has explicitly deferred setup)
</success_criteria>

<output>
After completion, create `.planning/phases/66-content-library-backend/66-04-SUMMARY.md` with:
- Files created
- Whether Mux credentials were configured or deferred
- Any TypeScript issues and resolutions
- Webhook event types handled
</output>
