# Phase 37-01: Reality Lens Gate & Decision Sequencing

**Phase:** 37 — Reality Lens Gate & Decision Sequencing
**Plan:** 01 of 1
**Wave:** 3 (depends on Phase 36)
**Status:** PENDING
**Depends on:** Phase 36 (conversation state tracking), migration 051 (reality_lens_gate column on fred_conversation_state)
**Autonomous:** true
**Authority:** `.planning/OPERATING-BIBLE.md` Section 2.2 (Startup Reality Lens), Section 2.3 (Decision Sequencing Rule)

## Files Modified

- `lib/fred/actors/validate-input.ts` — Add downstream-request detection (deck, fundraising, hiring, patents, scaling)
- `lib/ai/prompts.ts` — Add `buildRealityLensGateBlock` for prompt-layer gate enforcement
- `lib/fred/actors/execute.ts` — Post-response Reality Lens dimension updates
- `lib/db/conversation-state.ts` — Add `updateRealityLensGate`, `getRealityLensStatus` DAL functions
- `app/api/fred/chat/route.ts` — Load Reality Lens gate status, inject gate block when downstream request detected

## Goal

Make the Reality Lens (Feasibility, Economics, Demand, Distribution, Timing) a mandatory gate before tactical or downstream advice. When a founder requests downstream work (pitch decks, patents, hiring, fundraising, scaling), FRED checks whether the **relevant** upstream dimensions have been validated. If not, FRED redirects plainly. After 2 redirects on the same request, FRED shifts to **compromise mode** — helping with the downstream work while being transparent about gaps.

This is the **non-negotiable** gate from Operating Bible Section 2.2. It is NOT a separate tool or assessment — it runs inline during natural conversation. The gate is a **conversation**, not a wall:
- Only dimensions relevant to the specific request are checked (GTM doesn't require Economics)
- Informational questions ("What is a pitch deck?") do NOT trigger the gate
- After 2 redirects, FRED compromises rather than stonewalling
- Validated dimensions can be **demoted** when contradicting evidence appears

## Key Distinction: Formal Assessment vs Conversational Gate

The codebase has TWO Reality Lens mechanisms:

1. **Formal Assessment** (`lib/fred/reality-lens.ts` + `reality_lens_analyses` table): AI-scored 0-100 per factor, full analysis with strengths/weaknesses/recommendations. Triggered explicitly. This is the heavyweight tool.

2. **Conversational Gate** (`fred_conversation_state.reality_lens_gate` JSONB, migration 051): Lightweight per-dimension status (not_assessed / assumed / weak / validated) updated during natural conversation. THIS is what Phase 37 implements.

The conversational gate determines whether FRED allows downstream work. The formal assessment is a separate, deeper dive that can be offered when the gate reveals weakness.

## Architecture

```
User asks about downstream work (e.g., "Help me with my pitch deck")
  │
  ├─ validate-input.ts
  │   └─ [NEW] Detect downstream request: deck, fundraising, hiring, patents, scaling
  │
  ├─ Chat route (prompt assembly)
  │   ├─ Load reality_lens_gate from fred_conversation_state
  │   ├─ Check: are all upstream dimensions validated?
  │   │   ├─ YES → Allow downstream work, proceed normally
  │   │   └─ NO → Inject gate block into system prompt
  │   │          "The founder is asking about [downstream]. But [dimension] is not validated.
  │   │           Redirect: address the gap before proceeding."
  │   │
  │   └─ Inject current RL gate status into system prompt (always, for context)
  │
  └─ execute.ts (post-response)
      └─ [NEW] Extract RL dimension signals from conversation
             Update reality_lens_gate JSONB when founder provides evidence
```

## Tasks

### Task 1: Add downstream-request detection to `validate-input.ts`

Detect when a founder is requesting (not just asking about) downstream artifacts that require upstream validation.

**Critical UX requirement:** Informational questions must NOT trigger the gate. "What is a pitch deck?" or "I used to work in patent law" are NOT downstream requests. Detection requires BOTH a domain keyword AND a request/action verb nearby.

```typescript
export type DownstreamRequest =
  | "pitch_deck"
  | "fundraising"
  | "hiring"
  | "patents"
  | "scaling"
  | "marketing_campaign"
  | null;

/** Verbs that indicate the founder is REQUESTING action, not just asking about a topic */
const REQUEST_VERBS = /\b(help|build|create|make|write|review|prepare|start|plan|need|want|should\s*i|how\s*(do\s*i|to|can\s*i)|ready\s*to|let'?s|work\s*on|get\s*(started|ready))\b/;

/**
 * Detect if the founder is requesting downstream work that requires
 * upstream Reality Lens validation.
 * Operating Bible Section 2.3: Never optimize downstream artifacts before
 * upstream truth is established.
 *
 * Two-gate detection:
 * 1. Domain keyword match (is the message about a downstream topic?)
 * 2. Intent check: either detected intent is "decision_request" OR a request
 *    verb is present near the keyword. This prevents false positives like
 *    "What is a pitch deck?" or "I used to work in patent law."
 */
function detectDownstreamRequest(
  message: string,
  keywords: string[],
  intent: InputIntent
): DownstreamRequest {
  const lowerMessage = message.toLowerCase();

  const patterns: Array<{ request: DownstreamRequest; signals: RegExp[] }> = [
    {
      request: "pitch_deck",
      signals: [/\b(pitch\s*deck|slide\s*deck|investor\s*deck|presentation)\b/, /\b(deck\s*review|review\s*my\s*deck)\b/],
    },
    {
      request: "fundraising",
      signals: [/\b(fundrais\w*|raise\s*(money|capital|a\s*round)|valuation|term\s*sheet|investor\s*(outreach|meeting))\b/],
    },
    {
      request: "hiring",
      signals: [/\b(hir\w+|recruit\w*|team\s*build\w*|first\s*hire|co-?founder)\b/],
    },
    {
      request: "patents",
      signals: [/\b(patent|intellectual\s*property|trademark|copyright|ip\s*protect\w*)\b/],
    },
    {
      request: "scaling",
      signals: [/\b(scal\w+|expand\w*|grow\s*the\s*(team|company|business)|series\s*[a-c]|international)\b/],
    },
    {
      request: "marketing_campaign",
      signals: [/\b(marketing\s*campaign|ad\s*spend|paid\s*ads|brand\s*strategy|pr\s*campaign)\b/],
    },
  ];

  for (const { request, signals } of patterns) {
    for (const signal of signals) {
      if (signal.test(lowerMessage)) {
        // Gate 2: Check intent — must be actionable, not just informational
        const hasRequestVerb = REQUEST_VERBS.test(lowerMessage);
        const isDecisionRequest = intent === "decision_request";
        const isQuestion = intent === "question";

        // Allow through if: decision request OR request verb present
        // Block if: purely informational question with no action verb
        if (isDecisionRequest || hasRequestVerb) {
          return request;
        }

        // Pure question without action verb — informational, skip gate
        if (isQuestion && !hasRequestVerb) {
          return null;
        }

        // For other intents (information, feedback, etc.), require request verb
        if (hasRequestVerb) {
          return request;
        }
      }
    }
  }

  return null;
}
```

Add to `ValidatedInput`:
```typescript
export interface ValidatedInput {
  // ... existing fields ...
  downstreamRequest?: DownstreamRequest;
}
```

Update the call site in `validateInputActor` to pass `intent`:
```typescript
const downstreamRequest = detectDownstreamRequest(
  sanitizedMessage,
  keywords,
  intentResult.intent  // Pass detected intent for two-gate check
);
```

### Task 2: Add Reality Lens gate DAL functions to `lib/db/conversation-state.ts`

```typescript
import type { RealityLensFactor } from "@/lib/fred/schemas/reality-lens";

export type RealityLensStatus = "not_assessed" | "assumed" | "weak" | "validated";

export interface RealityLensDimensionState {
  status: RealityLensStatus;
  score?: number;
  blockers?: string[];
  lastAssessed?: string;
}

export type RealityLensGate = Record<RealityLensFactor, RealityLensDimensionState>;

/** Tracks redirect counts per downstream request type for compromise mode escalation */
export interface GateRedirectCounts {
  [downstreamRequest: string]: number;
}

/**
 * Get the redirect count for a specific downstream request.
 * Stored in mode_context.gate_redirect_counts (JSONB).
 */
export async function getGateRedirectCount(
  userId: string,
  downstreamRequest: string
): Promise<number> {
  const { modeContext } = await getActiveMode(userId);
  const counts = (modeContext as any)?.gate_redirect_counts as GateRedirectCounts | undefined;
  return counts?.[downstreamRequest] ?? 0;
}

/**
 * Increment the redirect count for a downstream request.
 * Fire-and-forget.
 */
export async function incrementGateRedirect(
  userId: string,
  downstreamRequest: string
): Promise<void> {
  const { modeContext } = await getActiveMode(userId);
  const counts = ((modeContext as any)?.gate_redirect_counts ?? {}) as GateRedirectCounts;
  counts[downstreamRequest] = (counts[downstreamRequest] ?? 0) + 1;

  const supabase = await createServiceClient();
  await supabase
    .from("fred_conversation_state")
    .update({
      mode_context: { ...modeContext, gate_redirect_counts: counts },
      updated_at: new Date().toISOString(),
    })
    .eq("user_id", userId);
}

/**
 * Reset the redirect count for a downstream request (called when gate opens).
 */
export async function resetGateRedirect(
  userId: string,
  downstreamRequest: string
): Promise<void> {
  const { modeContext } = await getActiveMode(userId);
  const counts = ((modeContext as any)?.gate_redirect_counts ?? {}) as GateRedirectCounts;
  delete counts[downstreamRequest];

  const supabase = await createServiceClient();
  await supabase
    .from("fred_conversation_state")
    .update({
      mode_context: { ...modeContext, gate_redirect_counts: counts },
      updated_at: new Date().toISOString(),
    })
    .eq("user_id", userId);
}

/**
 * Get the current Reality Lens gate status for a user.
 * Returns the gate state or a default (all not_assessed).
 */
export async function getRealityLensGate(userId: string): Promise<RealityLensGate> {
  const state = await getOrCreateConversationState(userId);
  const gate = (state as any).realityLensGate as RealityLensGate | null;

  if (gate && Object.keys(gate).length > 0) return gate;

  // Default: all dimensions not assessed
  return {
    feasibility: { status: "not_assessed" },
    economics: { status: "not_assessed" },
    demand: { status: "not_assessed" },
    distribution: { status: "not_assessed" },
    timing: { status: "not_assessed" },
  };
}

/**
 * Update a specific Reality Lens dimension.
 */
export async function updateRealityLensDimension(
  userId: string,
  dimension: RealityLensFactor,
  update: Partial<RealityLensDimensionState>
): Promise<void> {
  const gate = await getRealityLensGate(userId);
  gate[dimension] = { ...gate[dimension], ...update, lastAssessed: new Date().toISOString() };

  const supabase = createServiceClient();
  await supabase
    .from("fred_conversation_state")
    .update({ reality_lens_gate: gate })
    .eq("user_id", userId);
}

/**
 * Map downstream requests to the RL dimensions they REQUIRE.
 * Not all downstream work requires all 5 dimensions.
 * Asking about GTM doesn't require Economics to be validated.
 * Asking about fundraising requires all 5 (investors check everything).
 */
const DOWNSTREAM_REQUIRED_DIMENSIONS: Record<string, RealityLensFactor[]> = {
  pitch_deck:         ["feasibility", "economics", "demand", "distribution", "timing"], // Investors check everything
  fundraising:        ["feasibility", "economics", "demand", "distribution", "timing"], // Same — full gate
  hiring:             ["feasibility", "demand"],                                        // Can you build it? Is there demand?
  patents:            ["feasibility", "demand"],                                        // Does it work? Does anyone need it?
  scaling:            ["demand", "economics", "distribution"],                           // Proven demand + economics + channel
  marketing_campaign: ["demand", "distribution"],                                       // Who wants it? How to reach them?
};

/**
 * Check if the RELEVANT upstream dimensions are validated for a specific
 * downstream request. Only gates on dimensions that matter for the request.
 *
 * Returns { gateOpen, weakDimensions, unassessedDimensions }.
 */
export function checkGateStatus(
  gate: RealityLensGate,
  downstreamRequest?: string | null
): {
  gateOpen: boolean;
  weakDimensions: RealityLensFactor[];
  unassessedDimensions: RealityLensFactor[];
} {
  // Determine which dimensions to check
  const relevantDimensions: RealityLensFactor[] = downstreamRequest
    ? (DOWNSTREAM_REQUIRED_DIMENSIONS[downstreamRequest] || Object.keys(gate) as RealityLensFactor[])
    : (Object.keys(gate) as RealityLensFactor[]);

  const weakDimensions: RealityLensFactor[] = [];
  const unassessedDimensions: RealityLensFactor[] = [];

  for (const dim of relevantDimensions) {
    const state = gate[dim];
    if (!state || state.status === "weak") weakDimensions.push(dim);
    if (state && state.status === "not_assessed") unassessedDimensions.push(dim);
  }

  return {
    gateOpen: weakDimensions.length === 0 && unassessedDimensions.length === 0,
    weakDimensions,
    unassessedDimensions,
  };
}
```

Note: The `realityLensGate` field must be added to the `ConversationState` interface and `transformStateRow` function. The column already exists in the DB (migration 051).

### Task 3: Add `buildRealityLensGateBlock` to `lib/ai/prompts.ts`

This is the prompt-layer enforcement. When a downstream request is detected AND the gate is not open, inject an instruction block.

**Critical UX requirement:** The gate must feel like a conversation, not a wall. After 2+ redirects on the same downstream request, FRED shifts to **compromise mode** — helping the founder do the downstream work while being transparent about the gaps. This prevents experienced founders from feeling trapped.

```typescript
import type { RealityLensFactor } from "@/lib/fred/schemas/reality-lens";
import { FACTOR_DESCRIPTIONS } from "@/lib/fred/schemas/reality-lens";

/** Redirect counter threshold before compromise mode activates */
const COMPROMISE_THRESHOLD = 2;

/**
 * Build a prompt block that enforces the Reality Lens gate.
 * Injected when the founder requests downstream work but upstream truth
 * is not established.
 *
 * Escalation path:
 * - Redirect 1: Acknowledge request, explain gaps, redirect to upstream work
 * - Redirect 2: Acknowledge persistence, reiterate gaps, redirect with urgency
 * - Redirect 3+: COMPROMISE MODE — help with the downstream work but be
 *   transparent about weaknesses. "Let me help you build a deck that's honest
 *   about where you are."
 *
 * Operating Bible Section 2.2 and 2.3.
 */
export function buildRealityLensGateBlock(
  downstreamRequest: string,
  weakDimensions: RealityLensFactor[],
  unassessedDimensions: RealityLensFactor[],
  redirectCount: number = 0
): string {
  const lines: string[] = [];
  const requestLabel = downstreamRequest.replace(/_/g, " ");

  // COMPROMISE MODE: After COMPROMISE_THRESHOLD redirects, help with caveats
  if (redirectCount >= COMPROMISE_THRESHOLD) {
    lines.push("## REALITY LENS GATE — COMPROMISE MODE (Active This Turn)");
    lines.push("");
    lines.push(`The founder has asked about **${requestLabel}** ${redirectCount + 1} times.`);
    lines.push("You have redirected them before. They are persistent. Switch to **compromise mode**.");
    lines.push("");
    lines.push("**Your response MUST:**");
    lines.push(`1. Acknowledge their persistence: "I hear you — you want to work on ${requestLabel.toLowerCase()}. Let's do it."`)
    lines.push("2. Help them with the downstream work they requested");
    lines.push("3. BUT be transparent about the gaps as you go. Weave the weaknesses INTO the work:");

    const allGaps = [...weakDimensions, ...unassessedDimensions];
    for (const dim of allGaps) {
      lines.push(`   - **${dim.charAt(0).toUpperCase() + dim.slice(1)}**: Flag this gap where it matters in the output. E.g., if building a deck with unvalidated demand, note: "This slide claims market demand — you'll need evidence here before presenting."`)
    }

    lines.push("4. End with: what would make this work STRONGER (the upstream truth they're missing)");
    lines.push("");
    lines.push("The goal is to be USEFUL while honest. A deck that's transparent about gaps is better than no deck and a frustrated founder.");

    return lines.join("\n");
  }

  // STANDARD REDIRECT MODE (redirects 1-2)
  lines.push("## REALITY LENS GATE (Active This Turn)");
  lines.push("");
  lines.push(`The founder is asking about **${requestLabel}**.`);
  lines.push("This is downstream work. The relevant upstream dimensions are not yet established.");
  lines.push("");

  if (weakDimensions.length > 0) {
    lines.push("**Weak dimensions (need strengthening):**");
    for (const dim of weakDimensions) {
      lines.push(`- **${dim.charAt(0).toUpperCase() + dim.slice(1)}**: ${FACTOR_DESCRIPTIONS[dim]}`);
    }
    lines.push("");
  }

  if (unassessedDimensions.length > 0) {
    lines.push("**Unassessed dimensions (no data yet):**");
    for (const dim of unassessedDimensions) {
      lines.push(`- **${dim.charAt(0).toUpperCase() + dim.slice(1)}**: ${FACTOR_DESCRIPTIONS[dim]}`);
    }
    lines.push("");
  }

  lines.push("**Your response MUST:**");
  lines.push("1. Acknowledge what they asked about — do not dismiss it");
  lines.push("2. Explain plainly which upstream dimensions are weak or unassessed");
  lines.push("3. Ask a specific question to address the most critical gap");
  lines.push("4. Be direct but warm — this is a conversation, not a wall");
  lines.push("");
  lines.push("Do NOT proceed with downstream work yet. But if the founder pushes back again, you will shift to helping them while being transparent about the gaps.");

  return lines.join("\n");
}

/**
 * Build a compact summary of Reality Lens gate status for the system prompt.
 * Always injected so FRED knows the current state of upstream validation.
 */
export function buildRealityLensStatusBlock(
  gate: Record<string, { status: string; score?: number; blockers?: string[] }>
): string {
  const entries = Object.entries(gate)
    .map(([dim, state]) => {
      let label = `${dim}=${state.status}`;
      if (state.score !== undefined) label += `(${state.score})`;
      return label;
    })
    .join(", ");

  return `Reality Lens: ${entries}`;
}
```

### Task 4: Wire Reality Lens gate into `app/api/fred/chat/route.ts`

In the chat route, after loading conversation state (from Phase 36-01), also load the Reality Lens gate and check it. The quick detection requires BOTH a keyword match AND a request verb (matching Task 1's intent-gated approach).

```typescript
import { getRealityLensGate, checkGateStatus, getGateRedirectCount, incrementGateRedirect } from "@/lib/db/conversation-state";
import { buildRealityLensGateBlock, buildRealityLensStatusBlock } from "@/lib/ai/prompts";

// After conversation state is loaded:

// Phase 37: Load Reality Lens gate status
let rlGateBlock = "";
let rlStatusBlock = "";
try {
  const rlGate = await getRealityLensGate(userId);
  rlStatusBlock = buildRealityLensStatusBlock(rlGate);

  // Check if downstream request detected AND gate is not open
  const downstreamRequest = detectDownstreamRequestQuick(message);
  if (downstreamRequest) {
    // Pass the specific request so only RELEVANT dimensions are checked
    const gateStatus = checkGateStatus(rlGate, downstreamRequest);
    if (!gateStatus.gateOpen) {
      // Load redirect count for compromise mode escalation
      const redirectCount = await getGateRedirectCount(userId, downstreamRequest);

      rlGateBlock = buildRealityLensGateBlock(
        downstreamRequest,
        gateStatus.weakDimensions,
        gateStatus.unassessedDimensions,
        redirectCount
      );

      // Fire-and-forget: increment redirect counter
      incrementGateRedirect(userId, downstreamRequest).catch(err =>
        console.warn("[FRED Chat] Failed to increment gate redirect:", err)
      );
    }
  }
} catch (error) {
  console.warn("[FRED Chat] Failed to load Reality Lens gate (non-blocking):", error);
}

// Append to system prompt suffix
if (rlStatusBlock) {
  systemPromptSuffix += "\n\n" + rlStatusBlock;
}
if (rlGateBlock) {
  systemPromptSuffix += "\n\n" + rlGateBlock;
}
```

Note: `detectDownstreamRequestQuick` is a lightweight version of the detection from Task 1, used in the chat route before the machine runs. This is needed because the system prompt must be assembled BEFORE the XState machine processes the message. The full `detectDownstreamRequest` in `validate-input.ts` provides the detailed result for metadata/logging.

**The quick detection includes the same two-gate check:** keyword + request verb. Purely informational questions like "What is a pitch deck?" or "I used to work in patent law" do NOT trigger the gate.

```typescript
/** Request verbs indicating founder wants ACTION, not information */
const QUICK_REQUEST_VERBS = /\b(help|build|create|make|write|review|prepare|start|plan|need|want|should\s*i|how\s*(do\s*i|to|can\s*i)|ready\s*to|let'?s|work\s*on|get\s*(started|ready))\b/;

/**
 * Quick downstream request detection for pre-machine prompt assembly.
 * Requires BOTH a domain keyword AND a request verb.
 * "What is a pitch deck?" → no match (no request verb)
 * "Help me build a pitch deck" → match (has "help" + "build" + "pitch deck")
 */
function detectDownstreamRequestQuick(message: string): string | null {
  const lowerMessage = message.toLowerCase();

  // Gate 1: Must have a request/action verb
  if (!QUICK_REQUEST_VERBS.test(lowerMessage)) return null;

  // Gate 2: Match domain keyword
  if (/\b(pitch\s*deck|investor\s*deck|deck\s*review)\b/.test(lowerMessage)) return "pitch_deck";
  if (/\b(fundrais\w*|raise.*capital|valuation|term\s*sheet)\b/.test(lowerMessage)) return "fundraising";
  if (/\b(hir\w+|recruit\w*|first\s*hire)\b/.test(lowerMessage)) return "hiring";
  if (/\b(patent|ip\s*protect\w*)\b/.test(lowerMessage)) return "patents";
  if (/\b(scal\w+|series\s*[a-c])\b/.test(lowerMessage)) return "scaling";
  if (/\b(marketing\s*campaign|ad\s*spend|paid\s*ads)\b/.test(lowerMessage)) return "marketing_campaign";
  return null;
}
```

### Task 5: Post-response Reality Lens dimension updates in `execute.ts`

After each response, extract signals that indicate progress (or regression) on Reality Lens dimensions.

**Critical UX fix: Demotion path.** Once a dimension is validated, it must NOT stay validated forever if contradicting evidence appears. If a founder says "Actually, we pivoted and have no customers anymore," the demand dimension should be demoted from `validated` back to `weak`.

Demotion rules:
- `validated` can be demoted to `weak` (not back to `not_assessed` — we know something about it)
- `assumed` can be demoted to `weak`
- `weak` can be demoted to `not_assessed` only if the founder explicitly says the dimension doesn't apply
- Demotion requires NEGATIVE signals (contradiction, loss, pivot), not just absence of positive signals

```typescript
import { updateRealityLensDimension, getRealityLensGate } from "@/lib/db/conversation-state";
import type { RealityLensFactor } from "@/lib/fred/schemas/reality-lens";

/**
 * Extract Reality Lens dimension signals from the conversation.
 * Updates dimension status based on what the founder has shared.
 * Supports both PROMOTION (evidence strengthens dimension) and
 * DEMOTION (contradicting evidence weakens dimension).
 * Fire-and-forget.
 */
async function updateRealityLensDimensions(
  userId: string,
  validatedInput: ValidatedInput
): Promise<void> {
  const msg = validatedInput.originalMessage.toLowerCase();
  const entities = validatedInput.entities;

  // Load current gate state for demotion checks
  const currentGate = await getRealityLensGate(userId);

  // ─── Promotion signals (evidence strengthens dimension) ─────────────

  // Demand signals
  if (/\b(customer\w*|user\w*|buyer\w*)\b.*\b(interview|talk|spoke|feedback)\b/.test(msg) ||
      /\b(waitlist|pre-?order|loi|letter\s*of\s*intent)\b/.test(msg)) {
    await updateRealityLensDimension(userId, "demand", { status: "assumed" });
  }
  if (/\b(paying|revenue|mrr|arr)\b/.test(msg) && entities.some(e => e.type === "money")) {
    await updateRealityLensDimension(userId, "demand", { status: "validated" });
  }

  // Economics signals
  if (/\b(unit\s*economics|margin|cac|ltv|cost\s*per)\b/.test(msg)) {
    await updateRealityLensDimension(userId, "economics", { status: "assumed" });
  }
  if (/\b(profitable|positive\s*margin|ltv.*cac|cac.*ltv)\b/.test(msg) && entities.some(e => e.type === "money")) {
    await updateRealityLensDimension(userId, "economics", { status: "validated" });
  }

  // Feasibility signals
  if (/\b(built|launched|prototype|mvp|working\s*product|live)\b/.test(msg)) {
    await updateRealityLensDimension(userId, "feasibility", { status: "validated" });
  }
  if (/\b(building|developing|coding|designing)\b/.test(msg)) {
    await updateRealityLensDimension(userId, "feasibility", { status: "assumed" });
  }

  // Distribution signals
  if (/\b(channel|distribution|go.?to.?market|sales\s*process|acquisition)\b/.test(msg)) {
    await updateRealityLensDimension(userId, "distribution", { status: "assumed" });
  }

  // Timing signals
  if (/\b(market\s*(shift|trend|growing)|regulation|technology.*ready|competitor.*just)\b/.test(msg)) {
    await updateRealityLensDimension(userId, "timing", { status: "assumed" });
  }

  // ─── Demotion signals (contradicting evidence weakens dimension) ────

  // Demand demotion: pivot, lost customers, no customers
  if (/\b(pivot\w*|no\s*(customers?|users?|buyers?)|lost\s*(all|most|our)\s*(customers?|users?)|churn\w*\s*(all|most|100))\b/.test(msg)) {
    const current = currentGate.demand?.status;
    if (current === "validated" || current === "assumed") {
      await updateRealityLensDimension(userId, "demand", {
        status: "weak",
        blockers: ["Founder indicated loss of customers or pivot — demand needs revalidation"],
      });
    }
  }

  // Feasibility demotion: technical failure, can't build it
  if (/\b(can'?t\s*build|technically\s*(impossible|infeasible)|failed\s*to\s*(build|launch|ship)|scrapped\s*(the\s*)?(product|mvp|prototype))\b/.test(msg)) {
    const current = currentGate.feasibility?.status;
    if (current === "validated" || current === "assumed") {
      await updateRealityLensDimension(userId, "feasibility", {
        status: "weak",
        blockers: ["Founder indicated technical difficulty or product failure — feasibility needs reassessment"],
      });
    }
  }

  // Economics demotion: burning cash, negative margins
  if (/\b(burn\w*\s*(rate|cash|through)|negative\s*margin|losing\s*money\s*on\s*every|unsustainable\s*(economics|cost))\b/.test(msg)) {
    const current = currentGate.economics?.status;
    if (current === "validated" || current === "assumed") {
      await updateRealityLensDimension(userId, "economics", {
        status: "weak",
        blockers: ["Founder indicated unsustainable economics — needs reassessment"],
      });
    }
  }

  // Distribution demotion: channel died, lost partnership
  if (/\b(channel\s*(died|stopped|no\s*longer)|lost\s*(our|the)\s*(partner|distribution|channel)|can'?t\s*reach\s*(customers?|buyers?))\b/.test(msg)) {
    const current = currentGate.distribution?.status;
    if (current === "validated" || current === "assumed") {
      await updateRealityLensDimension(userId, "distribution", {
        status: "weak",
        blockers: ["Founder indicated distribution channel loss — needs new path"],
      });
    }
  }
}
```

Call this from the post-response state update function in `execute.ts` (alongside the existing diagnostic tag and snapshot updates from Phase 36-02 Task 5):

```typescript
// In updateConversationState (Phase 36-02 Task 5):
// Add after the diagnostic tag and snapshot updates:

// 4. Update Reality Lens dimensions from conversation signals
await updateRealityLensDimensions(userId, validatedInput);
```

### Task 6: Add Reality Lens gate status to `ConversationState` type

Update `lib/db/conversation-state.ts`:

```typescript
export interface ConversationState {
  // ... existing fields ...
  realityLensGate: RealityLensGate;
}
```

Update `transformStateRow` to include the new field:

```typescript
function transformStateRow(row: Record<string, unknown>): ConversationState {
  return {
    // ... existing fields ...
    realityLensGate: (row.reality_lens_gate as RealityLensGate) || {
      feasibility: { status: "not_assessed" },
      economics: { status: "not_assessed" },
      demand: { status: "not_assessed" },
      distribution: { status: "not_assessed" },
      timing: { status: "not_assessed" },
    },
  };
}
```

## How 9-Step Process Maps to Reality Lens Dimensions

For context on how the two systems interact:

| Reality Lens Dimension | 9-Step Process Steps | What Validates It |
|----------------------|---------------------|-------------------|
| Demand | Steps 1 (Problem), 2 (Buyer), 5 (Validation) | Real customer conversations, LOIs, pre-orders, usage data |
| Economics | Steps 4 (Solution), 5 (Validation) | Unit economics data, margin analysis, pricing validation |
| Feasibility | Steps 3 (Founder Edge), 4 (Solution) | Working product, prototype, technical capability |
| Distribution | Step 6 (GTM) | Defined channel, early customer acquisition path |
| Timing | Steps 1-2 (Problem + Buyer context) | Market trend evidence, competitive timing analysis |

FRED uses the 9-Step Process to guide the conversation sequentially. The Reality Lens Gate checks whether enough upstream dimensions are validated before allowing downstream work. They work in parallel but serve different purposes.

## Verification

- [ ] `detectDownstreamRequest` identifies pitch deck, fundraising, hiring, patents, scaling, marketing campaign requests
- [ ] Downstream detection uses word-boundary regex (no false positives)
- [ ] **Downstream detection requires BOTH keyword AND request verb** — "What is a pitch deck?" does NOT trigger the gate
- [ ] **Downstream detection with intent gating** — `intent=question` without request verb is skipped
- [ ] `getRealityLensGate` returns current gate status from fred_conversation_state
- [ ] **`checkGateStatus` accepts optional downstream request and checks only RELEVANT dimensions**
- [ ] `checkGateStatus("hiring")` only checks feasibility + demand, NOT all 5 dimensions
- [ ] `checkGateStatus("fundraising")` checks all 5 dimensions (investors check everything)
- [ ] `buildRealityLensGateBlock` produces clear gate enforcement instructions for the system prompt
- [ ] Gate enforcement is prompt-driven (language generated by LLM, not hardcoded)
- [ ] **Redirect counter tracks per-request type** (e.g., 2 redirects on "pitch_deck" doesn't affect "hiring" count)
- [ ] **After 2 redirects, COMPROMISE MODE activates** — FRED helps with downstream work while being transparent about gaps
- [ ] **Compromise mode prompt instructs FRED to weave gaps into the work** (e.g., "This slide claims demand — you'll need evidence here")
- [ ] `buildRealityLensStatusBlock` produces compact status line for always-on context
- [ ] Chat route loads RL gate status and injects gate block when downstream request + gate not open
- [ ] Chat route quick detection requires keyword + request verb (same two-gate check as validate-input.ts)
- [ ] Post-response RL dimension updates extract demand, economics, feasibility, distribution, timing signals
- [ ] **Demotion path works:** pivot/customer loss demotes demand from validated to weak
- [ ] **Demotion path works:** technical failure demotes feasibility from validated to weak
- [ ] **Demotion path works:** unsustainable economics demotes economics from validated to weak
- [ ] **Demotion path works:** lost distribution channel demotes distribution from validated to weak
- [ ] **Demotion adds blockers array** explaining why the dimension was weakened
- [ ] RL dimension updates are fire-and-forget (never block the response)
- [ ] `ConversationState` type includes `realityLensGate` field
- [ ] Default gate state is all dimensions "not_assessed"
- [ ] Dimension status progression: not_assessed -> assumed -> validated (or weak if evidence is negative)
- [ ] **Dimension status demotion:** validated -> weak, assumed -> weak (when contradicting evidence appears)
- [ ] When gate IS open (all relevant dimensions validated), downstream requests proceed normally
- [ ] Formal Reality Lens assessment (`reality_lens_analyses` table) is NOT triggered by the gate — it remains a separate, explicit tool
- [ ] `npx tsc --noEmit` passes
- [ ] Existing chat API contract preserved
- [ ] Existing tests pass

## Must-Haves

1. Gate enforcement is prompt-driven — the instruction tells the LLM what gaps exist and to redirect, the LLM generates the actual language
2. Gate check does NOT block the response if loading fails — graceful fallback to no gate (allow downstream work)
3. Quick downstream detection in chat route must be fast — regex only, no AI calls before the machine runs
4. RL dimension updates are conservative — "assumed" requires mention of evidence, "validated" requires concrete data (numbers, customer quotes, LOIs)
5. The gate is a CONVERSATION-level mechanism, not a formal assessment — it does not replace `reality-lens.ts` formal scoring
6. **Intent-gated downstream detection** — BOTH a domain keyword AND a request/action verb are required. "What is a pitch deck?" (informational) does NOT trigger the gate. "Help me build my pitch deck" (actionable) DOES
7. No new database tables — uses existing `reality_lens_gate` JSONB column on `fred_conversation_state` (migration 051). Redirect counts stored in `mode_context` JSONB (no new columns)
8. All RL gate state updates are fire-and-forget
9. **Per-request dimension relevance** — only dimensions RELEVANT to the specific downstream request are gated. Asking about GTM does not require Economics to be validated. Fundraising/pitch deck require all 5 (investors check everything)
10. **Compromise mode after 2 redirects** — FRED shifts from blocking to helping with caveats. The gate is a conversation, not a wall. After 2 redirects on the same request type, FRED helps with the downstream work while being transparent about gaps
11. **Demotion path exists** — validated dimensions can be demoted to `weak` when contradicting evidence appears (pivot, customer loss, technical failure). Demotion requires NEGATIVE signals, not just absence of positive ones. Demotion adds `blockers` explaining why
