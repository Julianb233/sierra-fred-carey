---
phase: 04-studio-tier
plan: 06
type: execute
wave: 4
depends_on: ["04-01"]
files_modified:
  - lib/boardy/client.ts
  - lib/boardy/types.ts
  - lib/boardy/mock.ts
  - lib/db/boardy.ts
  - app/api/boardy/match/route.ts
  - app/api/boardy/callback/route.ts
  - components/boardy/match-list.tsx
  - components/boardy/boardy-connect.tsx
  - app/dashboard/boardy/page.tsx
autonomous: true

must_haves:
  truths:
    - "Studio users can view suggested investor/advisor matches"
    - "Match suggestions are generated from user profile and startup data"
    - "Users can connect to Boardy via deep link"
    - "Match status can be updated (connected, intro_sent, meeting_scheduled, declined)"
    - "Integration is abstracted behind an interface that can swap mock for real API"
  artifacts:
    - path: "lib/boardy/client.ts"
      provides: "Boardy integration client (abstraction layer)"
      exports: ["BoardyClient", "getBoardyClient"]
    - path: "lib/boardy/types.ts"
      provides: "Boardy match types"
      exports: ["BoardyMatch", "BoardyMatchType", "BoardyMatchStatus"]
    - path: "lib/boardy/mock.ts"
      provides: "Mock Boardy implementation using AI generation"
      exports: ["MockBoardyClient"]
    - path: "lib/db/boardy.ts"
      provides: "CRUD for boardy_matches table"
      exports: ["createMatch", "getMatches", "updateMatchStatus"]
    - path: "app/dashboard/boardy/page.tsx"
      provides: "Boardy integration dashboard page"
    - path: "components/boardy/match-list.tsx"
      provides: "Match list UI component"
    - path: "components/boardy/boardy-connect.tsx"
      provides: "Boardy connection/deep-link component"
  key_links:
    - from: "app/api/boardy/match/route.ts"
      to: "lib/boardy/client.ts"
      via: "uses BoardyClient to get matches"
      pattern: "getBoardyClient|getMatches"
    - from: "lib/boardy/client.ts"
      to: "lib/boardy/mock.ts"
      via: "delegates to mock implementation"
      pattern: "MockBoardyClient"
    - from: "app/dashboard/boardy/page.tsx"
      to: "app/api/boardy/match/route.ts"
      via: "fetches matches from API"
      pattern: "fetch.*api/boardy"
---

<objective>
Build the Boardy integration for investor/advisor matching. Since Boardy has no public API, this creates an abstraction layer with a mock implementation that uses AI to generate contextual match suggestions. The interface is designed so a real Boardy API can be swapped in when available.

Purpose: Investor/advisor matching is a key Studio tier value proposition. Even without a live Boardy API, AI-generated match suggestions based on the founder's profile provide real value.

Output: Boardy abstraction layer, mock client, match database operations, API endpoints, and dashboard page.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/04-studio-tier/04-RESEARCH.md
@.planning/phases/04-studio-tier/04-01-SUMMARY.md
@lib/db/migrations/030_boardy_matches.sql (from Plan 01)
@lib/ai/fred-client.ts (generateStructuredReliable for AI match generation)
@lib/constants.ts (UserTier, DASHBOARD_NAV)
@components/tier/feature-lock.tsx (tier gating UI)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Boardy abstraction layer and mock client</name>
  <files>
    lib/boardy/types.ts
    lib/boardy/client.ts
    lib/boardy/mock.ts
    lib/db/boardy.ts
  </files>
  <action>
**lib/boardy/types.ts:**
Export types matching the database schema:
- `BoardyMatchType` = 'investor' | 'advisor' | 'mentor' | 'partner'
- `BoardyMatchStatus` = 'suggested' | 'connected' | 'intro_sent' | 'meeting_scheduled' | 'declined'
- `BoardyMatch` interface: { id, userId, matchType, matchName, matchDescription, matchScore, status, boardyReferenceId?, metadata, createdAt, updatedAt }
- `MatchRequest` interface: { userId: string, startupStage: string, sector: string, fundraisingTarget?: string, matchTypes: BoardyMatchType[], limit?: number }
- `BoardyClientInterface` interface with methods: `getMatches(request: MatchRequest): Promise<BoardyMatch[]>`, `refreshMatches(userId: string): Promise<BoardyMatch[]>`, `getDeepLink(userId: string): string`

**lib/boardy/client.ts:**
Create the abstraction layer:
- `export class BoardyClient implements BoardyClientInterface` -- delegates to the underlying implementation
- Constructor takes an implementation (BoardyClientInterface)
- `export function getBoardyClient(): BoardyClient` -- factory function. Check `process.env.BOARDY_API_KEY` -- if set, use real client (future). Otherwise, use MockBoardyClient.
- This is the strategy pattern: swap implementations without changing callers.

**lib/boardy/mock.ts:**
Create `MockBoardyClient implements BoardyClientInterface`:
- `getMatches(request)`: Use `generateStructuredReliable` from fred-client to generate investor/advisor matches based on the request parameters. Schema: array of { matchName, matchType, matchDescription, matchScore (0-1), reasoning }. Limit to request.limit or default 5. Store generated matches in DB via `createMatch()` and return them.
- `refreshMatches(userId)`: Generate new matches based on stored user profile data. Delete old 'suggested' matches and create new ones.
- `getDeepLink(userId)`: Return `https://www.boardy.ai/?ref=sahara&uid=${userId}` -- a referral deep link to Boardy's platform.

The mock client should produce REALISTIC match suggestions. System prompt for generateStructuredReliable:
"Generate realistic investor/advisor match suggestions for a startup founder. Each match should have a real-sounding name, firm, and specific reasoning for why they're a good fit based on the founder's stage ({stage}), sector ({sector}), and fundraising goals."

**lib/db/boardy.ts:**
CRUD operations:
- `createMatch(params: Omit<BoardyMatch, 'id' | 'createdAt' | 'updatedAt'>): Promise<BoardyMatch>` - INSERT
- `getMatches(userId: string, opts?: { matchType?, status?, limit? }): Promise<BoardyMatch[]>` - SELECT with filters
- `updateMatchStatus(matchId: string, status: BoardyMatchStatus): Promise<BoardyMatch>` - UPDATE status
- `deleteMatchesByStatus(userId: string, status: BoardyMatchStatus): Promise<void>` - DELETE (for refresh)
  </action>
  <verify>TypeScript compiles. Mock client produces structured matches via AI. Strategy pattern allows swapping implementations.</verify>
  <done>Boardy abstraction layer with mock client generates AI-powered match suggestions. Interface ready for real API when available.</done>
</task>

<task type="auto">
  <name>Task 2: Boardy API endpoints and dashboard UI</name>
  <files>
    app/api/boardy/match/route.ts
    app/api/boardy/callback/route.ts
    components/boardy/match-list.tsx
    components/boardy/boardy-connect.tsx
    app/dashboard/boardy/page.tsx
  </files>
  <action>
**app/api/boardy/match/route.ts:**
GET handler:
1. requireAuth() to get userId
2. Check Studio tier (return 403 if not)
3. Parse query params: matchType (optional), status (optional)
4. Get matches from DB via `getMatches(userId, { matchType, status })`
5. If no matches exist, generate initial matches via `getBoardyClient().getMatches({ userId, startupStage, sector, matchTypes: ['investor', 'advisor'] })`
6. Return 200 with { matches: [...] }

POST handler - refresh matches:
1. requireAuth() + Studio tier check
2. Call `getBoardyClient().refreshMatches(userId)`
3. Return 200 with new matches

**app/api/boardy/callback/route.ts:**
POST handler - for future Boardy webhooks/callbacks:
1. For now, accept status updates: `{ matchId: string, status: BoardyMatchStatus }`
2. requireAuth()
3. Validate matchId belongs to user
4. Call `updateMatchStatus(matchId, status)`
5. Return 200

**components/boardy/match-list.tsx:**
`MatchList` component:
- Props: `{ matches: BoardyMatch[], onStatusUpdate: (matchId: string, status: BoardyMatchStatus) => void }`
- Render matches as cards in a grid
- Each card shows: match name, type (badge), description, match score (as percentage), status
- Action buttons per status: suggested -> "Connect" (sets to 'connected'), connected -> "Request Intro" (sets to 'intro_sent'), intro_sent -> "Schedule Meeting" (sets to 'meeting_scheduled')
- "Decline" button always available for non-declined matches
- Match score shown as a colored bar (green >0.8, yellow 0.5-0.8, orange <0.5)
- Type badges: investor=blue, advisor=purple, mentor=green, partner=orange

**components/boardy/boardy-connect.tsx:**
`BoardyConnect` component:
- Props: `{ deepLink: string }`
- Card with Boardy branding explanation: "Boardy AI matches you with investors and advisors through AI-powered introductions"
- "Connect with Boardy" button that opens the deep link in a new tab
- Brief description of how the matching works
- Note: "Matches are generated based on your startup profile and fundraising stage"

**app/dashboard/boardy/page.tsx:**
"use client" page:
1. Fetch matches from `/api/boardy/match` on mount
2. Show BoardyConnect component at top
3. Show MatchList component below with fetched matches
4. "Refresh Matches" button that POSTs to `/api/boardy/match` and reloads
5. Tier gating: if not Studio tier, show FeatureLock component
6. Page title: "Investor & Advisor Matching" with subtitle "AI-powered connections to the right people"
7. Loading skeleton while fetching
8. Filter tabs: All | Investors | Advisors | Active | Declined
  </action>
  <verify>Page renders at /dashboard/boardy. Matches display in cards. Status updates work. Tier gating enforced. `npm run build` succeeds.</verify>
  <done>Boardy dashboard shows AI-generated matches with status workflow. Users can connect via deep link. Match refresh generates new suggestions.</done>
</task>

</tasks>

<verification>
- lib/boardy/ has client.ts, types.ts, mock.ts
- lib/db/boardy.ts has all CRUD operations
- GET /api/boardy/match returns matches (generates initial on first request)
- POST /api/boardy/match refreshes matches
- /dashboard/boardy page renders with match cards and status actions
- Studio tier gating works
- `npm run build` succeeds
</verification>

<success_criteria>
- Boardy abstraction layer allows mock/real implementation swap
- AI-generated matches are realistic and contextual
- Match status workflow tracks investor/advisor relationship progression
- Dashboard shows matches with filter tabs and action buttons
- Deep link directs users to Boardy platform
</success_criteria>

<output>
After completion, create `.planning/phases/04-studio-tier/04-06-SUMMARY.md`
</output>
